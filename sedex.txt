SA+VegDItto lockscreen kbdin pis0856polsiren

	
EDUCBA

EDUCBA

    Free Tutorials
    Free Courses
    Certification Courses
    600+ Courses All in One Bundle
    Login

SED Command in Linux
Home » Software Development » Software Development Tutorials » Linux Tutorial » SED Command in Linux

SED Command in Linux
Introduction to SED Command in Linux

The following article provides an outline for SED Command in Linux. SED as text manipulation tool that we use regularly and we think a lot of shell script is use regularly and SED stands for stream editor and basically allows you to manipulate text files substituting, replacing, searching, inserting, deleting without opening the files. Moreover, SED enables us to use a regular expression to match the expression within the file and perform text manipulation.

Syntax:

sed OPTIONS [SCRIPT] INPUTFILE

Some options available are:

    -n, –quiet, –silent: Suppress automatic printing of pattern space.
    -f script-file, –file=script-file: Add script file.
    -e script, –expression=script: Add the script to the commands to be executed.
    -l N, –line-length=N: Specify the desired line-wrap length, N, for the “l” command.

Examples of SED Command in Linux

Given below are the examples of SED Command in Linux:
Example #1

Code:

cat test|sed 's/t/T'

Output:

SED Command in Linux 1

Explanation:

    We’re going to say substitute forward slash forward slash forward slash. We’re going to give in between the first and second forward slash what we want to replace, what string we want to replace, and the second one what we’re going to replace it with, so for example, I can say T here and then here I can put an uppercase T because we’re gonna be replacing the lowercase T’s with uppercase T’s if I hit enter at this point we’ll see the lines from the text file. Still, we have only modified the first T in each line to be capital; you’ll notice that the second T and the third T and the other T on that line doesn’t work, so basically, at this point, we haven’t modified the original file.

Example #2

Code:

sed 's/t/T/g text

Output:

SED Command in Linux 2

Explanation:

    G, which stands for global, meaning find all the lowercase T’s and transform them, so there we go that’s what we’ve got now we’ve got every T is now an uppercase T on every line again we have not modified the actual file yet.

Example #3

Code:

sed 's/t/T/g text>new.txt

Explanation:

    We can create a new file by redirecting into it so we can take the output of this and put it into new.txt or whatever you want to call it, so now we can cat out new.txt.

Example #4

Code:

sed -i 's/t/T/g text
Cat text

Output:

SED Command in Linux 3

Explanation:

    The original file is now changed.

Example #5

Code:

sed 's/^t/oooo/g text

Output:

10 tiny toes

Explanation:

    So let’s say I just wanted to replace the T at the beat that starts at the beginning of each line, so that would be this and tree are both beginning the lines, so we’re looking for a T at the beginning of the line what we can do here is we can give it the caret symbol which on a standard keyboard most no difficult of different keyboards but it’s over the six on most keyboards. So now it’s saying this caret indicates the beginning of lines, so it’s saying we’re looking for the beginning in line T. Hence, it’s still kind of like it’s part of the string you know it’s we’re and what we’re going to do is we’re going to replace it with oooo so now I’ll hit enter once again we’re not we don’t have our – I in here so we do not modify the original file we’re just displaying it differently we’re going to enter here. You can see that not all of our T’s have been replaced but only the T’s that are at the beginning of each line.

Example #6

Code:

sed 's/t$/oooo/g text

Explanation:

    We can do the same thing with the end of a line now the caret symbol indicates the beginning of the line well a dollar sign indicates the end of a line, so this is going to find every line that ends with a T because it’s going to be T and then the end of the line and we’re going to replace that with oooo. I’ll hit enter, and you can see we get the T right there; oh, and we can do it with ease as well; in this case, we’ll or any string. Still, we have three the ends and E and twice the ends in E, and they’re both at the end aligned we’d enter, and you can see we’ve got o and O there, and of course, if we did two E’s it would only affect the three because there’s only one e and twice and then the end of the line.

Example #7

Code:

sed 's/[0-9]/*/g text

Output:

Tiny toes

Explanation:

    We’re looking for, I can say inside square brackets here 0-9 meaning look at all numeric characters, and I can say replace every numeric character, so we’re not looking at alpha characters are not looking at the letters in the alphabet we’re looking at numbers and replace them with a strict and that’s within the text file again there’s no – I hear someone up modifying the file just changing the output, and you can see everywhere that there was a number there is now an asterisk now I can do the same thing with a dash Z.

Example #8

Code:

sed 's/[a-zA-Z]/*/g' text

Output:

SED Command in Linux 6

Explanation:

    Searching [a-zA-Z] and replacing with *.

Example #9

Code:

sed 's/[A-Z]i/*/g' text

Output:

toes

Explanation:

    We’ll say replace all capital letters that are followed by an I, so here we it replaced the T and the I because it’s looking for both those things and replacing it with that it’s not looking for one or the other it’s looking for the two together and the only place where an eye follows a capital letter was the word tiny.

Conclusion

We have seen step by step definition and example using the SED command about replacing string and finding and replacing or redirecting the result to a new file or modifying the same file.
Recommended Articles

This is a guide to SED Command in Linux. Here we discuss the introduction to SED Command in Linux along with examples respectively. You may also have a look at the following articles to learn more –

    Linux Ping
    Linux nslookup
    Linux Size
    Linux Repository

All in One Software Development Bundle (600+ Courses, 50+ projects)

600+ Online Courses

50+ projects

3000+ Hours

Verifiable Certificates

Lifetime Access

Learn More
0 Shares
Share
Tweet
Share
Primary Sidebar
Linux Tutorial

    Linux Commands
        Linux install Command
        Linux Locate Command
        Linux Shutdown Command
        CAT Command in Linux
        SED Command in Linux
        df Command in Linux
        Cut Command in Linux
        Linux Reboot Command
        PS command in Linux
        Mkdir Command in Linux
        rmdir command in Linux
        mv command in Linux
        Linux rm Command
        CHMOD Command in Linux
        Linux chmod recursive
        Zip Command in Linux
        Linux Route Command
        SCP Command in Linux
        du Command in Linux
        Less Command in Linux
        Copy Command in Linux
        Head Command in Linux
        Help Command in Linux
        Linux History Command
        Linux Find Command
        hostname Command in Linux
        GREP Command in Linux
        Linux man Command
        Linux Curl Command
        Linux List Users
        Linux List Directories
        Linux Directory Permissions
        Find Directory Linux
        Linux User Permission
        Linux Add User
        Linux Delete User
        Linux uniq
        Linux Filter Commands
        Linux sort Command
        Linux Sort by Size
        Remove dir Linux
        Linux tr Command
        Linux Touch Command
        Linux Nice Command
        Linux More Command
        Linux Cal Command
        Linux OD
        Linux Zcat
        Linux tracepath
        Linux Relative Path
        Linux Sleep
        Linux bg Command
        Linux WC
        Linux Read
        Linux Write
        Linux Rename Command
        Linux Free Command
        Linux tac
        Linux Shred
        Linux wget
        Linux Date
        Linux Untar
        Linux JQ
        Linux Xargs
        Linux Mount Command
        Linux mdadm
        Linux comm
        Linux tee Command
        Tail Command in Linux
        Linux gzip
        Linux Directory Structure
        Linux Alias Command
        Linux Export
        Linux netstat
        Linux traceroute
        Linux Inode
        Linux Ping
        Linux Pipe Command
        Linux Watch Command
        Linux Terminate Process
        Linux Home Directory
        Linux Nohup
        Linux Split Command
        Linux Size
        Linux Network Stack
        Linux Network Manager
        Linux Diff Command
        Vim Command in Linux
        Linux nslookup

    Basic
        Introduction to Linux
        What is Linux
        Careers in Linux
        How to Install Linux
        How to Install Ubuntu
        How to Install Ubuntu Server
        How To Install Debian
        Advantage Of Linux
        What is Raid in Linux
        What is Raid 5?
        Raid 5 vs Raid 6
        Careers in Linux Administration
        What is Shell in Linux?
        Bash Shell in Linux
        Linux Emulator
        Linux Operators
        Linux uptime
        Linux Apps
        Linux PDF Editor
        Linux Keyboard Shortcuts
        Linux Crontab
        What is Raid Storage
        What is Vmware
        What is RedHat
        What is Debian
        Uses of Ubuntu
        Career In RedHat
        Linux Distributions
        Linux From Scratch
        Linux Format
        sqlplus in linux
        Linux Environment Variables
        Cheat Sheet Linux
        Linux QT
        Linux Unzip Zip File
        Linux Disk Space
        Linux remote desktop
        Linux GUI
        Linux restart
        Linux hex editor
        Linux KVM
        Linux XFCE
    Advanced
        What is Linux Used For
        Kali Linux Terminal
        Linux PAM
        Linux pkill
        Linux Exit
        Linux id
        Linux Umask
        Crontab in Linux
        Linux kernel
        Linux Rsync
        Kali Linux Tools
        Linux wildcards
        Exec Linux
        Linux Symbolic Link
        Install VMware
        Linux User Mode
        Install GRUB
        Kali Linux VMware
        Cron timing format
        Cron validator
        Cron in Linux
        Cron Job Scheduler
        Cron Command
        Cron Weekly
        Chown Command in Linux
        Linux Network Command
        Configuring Linux Network Environment
        DNS Configuration in Linux
        Linux Users
        Create User in Linux
        DHCP Server in Linux
        FTP Server in Linux
        Linux Regular Expression
        IP Command in Linux
        GNU in Linux
        Set IP Address in Linux
        Tar Command in Linux
        Dynamic Host Configuration Protocol
        Linux Kill Signals
        Linux File Permissions
        Linux File System
        Linux Create File
        Linux Concatenate Files
        Linux Join
        Linux Process Management
        Linux Proxy Server
        Linux System Commands
        Linux System Logging
        NFS in Linux
        What is NFS
        Linux LVM
        Nautilus Linux
        Linux mtr
        Linux While Loop
        Linux Remove Directory and Contents
        Linux Repository
        Samba Server in Linux
        Top Commands in Linux
        Types of Shells in Linux
        Shell Script Types For Linux
        GCC Command in Linux
        Monolithic Kernel
        YARN Package Manager
        Linux Sed Replace
        Linux List Groups
        Linux Container
        Linux Find File by Name
        Create Folder in Linux
        Linux Move Folder
        Linux Error Codes
        Linux Automount
        Linux HugePages
        Linux Manual Pages
        Linux iptables
        CP Command?in Linux
        Linux Zip Multiple Files
        Linux XRDP
        Alpine linux packages
        Void Linux Packages
        Linux Terminal
        Linux Time
        Why Is It Important To Red Hat Linux Certification?
        Linux Chgrp
    Kali Linux
        Install Kali Linux
        Kali Linux Uses
        Kali Linux tools list
        Kali Linux Commands
        Kali Linux Repository
        Kali Linux Packages
        Kali Linux root password
        Kali Linux GNOME
        Kali Linux SSH
        Kali Linux KDE
        Kali Linux NetHunter
        Kali Linux Metasploit
        Kali Linux Nmap
        Kali Linux Alternative
    CentOS
        CentOS Commands
        CentOS packages
        CentOS package manager
        CentOS useradd
        CentOS add sudo user
        Centos Repositories
        CentOS kill process
        CentOS List Users
        CentOS Set Timezone
        CentOS netstat
        CentOS NetworkManager
        CentOS disable firewall
    Interview Questions
        Linux Interview Questions
        Linux System Administration Interview
        Red Hat Interview Questions


Related Courses
Kali Linux Training
Linux Training Course
Red Hat Training Course
Footer
About Us

    Blog
    Who is EDUCBA?
    Sign Up
    Live Classes
    Corporate Training
    Certificate from Top Institutions
    Contact Us
    Verifiable Certificate
    Reviews
    Terms and Conditions
    Privacy Policy
     

Apps

    iPhone & iPad
    Android

Resources

    Free Courses
    Java Tutorials
    Python Tutorials
    All Tutorials

Certification Courses

    All Courses
    Software Development Course - All in One Bundle
    Become a Python Developer
    Java Course
    Become a Selenium Automation Tester
    Become an IoT Developer
    ASP.NET Course
    VB.NET Course
    PHP Course

© 2022 - EDUCBA. ALL RIGHTS RESERVED. THE CERTIFICATION NAMES ARE THE TRADEMARKS OF THEIR RESPECTIVE OWNERS.
quiz 

SA+VegDitto lockscreen kbdin pis0856polsiren

Skip to content
Free Newsletter

    Buying Guides News Reviews Explore 

We select and review products independently. When you purchase through our links we may earn a commission. Learn more.

    🏡
    Linux

How to Use the sed Command on Linux
Dave McKay


 @TheGurkha
Apr 16, 2020, 8:00 am EDT | 13 min read
A terminal window on a Linux system.
Fatmawati Achmad Zaenuri/Shutterstock

It might sound crazy, but the Linux sed command is a text editor without an interface. You can use it from the command line to manipulate text in files and streams. We’ll show you how to harness its power.
The Power of sed

The sed command is a bit like chess: it takes an hour to learn the basics and a lifetime to master them (or, at least a lot of practice). We’ll show you a selection of opening gambits in each of the main categories of sed functionality.

sed is a stream editor that works on piped input or files of text. It doesn’t have an interactive text editor interface, however. Rather, you provide instructions for it to follow as it works through the text. This all works in Bash and other command-line shells.

With sed you can do all of the following:

    Select text
    Substitute text
    Add lines to text
    Delete lines from text
    Modify (or preserve) an original file

We’ve structured our examples to introduce and demonstrate concepts, not to produce the tersest (and least approachable) sed commands. However, the pattern matching and text selection functionalities of sed rely heavily on regular expressions (regexes). You’re going to need some familiarity with these to get the best out of sed.

RELATED: How to Use Regular Expressions (regexes) on Linux
A Simple Example

First, we’re going to use echo to send some text to sed through a pipe, and have sed substitute a portion of the text. To do so, we type the following:

echo howtogonk | sed 's/gonk/geek/'

The echo command sends “howtogonk” into sed, and our simple substitution rule (the “s” stands for substitution) is applied. sed searches the input text for an occurrence of the first string, and will replace any matches with the second.

The string “gonk” is replaced by “geek,” and the new string is printed in the terminal window.

Substitutions are probably the most common use of sed. Before we can dive deeper into substitutions, though, we need to know how to select and match text.
Selecting Text

We’re going to need a text file for our examples. We’ll use one that contains a selection of verses from Samuel Taylor Coleridge’s epic poem “The Rime of the Ancient Mariner.”

We type the following to take a look at it with less:

less coleridge.txt

To select some lines from the file, we provide the start and end lines of the range we want to select. A single number selects that one line.

To extract lines one to four, we type this command:

sed -n '1,4p' coleridge.txt

Note the comma between 1 and 4. The p means “print matched lines.” By default, sed prints all lines. We’d see all the text in the file with the matching lines printed twice. To prevent this, we’ll use the -n (quiet) option to suppress the unmatched text.

We change the line numbers so we can select a different verse, as shown below:

sed -n '6,9p' coleridge.txt

We can use the -e (expression) option to make multiple selections. With two expressions, we can select two verses, like so:

sed -n -e '1,4p' -e '31,34p' coleridge.txt

If we reduce the first number in the second expression, we can insert a blank between the two verses. We type the following:

sed -n -e '1,4p' -e '30,34p' coleridge.txt

We can also choose a starting line and tell sed to step through the file and print alternate lines, every fifth line, or to skip any number of lines. The command is similar to those we used above to select a range. This time, however, we’ll use a tilde (~) instead of a comma to separate the numbers.

The first number indicates the starting line. The second number tells sed which lines after the starting line we want to see. The number 2 means every second line, 3 means every third line, and so on.

We type the following:

sed -n '1~2p' coleridge.txt

You won’t always know where the text you’re looking for is located in the file, which means line numbers won’t always be much help. However, you can also use sed to select lines that contain matching text patterns. For example, let’s extract all lines that start with “And.”

The caret (^) represents the start of the line. We’ll enclose our search term in forward slashes (/). We also include a space after “And” so words like “Android” won’t be included in the result.

Reading sed scripts can be a bit tough at first. The /p means “print,” just as it did in the commands we used above. In the following command, though, a forward slash precedes it:

sed -n '/^And /p' coleridge.txt

Three lines that start with “And ” are extracted from the file and displayed for us.
Making Substitutions

In our first example, we showed you the following basic format for a sed substitution:

echo howtogonk | sed 's/gonk/geek/'

The s tells sed this is a substitution. The first string is the search pattern, and the second is the text with which we want to replace that matched text. Of course, as with all things Linux, the devil is in the details.

We type the following to change all occurrences of “day” to “week,” and give the mariner and albatross more time to bond:

sed -n 's/day/week/p' coleridge.txt

In the first line, only the second occurrence of “day” is changed. This is because sed stops after the first match per line. We have to add a “g” at the end of the expression, as shown below, to perform a global search so all matches in each line are processed:

sed -n 's/day/week/gp' coleridge.txt

This matches three out of the four in the first line. Because the first word is “Day,” and sed is case-sensitive, it doesn’t consider that instance to be the same as “day.”

We type the following, adding an i to the command at the end of the expression to indicate case-insensitivity:

sed -n 's/day/week/gip' coleridge.txt

This works, but you might not always want to turn on case-insensitivity for everything. In those instances, you can use a regex group to add pattern-specific case-insensitivity.

For example, if we enclose characters in square brackets ([]), they’re interpreted as “any character from this list of characters.”

We type the following, and include “D” and “d” in the group, to ensure it matches both “Day” and “day”:

sed -n 's/[Dd]ay/week/gp' coleridge.txt

We can also restrict substitutions to sections of the file. Let’s say our file contains weird spacing in the first verse. We can use the following familiar command to see the first verse:

sed -n '1,4p' coleridge.txt

We’ll search for two spaces and substitute them with one. We’ll do this globally so the action is repeated across the entire line. To be clear, the search pattern is space, space asterisk (*), and the substitution string is a single space. The 1,4 restricts the substitution to the first four lines of the file.

We put all of that together in the following command:

sed -n '1,4 s/  */ /gp' coleridge.txt

This works nicely! The search pattern is what’s important here. The asterisk (*) represents zero or more of the preceding character, which is a space. Thus, the search pattern is looking for strings of one space or more.

If we substitute a single space for any sequence of multiple spaces, we’ll return the file to regular spacing, with a single space between each word. This will also substitute a single space for a single space in some cases, but this won’t affect anything adversely—we’ll still get our desired result.

If we type the following and reduce the search pattern to a single space, you’ll see immediately why we have to include two spaces:

sed -n '1,4 s/ */ /gp' coleridge.txt

Because the asterisk matches zero or more of the preceding character, it sees each character that isn’t a space as a “zero space” and applies the substitution to it.

However, if we include two spaces in the search pattern, sed must find at least one space character before it applies the substitution. This ensures nonspace characters will remain untouched.

We type the following, using the -e (expression) we used earlier, which allows us to make two or more substitutions simultaneously:

sed -n -e 's/motion/flutter/gip' -e 's/ocean/gutter/gip' coleridge.txt

We can achieve the same result if we use a semicolon (;)  to separate the two expressions, like so:

sed -n 's/motion/flutter/gip;s/ocean/gutter/gip' coleridge.txt

When we swapped “day” for “week” in the following command, the instance of “day” in the expression “well a-day” was swapped as well:

sed -n 's/[Dd]ay/week/gp' coleridge.txt

To prevent this, we can only attempt substitutions on lines that match another pattern. If we modify the command to have a search pattern at the start, we’ll only consider operating on lines that match that pattern.

We type the following to make our matching pattern the word “after”:

sed -n '/after/ s/[Dd]ay/week/gp' coleridge.txt

That gives us the response we want.

More Complex Substitutions

Let’s give Coleridge a break and use sed to extract names from the etc/passwd file.

There are shorter ways to do this (more on that later), but we’ll use the longer way here to demonstrate another concept. Each matched item in a search pattern (called subexpressions) can be numbered (up to a maximum of nine items). You can then use these numbers in your sed commands to reference specific subexpressions.

You have to enclose the subexpression in parentheses [()] for this to work. The parentheses also must be preceded by a backward slash (\) to prevent them from being treated as a normal character.

To do this, you would type the following:

sed 's/\([^:]*\).*/\1/' /etc/passwd

Let’s break this down:

    sed 's/: The sed command and the beginning of the substitution expression.
    \(: The opening parenthesis [(] enclosing the subexpression, preceded by a backslash (\).
    [^:]*: The first subexpression of the search term contains a group in square brackets. The caret (^) means “not” when used in a group. A group means any character that isn’t a colon (:) will be accepted as a match.
    \): The closing parenthesis [)] with a preceding backslash (\).
    .*: This second search subexpression means “any character and any number of them.”
    /\1: The substitution portion of the expression contains 1 preceded by a backslash (\). This represents the text that matches the first subexpression.
    /': The closing forward-slash (/) and single quote (') terminate the sed command.

What this all means is we’re going to look for any string of characters that doesn’t contain a colon (:), which will be the first instance of matching text. Then, we’re searching for anything else on that line, which will be the second instance of matching text. We’re going to substitute the entire line with the text that matched the first subexpression.

Each line in the /etc/passwd file starts with a colon-terminated username. We match everything up to the first colon, and then substitute that value for the entire line. So, we’ve isolated the usernames.

Output from

Next, we’ll enclose the second subexpression in parentheses [()] so we can reference it by number, as well. We’ll also replace \1 with \2. Our command will now substitute the entire line with everything from the first colon (:) to the end of the line.

We type the following:

sed 's/\([^:]*\)\(.*\)/\2/' /etc/passwd

Those small changes invert the meaning of the command, and we get everything except the usernames.

Now, let’s take a look at the quick and easy way to do this.

Our search term is from the first colon (:) to the end of the line. Because our substitution expression is empty (//), we won’t replace the matched text with anything.

So, we type the following, chopping off everything from the first colon (:) to the end of the line, leaving just the usernames:

sed 's/:.*//" /etc/passwd

Let’s look at an example in which we reference the first and second matches in the same command.

We’ve got a file of commas (,) separating first and last names. We want to list them as “last name, first name.” We can use cat, as shown below, to see what’s in the file:

cat geeks.txt

Like a lot of sed commands, this next one might look impenetrable at first:

sed 's/^\(.*\),\(.*\)$/\2,\1 /g' geeks.txt

This is a substitution command like the others we’ve used, and the search pattern is quite easy. We’ll break it down below:

    sed 's/: The normal substitution command.
    ^: Because the caret isn’t in a group ([]), it means “The start of the line.”
    \(.*\),: The first subexpression is any number of any characters. It’s enclosed in parentheses [()], each of which is preceded by a backslash (\) so we can reference it by number. Our entire search pattern so far translates as search from the start of the line up to the first comma (,) for any number of any characters.
    \(.*\): The next subexpression is (again) any number of any character. It’s also enclosed in parentheses [()], both of which are preceded by a backslash (\) so we can reference the matching text by number.
    $/: The dollar sign ($) represents the end of the line and will allow our search to continue to the end of the line. We’ve used this simply to introduce the dollar sign. We don’t really need it here, as the asterisk (*) would go to the end of the line in this scenario. The forward slash (/) completes the search pattern section.
    \2,\1 /g': Because we enclosed our two subexpressions in parentheses, we can refer to both of them by their numbers. Because we want to reverse the order, we type them as second-match,first-match. The numbers have to be preceded by a backslash (\).
    /g: This enables our command to work globally on each line.
    geeks.txt: The file we’re working on.

You can also use the Cut command (c) to substitute entire lines that match your search pattern. We type the following to search for a line with the word “neck” in it, and replace it with a new string of text:

sed '/neck/c Around my wrist was strung' coleridge.txt

Our new line now appears at the bottom of our extract.

Inserting Lines and Text

We can also insert new lines and text into our file. To insert new lines after any matching ones, we’ll use the Append command (a).

Here’s the file we’re going to work with:

cat geeks.txt

We’ve numbered the lines to make this a bit easier to follow.

We type the following to search for lines that contain the word “He,” and insert a new line beneath them:

sed '/He/a --> Inserted!' geeks.txt

We type the following and include the Insert Command (i) to insert the new line above those that contain matching text:

sed '/He/i --> Inserted!' geeks.txt

We can use the ampersand (&), which represents the original matched text, to add new text to a matching line. \1 , \2, and so on, represent matching subexpressions.

To add text to the start of a line, we’ll use a substitution command that matches everything on the line, combined with a replacement clause that combines our new text with the original line.

To do all of this, we type the following:

sed 's/.*/--> Inserted &/' geeks.txt

We type the following, including the G command, which will add a blank line between each line:

sed 'G' geeks.txt

If you want to add two or more blank lines, you can use G;G, G;G;G, and so on.
Deleting Lines

The Delete command (d) deletes lines that match a search pattern, or those specified with line numbers or ranges.

For example, to delete the third line, we would type the following:

sed '3d' geeks.txt

To delete the range of lines four to five, we’d type the following:

sed '4,5d' geeks.txt

To delete lines outside a range, we use an exclamation point (!), as shown below:

sed '6,7!d' geeks.txt

Saving Your Changes

So far, all of our results have printed to the terminal window, but we haven’t yet saved them anywhere. To make these permanent, you can either write your changes to the original file or redirect them to a new one.

Overwriting your original file requires some caution. If your sed command is wrong, you might make some changes to the original file that are difficult to undo.

For some peace of mind, sed can create a backup of the original file before it executes its command.

You can use the In-place option (-i) to tell sed to write the changes to the original file, but if you add a file extension to it, sed will back up the original file to a new one. It will have the same name as the original file, but with a new file extension.

To demonstrate, we’ll search for any lines that contain the word “He” and delete them. We’ll also back up our original file to a new one using the BAK extension.

To do all of this, we type the following:

sed -i'.bak' '/^.*He.*$/d' geeks.txt

We type the following to make sure our backup file is unchanged:

cat geeks.txt.bak

We can also type the following to redirect the output to a new file and achieve a similar result:

sed -i'.bak' '/^.*He.*$/d' geeks.txt > new_geeks.txt

We use cat to confirm the changes were written to the new file, as shown below:

cat new_geeks.txt

RELATED: How Do You Actually Use Regex?
Having sed All That

As you’ve probably noticed, even this quick primer on sed is quite long. There’s a lot to this command, and there’s even more you can do with it.

Hopefully, though, these basic concepts have provided a solid foundation on which you can build as you continue to learn more.

RELATED: 10 Basic Linux Commands for Beginners
	Linux Commands
Files 	tar · pv · cat · tac · chmod · grep ·  diff · sed · ar · man · pushd · popd · fsck · testdisk · seq · fd · pandoc · cd · $PATH · awk · join · jq · fold · uniq · journalctl · tail · stat · ls · fstab · echo · less · chgrp · chown · rev · look · strings · type · rename · zip · unzip · mount · umount · install · fdisk · mkfs · rm · rmdir · rsync · df · gpg · vi · nano · mkdir · du · ln · patch · convert · rclone · shred · srm 	
Processes 	alias · screen · top · nice · renice · progress · strace · systemd · tmux · chsh · history · at · batch · free · which · dmesg · chfn · usermod · ps · chroot · xargs · tty · pinky · lsof · vmstat · timeout · wall · yes · kill · sleep · sudo · su · time · groupadd · usermod · groups · lshw · shutdown · reboot · halt · poweroff · passwd · lscpu · crontab · date · bg · fg 	
Networking 	netstat · ping · traceroute · ip · ss · whois · fail2ban · bmon · dig · finger · nmap · ftp · curl · wget · who · whoami · w · iptables · ssh-keygen · ufw 	

RELATED: Best Linux Laptops for Developers and Enthusiasts
READ NEXT

    › How to Manipulate Strings in Bash on Linux
    › How Does a Decentralized VPN (dVPN) Work?
    › PSA: You Can Replace the Keys on Your Mechanical Keyboard
    › LastPass Just Had a Security Breach
    › Google Play Games on PC Enters Public Beta in Five Countries
    › A Farewell Tour of Benj’s Best HTG Computer History Articles
    › Play Destiny 2, Two Other Games Free for a Limited Time

Profile Photo for Dave McKay Dave McKay
Dave McKay first used computers when punched paper tape was in vogue, and he has been programming ever since. After over 30 years in the IT industry, he is now a full-time technology journalist. During his career, he has worked as a freelance programmer, manager of an international software development team, an IT services project manager, and, most recently, as a Data Protection Officer. His writing has been published by  howtogeek.com, cloudsavvyit.com, itenterpriser.com, and opensource.com. Dave is a Linux evangelist and open source advocate. Read Full Bio »
How-To Geek is where you turn when you want experts to explain technology. Since we launched in 2006, our articles have been read more than 1 billion times. Want to know more?
How-To Geek

Facebook

Instagram

Twitter

LinkedIn

RSS Feed

The Best Free Tech Newsletter Anywhere

By submitting your email, you agree to the Terms of Use and Privacy Policy.

    About Us
    Contact Us
    Join Our Team
    Advertising
    Privacy Policy
    Terms of Use
    Accessibility
    Toggle Dark Mode

© 2022 LifeSavvy Media. All Rights Reserved


SA+VEgdItto lockscreen kbdin pis0856polsiren


shell-fu
Enter search text
HomeLatestBrowseTop 25RandomStoreHall Of FameContactSubmit
//Tips tagged sed
Latest tips by RSS
Click here to subscribe
Follow Shell-Fu on Twitter
Click here to follow
Follow Shell-Fu on identi.ca
Click here to follow
+32-
Tip #205 / Convert permissions to octal

Tags: sed
Save this to del.icio.usDigg this!Reddit this!Tweet this!
Converts the symbolic permissions to octal (ie: numbers) when using 'ls -l':

$ls -l | sed -e 's/--x/1/g' -e 's/-w-/2/g' -e 's/-wx/3/g' -e 's/r--/4/g' \
 -e 's/r-x/5/g' -e 's/rw-/6/g' -e 's/rwx/7/g' -e 's/---/0/g'

-755  1 jrl jrl  111943 2003-10-21 19:57 logscan
-644  1 jrl jrl   35468 2003-11-23 16:13 htfoo
-700  1 jrl jrl 3100672 2004-05-15 17:00 mutt
-644  1 jrl jrl   10162 2005-02-22 14:14 joinstep2.php
-777  1 jrl jrl   41079 2005-04-21 13:02 setistats
d755  2 jrl jrl      47 2007-10-26 14:41 rf
-700  1 jrl jrl     104 2008-02-05 11:26 getc

If you're going to use this, you may want to make an alias rather than type it in each time!


View Comments »


+20-
Tip #177 / Copy and paste from the command line

Tags: sed
Save this to del.icio.usDigg this!Reddit this!Tweet this!
Add the following alias and function to your profile to be able to copy and paste files at the command line:

ccopy(){ cp $1 /tmp/ccopy.$1; }
alias cpaste="ls /tmp/ccopy* | sed 's|[^\.]*.\.||' | xargs -I % mv /tmp/ccopy.% ./%"


You can see below how this can be used:

blackbird:~/tst tks1$ ls
1.txt   2.txt   t1.tss  t2.tss  t3.tss
blackbird:~/tst tks1$ ccopy 1.txt
blackbird:~/tst tks1$ ccopy 2.txt


blackbird:~/tst tks1$ cd ../tst2
blackbird:~/tst2 tks1$ ls


blackbird:~/tst2 tks1$ cpaste


blackbird:~/tst2 tks1$ ls
1.txt   2.txt



View Comments »
+15-
Tip #701 / Stream YouTube videos directly to your media player

Tags: sed
Save this to del.icio.usDigg this!Reddit this!Tweet this!
YouTube is great, but the embedded flash player doesn't offer a lot in the way of customizing your viewing experience. There are quite a few options for downloading flv video files from YouTube, but adding the following function to your bashrc will let you stream them directly to your choice of media player.

function mtube {
  video_id=$(curl -s $1 | sed -n "/watch_fullscreen/s;.*\(video_id.\+\)&title.*;\1;p");
  mplayer -fs $(echo "http://youtube.com/get_video.php?$video_id");
}


This should work with any URL of the form http://www.youtube.com/watch?v=[video id here], for example:

mtube http://www.youtube.com/watch?v=evQ0QNi2CzA



View Comments »
+13-
Tip #11 /

Tags: sed
Save this to del.icio.usDigg this!Reddit this!Tweet this!
Add commas to all numeric strings in a file, changing "1234567" to "1,234,567"

sed -e :a -e 's/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/;ta' filename




View Comments »
+13-
Tip #172 / Create daily backups

Tags: sed
Save this to del.icio.usDigg this!Reddit this!Tweet this!
To create a set of backed up files with the current date added at the end of the file name try the following:

ls *txt | sed "s/.*/cp & &.$(date "+%Y%d%m")/"



This will run the following commands:

cp 1.txt 1.txt.20082703

cp 2.txt 2.txt.20082703

cp 3.txt 3.txt.20082703



View Comments »
+13-
Tip #209 / Directory Tree

Tags: sed
Save this to del.icio.usDigg this!Reddit this!Tweet this!
The following alias will print the directory structure from the current directory in tree format.

alias dirf='find . -type d | sed -e "s/[^-][^\/]*\//  |/g" -e "s/|\([^ ]\)/|-\1/"'



View Comments »
+11-
Tip #43 / Using Perl instead of Sed

Tags: sed
Save this to del.icio.usDigg this!Reddit this!Tweet this!
Prefer Perl over Sed? No problem! To use Perl as a Sed-like program:

perl -pe 's/foo/bar/; etc'


Have a Perl script ready? No problem!

perl -p foo.pl



View Comments »
+11-
Tip #300 / Find and replace on specific files

Tags: sed
Save this to del.icio.usDigg this!Reddit this!Tweet this!
Selective content replace on files. For example to replace '<?' with '<?php' in all PHP files:

find . -name '*.php' -exec sed -ie 's#<?#<?php#' {} \;



View Comments »
+10-
Tip #210 / Calendar with current date

Tags: sed
Save this to del.icio.usDigg this!Reddit this!Tweet this!
Add the following sed commands to cal to get a calendar with the current date marked:

cal | sed "s/^/ /;s/$/ /;s/ $(date +%e) / $(date +%e | sed 's/./#/g') /"



View Comments »
+10-
Tip #211 / Remove comments and blank lines

Tags: sed
Save this to del.icio.usDigg this!Reddit this!Tweet this!

sed '/ *#/d; /^ *$/d' file


Remove comments and blank lines from file


View Comments »
+10-
Tip #294 / Mass-renaming files

Tags: sed
Save this to del.icio.usDigg this!Reddit this!Tweet this!
Mass-renaming files using find and sed:


find -name "*.php3" | sed 's/\(.*\).php3$/mv "&" "\1.php"/' | sh


(this example will rename all .php3 files to .php)


View Comments »
+10-
Tip #878 / Random xkcd comic

Tags: sed
Save this to del.icio.usDigg this!Reddit this!Tweet this!
Displays a random xkcd comic. Requires ImageMagick.

wget http://dynamic.xkcd.com/comic/random/ -O -| grep <img src="http://imgs.xkcd.com/comics | 
 sed s/<img src="// | sed s/"[a-z]*.*// | wget -i - -O -| display



View Comments »
+9-
Tip #171 / Duplicate directory tree

Tags: sed
Save this to del.icio.usDigg this!Reddit this!Tweet this!
The following command creates in the /usr/project directory, a copy of the current working directory structure:

find . -type d -print|sed 's@^\.\{0,1\}@/usr/project@' | sed 's/ /\\ /' | xargs mkdir -p



View Comments »
+9-
Tip #539 / Using sed across multiple lines

Tags: sed
Save this to del.icio.usDigg this!Reddit this!Tweet this!
Sometimes when using sed you find that you need to match across line endings, this can be achieved by getting sed to match the first line and then pulling a second line into the buffer with the N command.

For example, if we have a file:

$ cat foo
This is a sample hello
world file.


And want to change 'hello world' to 'hello shell-fu' we need to replace across lines. This can be done with the following command:

:~$ cat foo | sed '/hello$/N;s/hello\nworld/hello\nshell-fu/'
This is a sample hello
shell-fu file.


Here sed first looks for lines which end with 'hello' then reads the next line, finally replacing 'hello\nworld' with 'hello\nshell-fu'.

This also has a lot of other uses, for example converting double line spaced files to single:

cat doublespace | sed '/^$/N;s/\n$//g'



View Comments »
+8-
Tip #384 / BBC Weather

Tags: sed
Save this to del.icio.usDigg this!Reddit this!Tweet this!
Go to [http://www.bbc.co.uk/cgi-perl/weather/search/new_search.pl] and search for your location. Copy the link to the 3 day forecast feed, for example [http://feeds.bbc.co.uk/weather/feeds/rss/5day/world/0105.xml]. Then just put that link into the following command to get a quick command line weather forecast.

wget -q -O - http://feeds.bbc.co.uk/weather/.../XXXXX.xml | grep title | sed -e "s/<[^>]*>//g" -e "s/°//g" | egrep "^[A-Z]"

Example:

$ wget -q -O - http://feeds.bbc.co.uk/weather/feeds/rss/5day/world/0105.xml | grep title | sed -e "s/<[^>]*>//g" -e "s/°//g" | egrep "^[A-Z]"

BBC - Weather Centre - Forecast for San Francisco, United States of America
Tuesday: sunny, Max Temp: 22C (72F), Min Temp: 13C (55F)
Wednesday: sunny, Max Temp: 22C (72F), Min Temp: 15C (59F)
Thursday: sunny, Max Temp: 25C (77F), Min Temp: 14C (57F)





View Comments »
+7-
Tip #487 / Print part of a file

Tags: sed
Save this to del.icio.usDigg this!Reddit this!Tweet this!
Print the contents of a file from a given regular expression to another

sed -n '/start/,/end/ p' file


This will print the contents of the file from the line that matches /start/ until the line that matches /end/


View Comments »
+5-
Tip #148 / Number each line of a file

Tags: sed
Save this to del.icio.usDigg this!Reddit this!Tweet this!


sed = filename | sed 'N;s/\n/\t/' > filename.numbered



View Comments »
+5-
Tip #182 / MAC address conversion

Tags: sed
Save this to del.icio.usDigg this!Reddit this!Tweet this!
Convert mac addresses such as 000000abde00 into 00:00:00:ab:de:00

awk '{for(i=10;i>=2;i-=2)$0=substr($0,1,i)":"substr($0,i+1);print}' macaddress_list
sed 's/\(..\)/\1:/g;s/:$//' macaddress_list

// sil at infiltrated.net


View Comments »
+5-
Tip #540 / Command examples from shell-fu

Tags: sed
Save this to del.icio.usDigg this!Reddit this!Tweet this!
The following isn't particularly pretty and should be considered a work in progress, but it's quite fun.

Get examples of ways a command can be used direct from shell-fu by adding the following alias:

function examples { lynx -width=$COLUMNS -nonumbers -dump "http://www.shell-fu.org/lister.php?tag=$1" | \
sed -n '/^[a-zA-Z]/,$p' | egrep -v '^http|^javas|View Comm|HIDE|] \+|to Share|^ +\*|^ +[HV][a-z]* l|^ .*efu.*ep.*!$' | \
sed -e '/^  *__*/N;s/\n$//g' | less -r; }


This pulls out the tips tagged by the given command. (Make sure you tag any tips you submit!)


View Comments »
+4-
Tip #48 / Check low space

Tags: sed
Save this to del.icio.usDigg this!Reddit this!Tweet this!
Mail somebody about space running low in some path (ksh, bash):


PATHS="/export/home /home"

AWK=/usr/bin/awk

DU="/usr/bin/du -ks"

GREP=/usr/bin/grep

DF="/usr/bin/df -k"

TR=/usr/bin/tr

SED=/usr/bin/sed

CAT=/usr/bin/cat

MAILFILE=/tmp/mailviews$$

MAILER=/bin/mailx

mailto="all@company.com" 

for path in $PATHS

do

	DISK_AVAIL=`$DF $path |  $GREP -v "Filesystem" | $AWK '{print $5}'|$SED 's/%//g'` 

	if [ $DISK_AVAIL -gt 90 ];then

		echo "Please clean up your stuff\n\n" > $MAILFILE

		$CAT $MAILFILE | $MAILER -s "Clean up stuff" $mailto	

	fi

done 



View Comments »
+4-
Tip #312 / SSH Auto Complete

Tags: sed
Save this to del.icio.usDigg this!Reddit this!Tweet this!

SSH_COMPLETE=( $(cat ~/.ssh/known_hosts | \
                 cut -f 1 -d ' ' | \
                 sed -e s/,.*//g | \
                 uniq | \
                 egrep -v [0123456789]) )
complete -o default -W "${SSH_COMPLETE[*]}" ssh



View Comments »
+4-
Tip #572 / Print until no match

Tags: sed
Save this to del.icio.usDigg this!Reddit this!Tweet this!
This bit of sed will print the contents of a file until the first line which doesn't contain the specified expression. A useful alternative to 'head' when you're not sure how much of the file you need.

sed -n '/Hello/!q; p'



View Comments »
+-1-
Tip #12 /

Tags: sed
Save this to del.icio.usDigg this!Reddit this!Tweet this!
Add a leading angle bracket and space to each line (quote a message)

sed 's/^/> /' filename



View Comments »
+-1-
Tip #234 / unwrapping ldapsearch's ldif output

Tags: sed
Save this to del.icio.usDigg this!Reddit this!Tweet this!
I'm working on a project to access data from my corporate Active Directory server using ldapsearch. The version of ldapsearch that comes with Red Hat Enterprise Server spews out LDIF in column truncated format. That is to say it inserts a carriage return at column 80 of the output.

This sed goodie unwraps the ldif output.

UNWRAP=' /^ / {; H; d; }; /^ /! {; x; s/\n //; }; '


View Comments »
+-9-
Tip #233 / Remove numbers from history

Tags: sed
Save this to del.icio.usDigg this!Reddit this!Tweet this!
Use the following command to give a history listing without the numbers for easier copy and pasting:

history | sed 's/^[ 0-9]* //'



View Comments »


Home Latest Browse Top 25 Random Hall Of Fame Contact Submit


SA+VEgdiTto lockscreen kbdin pis0856polsiren

SED -- A Non-interactive Text Editor                     USD:18-1

              SED -- A Non-interactive Text Editor

                         Lee E. McMahon

                     AT&T Bell Laboratories
                  Murray Hill, New Jersey 07974

                            ABSTRACT

          Sed  is a non-interactive context editor that runs
     on the UNIX operating system.  Sed is  designed  to  be
     especially useful in three cases:

          1)  To edit files too large for comfortable inter-
               active editing;
          2) To edit any size  file  when  the  sequence  of
               editing  commands  is  too  complicated to be
               comfortably typed in interactive mode.
          3) To perform multiple `global' editing  functions
               efficiently in one pass through the input.

     This  memorandum constitutes a manual for users of sed.

Introduction

Sed is a non-interactive context editor designed to be especially
useful in three cases:

     1) To edit files too large for comfortable interactive edit-
          ing;
     2) To edit any size file when the sequence of  editing  com-
          mands  is  too  complicated  to be comfortably typed in
          interactive mode;
     3) To perform  multiple  `global'  editing  functions  effi-
          ciently in one pass through the input.

Since  only  a few lines of the input reside in core at one time,
and no temporary files are used, the effective size of file  that
can  be  edited is limited only by the requirement that the input
and output fit simultaneously into available secondary storage.

Complicated editing scripts can be created separately  and  given
_________________________
 UNIX is a trademark of AT&T Bell Laboratories.

USD:18-2                     SED -- A Non-interactive Text Editor

to  sed as a command file.  For complex edits, this saves consid-
erable typing, and its attendant errors.  Sed running from a com-
mand  file  is  much  more  efficient than any interactive editor
known to the author, even if that editor can be driven by a  pre-
written script.

The principal loss of functions compared to an interactive editor
are lack of relative addressing (because  of  the  line-at-a-time
operation), and lack of immediate verification that a command has
done what was intended.

Sed is a lineal descendant of the UNIX editor,  ed.   Because  of
the  differences  between  interactive and non-interactive opera-
tion, considerable changes have been made  between  ed  and  sed;
even  confirmed  users  of  ed  will frequently be surprised (and
probably chagrined), if they rashly use sed without reading  Sec-
tions  2 and 3 of this document.  The most striking family resem-
blance between the two editors is in the class of patterns (`reg-
ular expressions') they recognize; the code for matching patterns
is copied almost verbatim from the code for ed, and the  descrip-
tion  of regular expressions in Section 2 is copied almost verba-
tim from the UNIX Programmer's Manual[1]. (Both code and descrip-
tion were written by Dennis M. Ritchie.)

1. Overall Operation

Sed  by default copies the standard input to the standard output,
perhaps performing one or more  editing  commands  on  each  line
before  writing  it to the output.  This behavior may be modified
by flags on the command line; see Section 1.1 below.

The general format of an editing command is:

          [address1,address2][function][arguments]

One or both addresses may be omitted; the format of addresses  is
given  in  Section  2.  Any number of blanks or tabs may separate
the addresses from the function.  The function must  be  present;
the available commands are discussed in Section 3.  The arguments
may be required or  optional,  according  to  which  function  is
given; again, they are discussed in Section 3 under each individ-
ual function.

Tab characters and spaces at the beginning of lines are  ignored.

1.1. Command-line Flags

Three flags are recognized on the command line:
     -n:  tells  sed not to copy all lines, but only those speci-
          fied by p functions or p flags after s  functions  (see
          Section 3.3);
     -e:  tells  sed  to  take  the  next  argument as an editing

SED -- A Non-interactive Text Editor                     USD:18-3

          command;
     -f: tells sed to take the next argument as a file name;  the
          file should contain editing commands, one to a line.

1.2. Order of Application of Editing Commands

Before  any  editing  is  done (in fact, before any input file is
even opened), all the editing commands are compiled into  a  form
which  will  be  moderately  efficient during the execution phase
(when the commands are actually applied to  lines  of  the  input
file).   The commands are compiled in the order in which they are
encountered; this is generally the order in which  they  will  be
attempted  at  execution time.  The commands are applied one at a
time; the input to each command is the output  of  all  preceding
commands.

The  default  linear order of application of editing commands can
be changed by the flow-of-control commands, t and b (see  Section
3).   Even when the order of application is changed by these com-
mands, it is still true that the input line to any command is the
output of any previously applied command.

1.3.  Pattern-space

The  range of pattern matches is called the pattern space.  Ordi-
narily, the pattern space is one line of the input text, but more
than  one  line can be read into the pattern space by using the N
command (Section 3.6.).

1.4. Examples

Examples are scattered throughout the text.  Except where  other-
wise noted, the examples all assume the following input text:

     In Xanadu did Kubla Khan
     A stately pleasure dome decree:
     Where Alph, the sacred river, ran
     Through caverns measureless to man
     Down to a sunless sea.

(In no case is the output of the sed commands to be considered an
improvement on Coleridge.)

Example:

The command

     2q

will quit after copying the first two lines of  the  input.   The
output will be:

USD:18-4                     SED -- A Non-interactive Text Editor

     In Xanadu did Kubla Khan
     A stately pleasure dome decree:

2. ADDRESSES: Selecting lines for editing

Lines  in  the  input file(s) to which editing commands are to be
applied can be selected by addresses.  Addresses  may  be  either
line numbers or context addresses.

The  application  of a group of commands can be controlled by one
address (or address-pair) by grouping  the  commands  with  curly
braces (`{ }')(Sec. 3.6.).

2.1. Line-number Addresses

A  line  number  is a decimal integer.  As each line is read from
the input, a line-number counter is  incremented;  a  line-number
address  matches (selects) the input line which causes the inter-
nal counter to equal the address line-number.  The  counter  runs
cumulatively through multiple input files; it is not reset when a
new input file is opened.

As a special case, the character $ matches the last line  of  the
last input file.

2.2. Context Addresses

A context address is a pattern (`regular expression') enclosed in
slashes (`/').  The regular expressions  recognized  by  sed  are
constructed as follows:

     1)  An ordinary character (not one of those discussed below)
          is a regular expression, and matches that character.

     2) A circumflex `^' at the beginning of a regular expression
          matches  the null character at the beginning of a line.
     3) A dollar-sign `$' at the  end  of  a  regular  expression
          matches the null character at the end of a line.
     4)  The characters `\n' match an imbedded newline character,
          but not the newline at the end of the pattern space.
     5) A period `.' matches any character  except  the  terminal
          newline of the pattern space.
     6)  A regular expression followed by an asterisk `*' matches
          any number (including 0) of adjacent occurrences of the
          regular expression it follows.
     7)  A  string of characters in square brackets `[ ]' matches
          any character in the string, and no others.   If,  how-
          ever,  the  first character of the string is circumflex
          `^',  the  regular  expression  matches  any  character
          except  the  characters  in the string and the terminal
          newline of the pattern space.
     8) A concatenation  of  regular  expressions  is  a  regular
          expression  which  matches the concatenation of strings

SED -- A Non-interactive Text Editor                     USD:18-5

          matched by the components of the regular expression.
     9) A regular expression between the sequences `\(' and  `\)'
          is identical in effect to the unadorned regular expres-
          sion, but has side-effects which  are  described  under
          the  s  command below and specification 10) immediately
          below.
     10) The expression `\d' means the same string of  characters
          matched by an expression enclosed in `\(' and `\)' ear-
          lier in the same pattern.  Here d is  a  single  digit;
          the  string  specified  is  that beginning with the dth
          occurrence of `\(' counting from the left.   For  exam-
          ple,  the  expression `^\(.*\)\1' matches a line begin-
          ning with two repeated occurrences of the same  string.
     11)  The null regular expression standing alone (e.g., `//')
          is equivalent to the  last regular expression compiled.

To  use one of the special characters (^ $ . * [ ] \ /) as a lit-
eral (to match an occurrence of itself in the input), precede the
special character by a backslash `\'.

For  a  context  address  to  `match' the input requires that the
whole pattern within the address match some portion of  the  pat-
tern space.

2.3. Number of Addresses

The  commands  in the next section can have 0, 1, or 2 addresses.
Under each command the maximum number  of  allowed  addresses  is
given.   For  a  command  to have more addresses than the maximum
allowed is considered an error.

If a command has no addresses, it is applied to every line in the
input.

If  a  command  has one address, it is applied to all lines which
match that address.

If a command has two addresses, it is applied to the  first  line
which  matches  the  first  address,  and to all subsequent lines
until (and including) the first subsequent line which matches the
second  address.   Then an attempt is made on subsequent lines to
again match the first address, and the process is repeated.

Two addresses are separated by a comma.

Examples:

     /an/      matches lines 1, 3, 4 in our sample text
     /an.*an/  matches line 1
     /^an/     matches no lines
     /./       matches all lines
     /\./      matches line 5
     /r*an/    matches lines 1,3, 4 (number = zero!)
     /\(an\).*\1/        matches line 1

USD:18-6                     SED -- A Non-interactive Text Editor

3. FUNCTIONS

All functions are named by a single character.  In the  following
summary,  the  maximum  number  of  allowable  addresses is given
enclosed in parentheses, then the single character function name,
possible  arguments enclosed in angles (< >), an expanded English
translation of the single-character name, and finally a  descrip-
tion of what each function does.  The angles around the arguments
are not part of the argument, and should not be typed  in  actual
editing commands.

3.1. Whole-line Oriented Functions

     (2)d  --  delete  lines The d function deletes from the file
          (does not write to the output) all those lines  matched
          by  its  address(es).  It also has the side effect that
          no further commands are attempted on the  corpse  of  a
          deleted  line; as soon as the d function is executed, a
          new line is read from the input, and the list of  edit-
          ing  commands  is  re-started from the beginning on the
          new line.
     (2)n -- next line The n function reads the  next  line  from
          the  input,  replacing  the  current line.  The current
          line is written to the output if  it  should  be.   The
          list  of  editing commands is continued following the n
          command.
     (1)a\
     <text> -- append lines
          The a function causes the argument <text> to be written
          to  the  output  after the line matched by its address.
          The a command is inherently multi-line; a  must  appear
          at the end of a line, and <text> may contain any number
          of lines.  To preserve the  one-command-to-a-line  fic-
          tion,  the  interior newlines must be hidden by a back-
          slash character (`\') immediately  preceding  the  new-
          line.   The  <text> argument is terminated by the first
          unhidden newline (the first one  not  immediately  pre-
          ceded  by  backslash).   Once an a function is success-
          fully executed, <text> will be written  to  the  output
          regardless  of what later commands do to the line which
          triggered it.   The  triggering  line  may  be  deleted
          entirely;  <text>  will still be written to the output.
          The <text> is not scanned for address matches,  and  no
          editing  commands  are  attempted  on  it.  It does not
          cause any change in the line-number counter.
     (1)i\
     <text> -- insert lines
          The i function  behaves identically to the a  function,
          except  that <text> is written to the output before the
          matched line.  All other comments about the a  function
          apply to the i function as well.
     (2)c\
     <text> -- change lines
          The  c  function  deletes  the  lines  selected  by its

SED -- A Non-interactive Text Editor                     USD:18-7

          address(es),  and  replaces  them  with  the  lines  in
          <text>.   Like a and i, c must be followed by a newline
          hidden by a backslash; and interior new lines in <text>
          must  be hidden by backslashes.  The c command may have
          two addresses, and therefore select a range  of  lines.
          If it does, all the lines in the range are deleted, but
          only one copy of <text> is written to the  output,  not
          one  copy per line deleted.  As with a and i, <text> is
          not scanned for address matches, and  no  editing  com-
          mands  are  attempted  on  it.   It does not change the
          line-number counter.  After a line has been deleted  by
          a  c function, no further commands are attempted on the
          corpse.  If text is appended after a line  by  a  or  r
          functions,  and  the  line is subsequently changed, the
          text inserted by the c function will be  placed  before
          the  text  of the a or r functions.  (The r function is
          described in Section 3.4.)
Note: Within the text put in the output by these functions, lead-
ing  blanks  and  tabs will disappear, as always in sed commands.
To get leading blanks and tabs into the output, precede the first
desired  blank  or  tab  by  a  backslash; the backslash will not
appear in the output.

Example:

The list of editing commands:

     n
     a\
     XXXX
     d

applied to our standard input, produces:

     In Xanadu did Kubhla Khan
     XXXX
     Where Alph, the sacred river, ran
     XXXX
     Down to a sunless sea.

In this particular case, the same effect  would  be  produced  by
either of the two following command lists:

     n               n
     i\              c\
     XXXX    XXXX
     d

3.2. Substitute Function

One  very important function changes parts of lines selected by a
context search within the line.
     (2)s<pattern><replacement><flags>  --   substitute   The   s

USD:18-8                     SED -- A Non-interactive Text Editor

          function  replaces  part  of  a line (selected by <pat-
          tern>) with <replacement>.  It can best be read:
                    Substitute for <pattern>,  <replacement>  The
          <pattern> argument contains a pattern, exactly like the
          patterns in addresses (see 2.2 above).  The  only  dif-
          ference between <pattern> and a context address is that
          the context address must be delimited  by  slash  (`/')
          characters; <pattern> may be delimited by any character
          other than space or  newline.   By  default,  only  the
          first  string matched by <pattern> is replaced, but see
          the g flag below.  The  <replacement>  argument  begins
          immediately  after  the  second delimiting character of
          <pattern>, and must be followed immediately by  another

          instance  of the delimiting character.  (Thus there are
          exactly three instances of the  delimiting  character.)
          The  <replacement> is not a pattern, and the characters
          which are special in patterns do not have special mean-
          ing  in  <replacement>.   Instead, other characters are
          special:
               &       is replaced by the string matched by <pat-
                    tern>
               \d  (where d is a single digit) is replaced by the
                    dth substring matched by parts  of  <pattern>
                    enclosed  in  `\('  and `\)'.  If nested sub-
                    strings occur in <pattern>, the dth is deter-
                    mined  by counting opening delimiters (`\(').
                    As in patterns,  special  characters  may  be
                    made literal by preceding them with backslash
                    (`\').
          The <flags> argument may contain the following flags:
               g  --  substitute  <replacement>  for  all   (non-
                    overlapping)  instances  of  <pattern> in the
                    line.  After a successful  substitution,  the
                    scan  for  the  next  instance  of  <pattern>
                    begins just after the  end  of  the  inserted
                    characters; characters put into the line from
                    <replacement> are not rescanned.
               p -- print the line if  a  successful  replacement
                    was  done.   The p flag causes the line to be
                    written to the output if and only if  a  sub-
                    stitution  was  actually  made by the s func-
                    tion.  Notice that if  several  s  functions,
                    each  followed by a p flag, successfully sub-
                    stitute in  the  same  input  line,  multiple
                    copies  of  the  line  will be written to the
                    output: one for each successful substitution.
               w <filename> -- write the line to a file if a suc-
                    cessful replacement was  done.   The  w  flag
                    causes  lines  which are actually substituted
                    by the s function to be  written  to  a  file
                    named  by  <filename>.   If <filename> exists
                    before sed is run, it is overwritten; if not,
                    it  is created.  A single space must separate
                    w  and  <filename>.   The  possibilities   of

SED -- A Non-interactive Text Editor                     USD:18-9

                    multiple,  somewhat  different  copies of one
                    input line being written are the same as  for
                    p.   A maximum of 10 different file names may
                    be mentioned after w flags  and  w  functions
                    (see below), combined.

Examples:

The following command, applied to our standard input,

     s/to/by/w changes

produces, on the standard output:

     In Xanadu did Kubhla Khan
     A stately pleasure dome decree:
     Where Alph, the sacred river, ran
     Through caverns measureless by man
     Down by a sunless sea.

and, on the file `changes':

     Through caverns measureless by man
     Down by a sunless sea.

If the nocopy option is in effect, the command:

     s/[.,;?:]/*P&*/gp

produces:

     A stately pleasure dome decree*P:*
     Where Alph*P,* the sacred river*P,* ran
     Down to a sunless sea*P.*

Finally, to illustrate the effect of the g flag, the command:

     /X/s/an/AN/p

produces (assuming nocopy mode):

     In XANadu did Kubhla Khan

and the command:

     /X/s/an/AN/gp

produces:

     In XANadu did Kubhla KhAN

USD:18-10                    SED -- A Non-interactive Text Editor

3.3. Input-output Functions

     (2)p  -- print The print function writes the addressed lines
          to the standard output file.  They are written  at  the
          time  the p function is encountered, regardless of what
          succeeding editing commands may do to the lines.
     (2)w <filename> -- write on <filename>  The  write  function
          writes  the addressed lines to the file named by <file-
          name>.  If the file previously existed, it is overwrit-
          ten;  if  not,  it  is  created.  The lines are written
          exactly as  they  exist  when  the  write  function  is
          encountered  for  each  line, regardless of what subse-
          quent editing commands may do  to  them.   Exactly  one
          space must separate the w and <filename>.  A maximum of
          ten different files may be mentioned in write functions
          and w flags after s functions, combined.
     (1)r  <filename>  --  read  the  contents of a file The read
          function reads the contents of <filename>, and  appends
          them  after  the line matched by the address.  The file
          is read and  appended  regardless  of  what  subsequent
          editing  commands  do  to  the  line  which matched its
          address.  If r and a functions are executed on the same
          line, the text from the a functions and the r functions
          is written to the output in the order  that  the  func-
          tions  are  executed.   Exactly one space must separate
          the r and <filename>.  If a file mentioned by a r func-
          tion  cannot  be  opened, it is considered a null file,
          not an error, and no diagnostic is given.
NOTE: Since there is a limit to the number of files that  can  be
opened simultaneously, care should be taken that no more than ten
files be mentioned in  w  functions  or  flags;  that  number  is
reduced  by  one  if any r functions are present.  (Only one read
file is open at one time.)

Examples

Assume that the file `note1' has the following contents:

          Note:   Kubla  Khan   (more   properly   Kublai   Khan;
          1216-1294)  was the grandson and most eminent successor
          of Genghiz (Chingiz) Khan, and founder  of  the  Mongol
          dynasty in China.

Then the following command:

     /Kubla/r note1

produces:

     In Xanadu did Kubla Khan
          Note:    Kubla   Khan   (more   properly  Kublai  Khan;
          1216-1294) was the grandson and most eminent  successor
          of  Genghiz  (Chingiz)  Khan, and founder of the Mongol
          dynasty in China.

SED -- A Non-interactive Text Editor                    USD:18-11

     A stately pleasure dome decree:
     Where Alph, the sacred river, ran
     Through caverns measureless to man
     Down to a sunless sea.

3.4.  Multiple Input-line Functions

Three functions, all spelled with capital letters, deal specially
with  pattern  spaces  containing  imbedded  newlines;  they  are
intended principally to provide pattern matches across  lines  in
the input.
     (2)N  --  Next  line  The next input line is appended to the
          current line in the pattern space; the two input  lines
          are  separated by an imbedded newline.  Pattern matches
          may extend across the imbedded newline(s).
     (2)D -- Delete first part of the pattern space Delete up  to
          and  including  the first newline character in the cur-
          rent pattern space.  If the pattern space becomes empty
          (the  only  newline  was  the  terminal  newline), read
          another line from the input.  In any  case,  begin  the
          list of editing commands again from its beginning.
     (2)P  --  Print  first part of the pattern space Print up to
          and including the first newline in the pattern space.
The P and D functions are equivalent to their lower-case counter-
parts if there are no imbedded newlines in the pattern space.

3.5.  Hold and Get Functions

Four  functions  save and retrieve part of the input for possible
later use.
     (2)h -- hold pattern space The h functions copies  the  con-
          tents of the pattern space into a hold area (destroying
          the previous contents of the hold area).
     (2)H -- Hold pattern space The H function appends  the  con-
          tents  of the pattern space to the contents of the hold
          area; the former and new contents are  separated  by  a
          newline.
     (2)g  -- get contents of hold area The g function copies the
          contents of  the  hold  area  into  the  pattern  space
          (destroying   the  previous  contents  of  the  pattern
          space).
     (2)G -- Get contents of hold area The G function appends the
          contents  of  the hold area to the contents of the pat-
          tern space; the former and new contents  are  separated
          by a newline.
     (2)x  -- exchange The exchange command interchanges the con-
          tents of the pattern space and the hold area.

Example

The commands
        1h
        1s/ did.*//

USD:18-12                    SED -- A Non-interactive Text Editor

        1x
        G
        s/\n/  :/
applied to our standard example, produce:
        In Xanadu did Kubla Khan  :In Xanadu
        A stately pleasure dome decree:  :In Xanadu
        Where Alph, the sacred river, ran  :In Xanadu
        Through caverns measureless to man  :In Xanadu
        Down to a sunless sea.  :In Xanadu

3.6.  Flow-of-Control Functions

These functions do no editing on the input lines, but control the
application  of  functions  to  the lines selected by the address
part.
     (2)! -- Don't The Don't  command  causes  the  next  command
          (written  on  the  same line), to be applied to all and
          only those input lines not selected by the adress part.
     (2){  --  Grouping  The grouping command `{' causes the next
          set of commands to be applied (or  not  applied)  as  a
          block  to  the input lines selected by the addresses of
          the grouping command.  The first of the commands  under
          control  of the grouping may appear on the same line as
          the `{' or on the next line.

          The group of commands is terminated by a  matching  `}'
          standing on a line by itself.

          Groups can be nested.
     (0):<label>  --  place  a  label  The label function marks a
          place in the list of  editing  commands  which  may  be
          referred  to  by b and t functions.  The <label> may be
          any sequence of eight or fewer characters; if two  dif-
          ferent colon functions have identical labels, a compile
          time diagnostic will be  generated,  and  no  execution
          attempted.
     (2)b<label>  --  branch  to label The branch function causes
          the sequence of editing commands being applied  to  the
          current  input  line  to be restarted immediately after
          the place where a colon function with the same  <label>
          was  encountered.   If  no colon function with the same
          label can be found after all the editing commands  have
          been  compiled,  a compile time diagnostic is produced,
          and no execution is attempted.  A b  function  with  no
          <label>  is taken to be a branch to the end of the list
          of editing commands; whatever should be done  with  the
          current  input  line is done, and another input line is
          read; the list of editing commands  is  restarted  from
          the beginning on the new line.
     (2)t<label>  --  test  substitutions  The  t  function tests
          whether any successful substitutions have been made  on
          the  current input line; if so, it branches to <label>;
          if not, it does nothing.  The flag which indicates that
          a  successful  substitution  has been executed is reset

SED -- A Non-interactive Text Editor                    USD:18-13

          by:
                    1) reading a new input line, or
                    2) executing a t function.

3.7. Miscellaneous Functions

     (1)= -- equals The = function writes to the standard  output
          the line number of the line matched by its address.
     (1)q  --  quit  The q function causes the current line to be
          written to the output (if it should be),  any  appended
          or  read text to be written, and execution to be termi-
          nated.

Reference

[1]  Ken Thompson and Dennis M. Ritchie,  The  UNIX  Programmer's
     Manual.  Bell Laboratories, 1978.

       SA+VEgdiTTo lockscreen kbdin pis0857polsiren


Sed - An Introduction and Tutorial by Bruce Barnett
Home
Magic
Search
About
Donate

Last modified: Mon Dec 7 10:13:59 2020
Copyright 1994, 1995 Bruce Barnett and General Electric Company
Copyright 2001,2005,2007,2011,2013 Bruce Barnett
All rights reserved
You are allowed to print copies of this tutorial for your personal use, and link to this page, but you are not allowed to make electronic copies, or redistribute this tutorial in any form without permission.
Original version written in 1994 and published in the Sun Observer
You can buy me a coffee, please

I would appreciate it if you occasionally buy me a coffee as it helps maintain this site.

Check out my Sed Reference Chart (pdf)
Quick Links

As a convenience, and to make my site more mobile-friendly, I moved my quick links to a new page: Click Here
Table of Contents

Note - You can click on the table of contents sections to jump to that section.

Then click on the section header of any section to jump back to the table of contents.

    The Awful Truth about sed
    The essential command: s for substitution
    The slash as a delimiter
    Using & as the matched string
    Using \1 to keep part of the pattern
    Extended Regular Expressions
    Sed Pattern Flags
        /g - Global replacement
        Is sed recursive?
        /1, /2, etc. Specifying which occurrence
        /p - print
        Write to a file with /w filename
        /I - Ignore Case
        Combining substitution flags
    Arguments and invocation of sed
        Multiple commands with -e command
        Filenames on the command line
        sed -n: no printing
        Using 'sed /pattern/'
            Using 'sed -n /pattern/p' to duplicate the function of grep
        sed -f scriptname
        sed in shell scripts
            Quoting multiple sed lines in the C shell
            Quoting multiple sed lines in the Bourne shell
        sed -V
        sed -h
        A sed interpreter script
        Sed Comments
        Passing arguments into a sed script
        Using sed in a shell here-is document
        Multiple commands and order of execution
    Addresses and Ranges of Text
        Restricting to a line number
        Patterns
        Ranges by line number
        Ranges by patterns
    Delete with d
    Printing with p
    Reversing the restriction with !
    Relationships between d, p, and !
    The q or quit command
    Grouping with { and }
    Operating in a pattern range except for the patterns
    Writing a file with the 'w' command
    Reading in a file with the 'r' command
    The # Comment Command
    Adding, Changing, Inserting new lines
        Append a line with 'a'
        Insert a line with 'i'
        Change a line with 'c'
        Leading tabs and spaces in a sed script
        Adding more than one line
        Adding lines and the pattern space
        Address ranges and the above commands
    Multi-Line Patterns
    Print line number with =
    Transform with y
    Displaying control characters with a l
    Working with Multiple Lines
        Matching three lines with sed
        Matching patterns that span multiple lines
        Using newlines in sed scripts
        The Hold Buffer
        Exchange with x
        Example of Context Grep
        Hold with h or H
        Keeping more than one line in the hold buffer
        Get with g or G
    Branch (Flow Control)
    Testing with t
    Debugging with l
    An alternate way of adding comments
    The poorly documented ;
    Passing regular expressions as arguments
    Inserting binary characters
    GNU sed Command Line arguments
        The -posix argument
        The --version argument
        The -h Help argument
        The -l Line Length Argument
        The -s Separate argument
        The -i in-place argument
        The --follow-symlinks argument
        The -b Binary argument
        The -r Extended Regular Expression argument
        The -u Unbuffered argument
        The -z Null Data argument
    FreeBSD Extensions
        -a or delayed open
        The -I in-place argument
        -E or Extended Regular Expressions
    Using word boundaries
    Command Summary
    In Conclusion
    More References

Introduction to Sed

How to use sed, a special editor for modifying files automatically. If you want to write a program to make changes in a file, sed is the tool to use.

There are a few programs that are the real workhorse in the UNIX toolbox. These programs are simple to use for simple applications, yet have a rich set of commands for performing complex actions. Don't let the complex potential of a program keep you from making use of the simpler aspects. I'll start with the simple concepts and introduce the advanced topics later on.
When I first wrote this (in 1994), most versions of sed did not allow you to place comments inside the script. Lines starting with the '#' characters are comments. Newer versions of sed may support comments at the end of the line as well.

One way to think of this is that the old, "classic" version was the basis of GNU, FreeBSD and Solaris versions of sed. And to help you understand what I had to work with, here is the sed(1) manual page from Sun/Oracle.
The Awful Truth about sed

Sed is the ultimate stream editor. If that sounds strange, picture a stream flowing through a pipe. Okay, you can't see a stream if it's inside a pipe. That's what I get for attempting a flowing analogy. You want literature, read James Joyce.

Anyhow, sed is a marvelous utility. Unfortunately, most people never learn its real power. The language is very simple, but the documentation is terrible. The Solaris on-line manual pages for sed are five pages long, and two of those pages describe the 34 different errors you can get. A program that spends as much space documenting the errors as it does documenting the language has a serious learning curve.

Do not fret! It is not your fault you don't understand sed. I will cover sed completely. But I will describe the features in the order that I learned them. I didn't learn everything at once. You don't need to either.
The essential command: s for substitution

Sed has several commands, but most people only learn the substitute command: s. The substitute command changes all occurrences of the regular expression into a new value. A simple example is changing "day" in the "old" file to "night" in the "new" file:

sed s/day/night/ <old >new

Or another way (for UNIX beginners),

sed s/day/night/ old >new

and for those who want to test this:

echo day | sed s/day/night/ 

This will output "night".

I didn't put quotes around the argument because this example didn't need them. If you read my earlier tutorial on quotes, you would understand why it doesn't need quotes. However, I recommend you do use quotes. If you have meta-characters in the command, quotes are necessary. And if you aren't sure, it's a good habit, and I will henceforth quote future examples to emphasize the "best practice." Using the strong (single quote) character, that would be:

sed 's/day/night/' <old >new

I must emphasize that the sed editor changes exactly what you tell it to. So if you executed

echo Sunday | sed 's/day/night/'

This would output the word "Sunnight" because sed found the string "day" in the input.

Another important concept is that sed is line oriented. Suppose you have the input file:

one two three, one two three
four three two one
one hundred

and you used the command

sed 's/one/ONE/' <file

The output would be

ONE two three, one two three
four three two ONE
ONE hundred

Note that this changed "one" to "ONE" once on each line. The first line had "one" twice, but only the first occurrence was changed. That is the default behavior. If you want something different, you will have to use some of the options that are available. I'll explain them later.

So let's continue.

There are four parts to this substitute command:

s	  Substitute command
/../../	  Delimiter
one	  Regular Expression Pattern Search Pattern
ONE	  Replacement string

The search pattern is on the left hand side and the replacement string is on the right hand side.

We've covered quoting and regular expressions.. That's 90% of the effort needed to learn the substitute command. To put it another way, you already know how to handle 90% of the most frequent uses of sed. There are a ... few fine points that any future sed expert should know about. (You just finished section 1. There are only 63 more sections to cover. :-) Oh. And you may want to bookmark this page, .... just in case you don't finish.
The slash as a delimiter

The character after the s is the delimiter. It is conventionally a slash, because this is what ed, more, and vi use. It can be anything you want, however. If you want to change a pathname that contains a slash - say /usr/local/bin to /common/bin - you could use the backslash to quote the slash:

sed 's/\/usr\/local\/bin/\/common\/bin/' <old >new

Gulp. Some call this a 'Picket Fence' and it's ugly. It is easier to read if you use an underline instead of a slash as a delimiter:

sed 's_/usr/local/bin_/common/bin_' <old >new

Some people use colons:

sed 's:/usr/local/bin:/common/bin:' <old >new

Others use the "|" character.

sed 's|/usr/local/bin|/common/bin|' <old >new

Pick one you like. As long as it's not in the string you are looking for, anything goes. And remember that you need three delimiters. If you get a "Unterminated `s' command" it's because you are missing one of them.
Using & as the matched string

Sometimes you want to search for a pattern and add some characters, like parenthesis, around or near the pattern you found. It is easy to do this if you are looking for a particular string:

sed 's/abc/(abc)/' <old >new

This won't work if you don't know exactly what you will find. How can you put the string you found in the replacement string if you don't know what it is?

The solution requires the special character "&." It corresponds to the pattern found.

sed 's/[a-z]*/(&)/' <old >new

You can have any number of "&" in the replacement string. You could also double a pattern, e.g. the first number of a line:

% echo "123 abc" | sed 's/[0-9]*/& &/'
123 123 abc

Let me slightly amend this example. Sed will match the first string, and make it as greedy as possible. I'll cover that later. If you don't want it to be so greedy (i.e. limit the matching), you need to put restrictions on the match.

The first match for '[0-9]*' is the first character on the line, as this matches zero or more numbers. So if the input was "abc 123" the output would be unchanged (well, except for a space before the letters). A better way to duplicate the number is to make sure it matches a number:

% echo "123 abc" | sed 's/[0-9][0-9]*/& &/'
123 123 abc

The string "abc" is unchanged, because it was not matched by the regular expression. If you wanted to eliminate "abc" from the output, you must expand the regular expression to match the rest of the line and explicitly exclude part of the expression using "(", ")" and "\1", which is the next topic.
Extended Regular Expressions

Let me add a quick comment here because there is another way to write the above script. "[0-9]*" matches zero or more numbers. "[0-9][0-9]*" matches one or more numbers. Another way to do this is to use the "+" meta-character and use the pattern "[0-9]+" as the "+" is a special character when using "extended regular expressions." Extended regular expressions have more power, but sed scripts that treated "+" as a normal character would break. Therefore you must explicitly enable this extension with a command line option.

GNU sed turns this feature on if you use the "-r" command line option. So the above could also be written using

% echo "123 abc" | sed -r 's/[0-9]+/& &/'
123 123 abc

Mac OS X and FreeBSD uses -E instead of -r. For more information on extended regular expressions, see Regular Expressions and the description of the -r command line argument
Using \1 to keep part of the pattern

I have already described the use of "(" ")" and "1" in my tutorial on regular expressions. To review, the escaped parentheses (that is, parentheses with backslashes before them) remember a substring of the characters matched by the regular expression. You can use this to exclude part of the characters matched by the regular expression. The "\1" is the first remembered pattern, and the "\2" is the second remembered pattern. Sed has up to nine remembered patterns.

If you wanted to keep the first word of a line, and delete the rest of the line, mark the important part with the parenthesis:

sed 's/\([a-z]*\).*/\1/'

I should elaborate on this. Regular expressions are greedy, and try to match as much as possible. "[a-z]*" matches zero or more lower case letters, and tries to match as many characters as possible. The ".*" matches zero or more characters after the first match. Since the first one grabs all of the contiguous lower case letters, the second matches anything else. Therefore if you type

echo abcd123 | sed 's/\([a-z]*\).*/\1/'

This will output "abcd" and delete the numbers.

If you want to switch two words around, you can remember two patterns and change the order around:

sed 's/\([a-z]*\) \([a-z]*\)/\2 \1/'

Note the space between the two remembered patterns. This is used to make sure two words are found. However, this will do nothing if a single word is found, or any lines with no letters. You may want to insist that words have at least one letter by using

sed 's/\([a-z][a-z]*\) \([a-z][a-z]*\)/\2 \1/'

or by using extended regular expressions (note that '(' and ')' no longer need to have a backslash):

sed -r 's/([a-z]+) ([a-z]+)/\2 \1/' # Using GNU sed
sed -E 's/([a-z]+) ([a-z]+)/\2 \1/' # Using Apple Mac OS X

The "\1" doesn't have to be in the replacement string (in the right hand side). It can be in the pattern you are searching for (in the left hand side). If you want to eliminate duplicated words, you can try:

sed 's/\([a-z]*\) \1/\1/'

If you want to detect duplicated words, you can use

sed -n '/\([a-z][a-z]*\) \1/p'

or with extended regular expressions

sed -rn '/([a-z]+) \1/p' # GNU sed
sed -En '/([a-z]+) \1/p' # Mac OS X

This, when used as a filter, will print lines with duplicated words.

The numeric value can have up to nine values: "\1" thru "\9." If you wanted to reverse the first three characters on a line, you can use

sed 's/^\(.\)\(.\)\(.\)/\3\2\1/'

Sed Pattern Flags

You can add additional flags after the last delimiter. You might have noticed I used a 'p' at the end of the previous substitute command. I also added the '-n' option. Let me first cover the 'p' and other pattern flags. These flags can specify what happens when a match is found. Let me describe them.
/g - Global replacement

Most UNIX utilities work on files, reading a line at a time. Sed, by default, is the same way. If you tell it to change a word, it will only change the first occurrence of the word on a line. You may want to make the change on every word on the line instead of the first. For an example, let's place parentheses around words on a line. Instead of using a pattern like "[A-Za-z]*" which won't match words like "won't," we will use a pattern, "[^ ]*," that matches everything except a space. Well, this will also match anything because "*" means zero or more. The current version of Solaris's sed (as I wrote this) can get unhappy with patterns like this, and generate errors like "Output line too long" or even run forever. I consider this a bug, and have reported this to Sun. As a work-around, you must avoid matching the null string when using the "g" flag to sed. A work-around example is: "[^ ][^ ]*." The following will put parenthesis around the first word:

sed 's/[^ ]*/(&)/' <old >new

If you want it to make changes for every word, add a "g" after the last delimiter and use the work-around:

sed 's/[^ ][^ ]*/(&)/g' <old >new

Is sed recursive?

Sed only operates on patterns found in the in-coming data. That is, the input line is read, and when a pattern is matched, the modified output is generated, and the rest of the input line is scanned. The "s" command will not scan the newly created output. That is, you don't have to worry about expressions like:

sed 's/loop/loop the loop/g' <old >new

This will not cause an infinite loop. If a second "s" command is executed, it could modify the results of a previous command. I will show you how to execute multiple commands later.
/1, /2, etc. Specifying which occurrence

With no flags, the first matched substitution is changed. With the "g" option, all matches are changed. If you want to modify a particular pattern that is not the first one on the line, you could use "\(" and "\)" to mark each pattern, and use "\1" to put the first pattern back unchanged. This next example keeps the first word on the line but deletes the second:

sed 's/\([a-zA-Z]*\) \([a-zA-Z]*\) /\1 /' <old >new

Yuck. There is an easier way to do this. You can add a number after the substitution command to indicate you only want to match that particular pattern. Example:

sed 's/[a-zA-Z]* //2' <old >new

You can combine a number with the g (global) flag. For instance, if you want to leave the first word alone, but change the second, third, etc. to be DELETED instead, use /2g:

sed 's/[a-zA-Z]* /DELETED /2g' <old >new

I've heard that combining the number with the g command does not work on The MacOS, and perhaps the FreeSBD version of sed as well.

Don't get /2 and \2 confused. The /2 is used at the end. \2 is used in inside the replacement field.

Note the space after the "*" character. Without the space, sed will run a long, long time. (Note: this bug is probably fixed by now.) This is because the number flag and the "g" flag have the same bug. You should also be able to use the pattern

sed 's/[^ ]*//2' <old >new

but this also eats CPU. If this works on your computer, and it does on some UNIX systems, you could remove the encrypted password from the password file:

sed 's/[^:]*//2' </etc/passwd >/etc/password.new

But this didn't work for me the time I wrote this. Using "[^:][^:]*" as a work-around doesn't help because it won't match a non-existent password, and instead delete the third field, which is the user ID! Instead you have to use the ugly parenthesis:

sed 's/^\([^:]*\):[^:]:/\1::/'  </etc/passwd >/etc/password.new

You could also add a character to the first pattern so that it no longer matches the null pattern:

sed 's/[^:]*:/:/2'  </etc/passwd >/etc/password.new

The number flag is not restricted to a single digit. It can be any number from 1 to 512. If you wanted to add a colon after the 80th character in each line, you could type:

sed 's/./&:/80' <file >new

You can also do it the hard way by using 80 dots:

sed 's/^................................................................................/&:/' <file >new

/p - print

By default, sed prints every line. If it makes a substitution, the new text is printed instead of the old one. If you use an optional argument to sed, "sed -n," it will not, by default, print any new lines. I'll cover this and other options later. When the "-n" option is used, the "p" flag will cause the modified line to be printed. Here is one way to duplicate the function of grep with sed:

sed -n 's/pattern/&/p' <file

But a simpler version is described later
Write to a file with /w filename

There is one more flag that can follow the third delimiter. With it, you can specify a file that will receive the modified data. An example is the following, which will write all lines that start with an even number, followed by a space, to the file even:

sed -n 's/^[0-9]*[02468] /&/w even' <file 

In this example, the output file isn't needed, as the input was not modified. You must have exactly one space between the w and the filename. You can also have ten files open with one instance of sed. This allows you to split up a stream of data into separate files. Using the previous example combined with multiple substitution commands described later, you could split a file into ten pieces depending on the last digit of the first number. You could also use this method to log error or debugging information to a special file.
/I - Ignore Case

GNU has added another pattern flags - /I

This flag makes the pattern match case insensitive. This will match abc, aBc, ABC, AbC, etc.:

sed -n '/abc/I p' <old >new

Note that a space after the '/I' and the 'p' (print) command emphasizes that the 'p' is not a modifier of the pattern matching process, , but a command to execute after the pattern matching.
Combining substitution flags

You can combine flags when it makes sense. Please note that the "w" has to be the last flag. For example the following command works:

sed -n 's/a/A/2pw /tmp/file' <old >new

Next I will discuss the options to sed, and different ways to invoke sed.
Arguments and invocation of sed

previously, I have only used one substitute command. If you need to make two changes, and you didn't want to read the manual, you could pipe together multiple sed commands:

sed 's/BEGIN/begin/' <old | sed 's/END/end/' >new

This used two processes instead of one. A sed guru never uses two processes when one can do.
Multiple commands with -e command

One method of combining multiple commands is to use a -e before each command:

sed -e 's/a/A/' -e 's/b/B/' <old >new

A "-e" isn't needed in the earlier examples because sed knows that there must always be one command. If you give sed one argument, it must be a command, and sed will edit the data read from standard input.

The long argument version is

sed --expression='s/a/A/' --expression='s/b/B/' <old >new

Also see Quoting multiple sed lines in the Bourne shell
Filenames on the command line

You can specify files on the command line if you wish. If there is more than one argument to sed that does not start with an option, it must be a filename. This next example will count the number of lines in three files that don't begin with a "#:"

sed 's/^#.*//'  f1 f2 f3 | grep -v '^$' | wc -l

Let's break this down into pieces. The sed substitute command changes every line that starts with a "#" into a blank line. Grep was used to filter out (delete) empty lines. Wc counts the number of lines left. Sed has more commands that make grep unnecessary. And grep -c can replace wc -l. I'll discuss how you can duplicate some of grep's functionality later.

Of course you could write the last example using the "-e" option:

sed -e 's/^#.*//'  f1 f2 f3 | grep -v '^$' | wc -l

There are two other options to sed.
sed -n: no printing

The "-n" option will not print anything unless an explicit request to print is found. I mentioned the "/p" flag to the substitute command as one way to turn printing back on. Let me clarify this. The command

sed  's/PATTERN/&/p' file

acts like the cat program if PATTERN is not in the file: e.g. nothing is changed. If PATTERN is in the file, then each line that has this is printed twice. Add the "-n" option and the example acts like grep:

sed -n 's/PATTERN/&/p' file

Nothing is printed, except those lines with PATTERN included.

The long argument of the -n command is either

sed --quiet 's/PATTERN/&/p' file

or

sed --silent 's/PATTERN/&/p' file

Using 'sed /pattern/'

Sed has the ability to specify which lines are to be examined and/or modified, by specifying addresses before the command. I will just describe the simplest version for now - the /PATTERN/ address. When used, only lines that match the pattern are given the command after the address. Briefly, when used with the /p flag, matching lines are printed twice:

sed '/PATTERN/p' file

And of course PATTERN is any regular expression.

Please note that if you do not include a command, such as the "p" for print, you will get an error. When I type

echo abc | sed '/a/'

I get the error

sed: -e expression #1, char 3: missing command

Also, you don't need to, but I recommend that you place a space after the pattern and the command. This will help you distinguish between flags that modify the pattern matching, and commands to execute after the pattern is matched. Therefore I recommend this style:

sed '/PATTERN/ p' file

Using 'sed -n /pattern/p' to duplicate the function of grep

If you want to duplicate the functionality of grep, combine the -n (noprint) option with the /p print flag:

sed -n '/PATTERN/p' file

sed -f scriptname

If you have a large number of sed commands, you can put them into a file and use

sed -f sedscript <old >new

where sedscript could look like this:

# sed comment - This script changes lower case vowels to upper case
s/a/A/g
s/e/E/g
s/i/I/g
s/o/O/g
s/u/U/g

When there are several commands in one file, each command must be on a separate line.

The long argument version is

sed --file=sedscript <old >new

Also see here on writing a script that executes sed directly
sed in shell scripts

If you have many commands and they won't fit neatly on one line, you can break up the line using a backslash:

sed -e 's/a/A/g' \
    -e 's/e/E/g' \
    -e 's/i/I/g' \
    -e 's/o/O/g' \
    -e 's/u/U/g'  <old >new

Quoting multiple sed lines in the C shell

You can have a large, multi-line sed script in the C shell, but you must tell the C shell that the quote is continued across several lines. This is done by placing a backslash at the end of each line:

#!/bin/csh -f
sed 's/a/A/g  \
s/e/E/g \
s/i/I/g \
s/o/O/g \
s/u/U/g'  <old >new

Quoting multiple sed lines in the Bourne shell

The Bourne shell makes this easier as a quote can cover several lines:

#!/bin/sh
sed '
s/a/A/g 
s/e/E/g 
s/i/I/g 
s/o/O/g 
s/u/U/g'  <old >new

sed -V

The -V option will print the version of sed you are using. The long argument of the command is

sed --version

sed -h

The -h option will print a summary of the sed commands. The long argument of the command is

sed --help

A sed interpreter script

Another way of executing sed is to use an interpreter script. Create a file that contains:

#!/bin/sed -f
s/a/A/g
s/e/E/g
s/i/I/g
s/o/O/g
s/u/U/g


Click here to get file: CapVowel.sed
If this script was stored in a file with the name "CapVowel" and was executable, you could use it with the simple command:

CapVowel <old >new

Comments

Sed comments are lines where the first non-white character is a "#." On many systems, sed can have only one comment, and it must be the first line of the script. On the Sun (1988 when I wrote this), you can have several comment lines anywhere in the script. Modern versions of Sed support this. If the first line contains exactly "#n" then this does the same thing as the "-n" option: turning off printing by default. This could not done with a sed interpreter script, because the first line must start with "#!/bin/sed -f" as I think "#!/bin/sed -nf" generated an error. It worked when I first wrote this (2008). Note that "#!/bin/sed -fn" does not work because sed thinks the filename of the script is "n". However,

"#!/bin/sed -nf" 

does work.
Passing arguments into a sed script

Passing a word into a shell script that calls sed is easy if you remembered my tutorial on the UNIX quoting mechanism. To review, you use the single quotes to turn quoting on and off. A simple shell script that uses sed to emulate grep is:

#!/bin/sh
sed -n 's/'$1'/&/p'

However - there is a subtle problem with this script. If you have a space as an argument, the script would cause a syntax error, such as

sed: -e expression #1, char 4: unterminated `s' command

A better version would protect from this happening:

#!/bin/sh
sed -n 's/'"$1"'/&/p'


Click here to get file: sedgrep.sed
If this was stored in a file called sedgrep, you could type

sedgrep '[A-Z][A-Z]' <file

This would allow sed to act as the grep command.
Using sed in a shell here-is document

You can use sed to prompt the user for some parameters and then create a file with those parameters filled in. You could create a file with dummy values placed inside it, and use sed to change those dummy values. A simpler way is to use the "here is" document, which uses part of the shell script as if it were standard input:

#!/bin/sh
echo -n 'what is the value? '
read value
sed  's/XYZ/'$value'/' <<EOF
The value is XYZ
EOF

When executed, the script says:

what is the value?

If you type in "123," the next line will be:

The value is 123

I admit this is a contrived example. "Here is" documents can have values evaluated without the use of sed. This example does the same thing:

#!/bin/sh
echo -n 'what is the value? '
read value
cat <<EOF
The value is $value
EOF

However, combining "here is" documents with sed can be useful for some complex cases.
Note that

sed 's/XYZ/'$value'/' <<EOF

will give a syntax error if the user types an answer that contains a space, like "a b c". Better form would be to put double quotes around the evaluation of the value:

#!/bin/sh
echo -n 'what is the value? '
read value
sed  's/XYZ/'"$value"'/' <<EOF
The value is XYZ
EOF

I covered this in my tutorial on quotation marks.
Click here to get file: sed_hereis.sed
Multiple commands and order of execution

As we explore more of the commands of sed, the commands will become complex, and the actual sequence can be confusing. It's really quite simple. Each line is read in. Each command, in order specified by the user, has a chance to operate on the input line. After the substitutions are made, the next command has a chance to operate on the same line, which may have been modified by earlier commands. If you ever have a question, the best way to learn what will happen is to create a small example. If a complex command doesn't work, make it simpler. If you are having problems getting a complex script working, break it up into two smaller scripts and pipe the two scripts together.
Addresses and Ranges of Text

You have only learned one command, and you can see how powerful sed is. However, all it is doing is a grep and substitute. That is, the substitute command is treating each line by itself, without caring about nearby lines. What would be useful is the ability to restrict the operation to certain lines. Some useful restrictions might be:


        Specifying a line by its number.
        Specifying a range of lines by number.
        All lines containing a pattern.
        All lines from the beginning of a file to a regular expression
        All lines from a regular expression to the end of the file.
        All lines between two regular expressions.

Sed can do all that and more. Every command in sed can be proceeded by an address, range or restriction like the above examples. The restriction or address immediately precedes the command:

    restriction command

Restricting to a line number

The simplest restriction is a line number. If you wanted to delete the first number on line 3, just add a "3" before the command:

sed '3 s/[0-9][0-9]*//' <file >new

Patterns

Many UNIX utilities like vi and more use a slash to search for a regular expression. Sed uses the same convention, provided you terminate the expression with a slash. To delete the first number on all lines that start with a "#," use:

sed '/^#/ s/[0-9][0-9]*//'

I placed a space after the "/expression/" so it is easier to read. It isn't necessary, but without it the command is harder to fathom. Sed does provide a few extra options when specifying regular expressions. But I'll discuss those later. If the expression starts with a backslash, the next character is the delimiter. To use a comma instead of a slash, use:

sed '\,^#, s/[0-9][0-9]*//'

The main advantage of this feature is searching for slashes. Suppose you wanted to search for the string "/usr/local/bin" and you wanted to change it for "/common/all/bin." You could use the backslash to escape the slash:

sed '/\/usr\/local\/bin/ s/\/usr\/local/\/common\/all/'

It would be easier to follow if you used an underline instead of a slash as a search. This example uses the underline in both the search command and the substitute command:

sed '\_/usr/local/bin_ s_/usr/local_/common/all_'

This illustrates why sed scripts get the reputation for obscurity. I could be perverse and show you the example that will search for all lines that start with a "g," and change each "g" on that line to an "s:"

sed '/^g/s/g/s/g'

Adding a space and using an underscore after the substitute command makes this much easier to read:

sed '/^g/ s_g_s_g'

Er, I take that back. It's hopeless. There is a lesson here: Use comments liberally in a sed script. You may have to remove the comments to run the script under a different (older) operating system, but you now know how to write a sed script to do that very easily! Comments are a Good Thing. You may have understood the script perfectly when you wrote it. But six months from now it could look like modem noise. And if you don't understand that reference, imagine an 8-month-old child typing on a computer.
Ranges by line number

You can specify a range on line numbers by inserting a comma between the numbers. To restrict a substitution to the first 100 lines, you can use:

sed '1,100 s/A/a/'

If you know exactly how many lines are in a file, you can explicitly state that number to perform the substitution on the rest of the file. In this case, assume you used wc to find out there are 532 lines in the file:

sed '101,532 s/A/a/'

An easier way is to use the special character "$," which means the last line in the file.

sed '101,$ s/A/a/'

The "$" is one of those conventions that mean "last" in utilities like cat -e, vi, and ed. "cat -e" Line numbers are cumulative if several files are edited. That is,

sed '200,300 s/A/a/' f1 f2 f3 >new

is the same as

cat f1 f2 f3 | sed '200,300 s/A/a/' >new

Ranges by patterns

You can specify two regular expressions as the range. Assuming a "#" starts a comment, you can search for a keyword, remove all comments until you see the second keyword. In this case the two keywords are "start" and "stop:"

sed '/start/,/stop/ s/#.*//'

The first pattern turns on a flag that tells sed to perform the substitute command on every line. The second pattern turns off the flag. If the "start" and "stop" pattern occurs twice, the substitution is done both times. If the "stop" pattern is missing, the flag is never turned off, and the substitution will be performed on every line until the end of the file.

You should know that if the "start" pattern is found, the substitution occurs on the same line that contains "start." This turns on a switch, which is line oriented. That is, the next line is read and the substitute command is checked. If it contains "stop" the switch is turned off. Switches are line oriented, and not word oriented.

You can combine line numbers and regular expressions. This example will remove comments from the beginning of the file until it finds the keyword "start:"

sed -e '1,/start/ s/#.*//'

This example will remove comments everywhere except the lines between the two keywords:

sed -e '1,/start/ s/#.*//' -e '/stop/,$ s/#.*//'

The last example has a range that overlaps the "/start/,/stop/" range, as both ranges operate on the lines that contain the keywords. I will show you later how to restrict a command up to, but not including the line containing the specified pattern. It is in Operating in a pattern range except for the patterns But I have to cover some more basic principles.

Before I start discussing the various commands, I should explain that some commands cannot operate on a range of lines. I will let you know when I mention the commands. In this next section I will describe three commands, one of which cannot operate on a range.
Delete with d

Using ranges can be confusing, so you should expect to do some experimentation when you are trying out a new script. A useful command deletes every line that matches the restriction: "d." If you want to look at the first 10 lines of a file, you can use:

sed '11,$ d' <file 

which is similar in function to the head command. If you want to chop off the header of a mail message, which is everything up to the first blank line, use:

sed '1,/^$/ d' <file

You can duplicate the function of the tail command, assuming you know the length of a file. Wc can count the lines, and expr can subtract 10 from the number of lines. A Bourne shell script to look at the last 10 lines of a file might look like this:

#!/bin/sh
#print last 10 lines of file
# First argument is the filename
lines=$(wc -l "$1" | awk '{print $1}' )
start=$(( lines - 10))
sed "1,$start d" "$1"


Click here to get file: sed_tail.sh
The range for deletions can be regular expressions pairs to mark the begin and end of the operation. Or it can be a single regular expression. Deleting all lines that start with a "#" is easy:

sed '/^#/ d'

Removing comments and blank lines takes two commands. The first removes every character from the "#" to the end of the line, and the second deletes all blank lines:

sed -e 's/#.*//' -e '/^$/ d'

A third one should be added to remove all blanks and tabs immediately before the end of line:

sed -e 's/#.*//' -e 's/[ ^I]*$//' -e '/^$/ d' 

The character "^I" is a CTRL-I or tab character. You would have to explicitly type in the tab. Note the order of operations above, which is in that order for a very good reason. Comments might start in the middle of a line, with white space characters before them. Therefore comments are first removed from a line, potentially leaving white space characters that were before the comment. The second command removes all trailing blanks, so that lines that are now blank are converted to empty lines. The last command deletes empty lines. Together, the three commands remove all lines containing only comments, tabs or spaces.

This demonstrates the pattern space sed uses to operate on a line. The actual operation sed uses is:


        Copy the input line into the pattern space.
        Apply the first
        sed command on the pattern space, if the address restriction is true.
        Repeat with the next sed expression, again
        operating on the pattern space.
        When the last operation is performed, write out the pattern space
        and read in the next line from the input file.

Printing with p

Another useful command is the print command: "p." If sed wasn't started with an "-n" option, the "p" command will duplicate the input. The command

sed 'p'

will duplicate every line. If you wanted to double every empty line, use:

sed '/^$/ p'

Adding the "-n" option turns off printing unless you request it. Another way of duplicating head's functionality is to print only the lines you want. This example prints the first 10 lines:

sed -n '1,10 p' <file

Sed can act like grep by combining the print operator to function on all lines that match a regular expression:

sed -n '/match/ p' 

which is the same as:

grep match

Reversing the restriction with !

Sometimes you need to perform an action on every line except those that match a regular expression, or those outside of a range of addresses. The "!" character, which often means not in UNIX utilities, inverts the address restriction. You remember that

sed -n '/match/ p'

acts like the grep command. The "-v" option to grep prints all lines that don't contain the pattern. Sed can do this with

sed -n '/match/ !p' </tmp/b

Relationships between d, p, and !

As you may have noticed, there are often several ways to solve the same problem with sed. This is because print and delete are opposite functions, and it appears that "!p" is similar to "d," while "!d" is similar to "p." I wanted to test this, so I created a 20 line test file, and tried every different combination. The following table, which shows the results of by test, demonstrates the difference:
Relations between d, p, and !
Sed 	Range 	Command 	Results
sed -n 	1,10 	p 	Print first 10 lines
sed -n 	11,$ 	!p 	Print first 10 lines
sed 	1,10 	!d 	Print first 10 lines
sed 	11,$ 	d 	Print first 10 lines
sed -n 	1,10 	!p 	Print last 10 lines of my 20-line file
sed -n 	11,$ 	p 	Print last 10 lines of my 20-line file
sed 	1,10 	d 	Print last 10 lines of my 20-line file
sed 	11,$ 	!d 	Print last 10 lines of my 20-line file
sed -n 	1,10 	d 	Nothing printed
sed -n 	1,10 	!d 	Nothing printed
sed -n 	11,$ 	d 	Nothing printed
sed -n 	11,$ 	!d 	Nothing printed
sed 	1,10 	p 	Print first 10 lines twice, then next 10 lines once
sed 	11,$ 	!p 	Print first 10 lines twice, then last 10 lines once
sed 	1,10 	!p 	Print first 10 lines once, then last 10 lines twice
sed 	11,$ 	p 	Print first 10 lines once, then last 10 lines twice

This table shows that using my 20-line test file, the following commands are identical:

sed -n '1,10 p'
sed -n '11,$ !p'
sed '1,10 !d'
sed '11,$ d'

It also shows that the "!" command "inverts" the address range, operating on the other lines.

Of course for files longer than 20 lines, you will get more than 10 lines for the last two cases.
The q or quit command

There is one more simple command that can restrict the changes to a set of lines. It is the "q" command: quit. the third way to duplicate the head command is:

sed '11 q'

which quits when the eleventh line is reached. This command is most useful when you wish to abort the editing after some condition is reached.

The "q" command is the one command that does not take a range of addresses. Obviously the command

sed '1,10 q'

cannot quit 10 times. Instead

sed '1 q'

or

sed '10 q'

is correct.
Grouping with { and }

The curly braces, "{" and "}," are used to group the commands.

Hardly worth the buildup. All that prose and the solution is just matching squiggles. Well, there is one complication. Since each sed command must start on its own line, the curly braces and the nested sed commands must be on separate lines.

Previously, I showed you how to remove comments starting with a "#." If you wanted to restrict the removal to lines between special "begin" and "end" key words, you could use:

#!/bin/sh
# This is a Bourne shell script that removes #-type comments
# between 'begin' and 'end' words.
sed -n '
	/begin/,/end/ {
	     s/#.*//
	     s/[ ^I]*$//
	     /^$/ d
	     p
	}
'


Click here to get file: sed_begin_end.sh
These braces can be nested, which allow you to combine address ranges. You could perform the same action as before, but limit the change to the first 100 lines:

#!/bin/sh
# This is a Bourne shell script that removes #-type comments
# between 'begin' and 'end' words.
sed -n '
	1,100 {
		/begin/,/end/ {
		     s/#.*//
		     s/[ ^I]*$//
		     /^$/ d
		     p
		}
	}
'


Click here to get file: sed_begin_end1.sh
You can place a "!" before a set of curly braces. This inverts the address, which removes comments from all lines except those between the two reserved words:

#!/bin/sh
sed '
	/begin/,/end/ !{
	     s/#.*//
	     s/[ ^I]*$//
	     /^$/ d
	     p
	}
'


Click here to get file: sed_begin_end2.sh
Operating in a pattern range except for the patterns

You may remember that I mentioned you can do a substitute on a pattern range, like changing "old" to "new" between a begin/end pattern:

#!/bin/sh
sed '
	/begin/,/end/ s/old/new/
'

Another way to write this is to use the curly braces for grouping:

#!/bin/sh
sed '
	/begin/,/end/ {
	    s/old/new/
	}
'

I think this makes the code clearer to understand, and easier to modify, as you will see below.

If you did not want to make any changes where the word "begin" occurred, you could simple add a new condition to skip over that line:

#!/bin/sh
sed '
	/begin/,/end/ {
	    /begin/n # skip over the line that has "begin" on it
	    s/old/new/
	}
'

However, skipping over the line that has "end" is trickier. If you use the same method you used for "begin" then the sed engine will not see the "end" to stop the range - it skips over that as well. The solution is to do a substitute on all lines that don't have the "end" by using

#!/bin/sh
sed '
    /begin/,/end/ {
      /begin/n # skip over the line that has "begin" on it
      /end/ !{
        s/old/new/
      }  
    }
'

Writing a file with the 'w' command

You may remember that the substitute command can write to a file. Here again is the example that will only write lines that start with an even number (and followed by a space):

sed -n 's/^[0-9]*[02468] /&/w even' <file 

I used the "&" in the replacement part of the substitution command so that the line would not be changed. A simpler example is to use the "w" command, which has the same syntax as the "w" flag in the substitute command:

sed -n '/^[0-9]*[02468]/ w even' <file

Remember - only one space must follow the command. Anything else will be considered part of the file name. The "w" command also has the same limitation as the "w" flag: only 10 files can be opened in sed.
Reading in a file with the 'r' command

There is also a command for reading files. The command

sed '$r end' <in>out

will append the file "end" at the end of the file (address "$)." The following will insert a file after the line with the word "INCLUDE:"

sed '/INCLUDE/ r file' <in >out

You can use the curly braces to delete the line having the "INCLUDE" command on it:

#!/bin/sh
sed '/INCLUDE/ {
	r file
	d
}'


Click here to get file: sed_include.sh

The order of the delete command "d" and the read file command "r" is important. Change the order and it will not work. There are two subtle actions that prevent this from working. The first is the "r" command writes the file to the output stream. The file is not inserted into the pattern space, and therefore cannot be modified by any command. Therefore the delete command does not affect the data read from the file.

The other subtlety is the "d" command deletes the current data in the pattern space. Once all of the data is deleted, it does make sense that no other action will be attempted. Therefore a "d" command executed in a curly brace also aborts all further actions. As an example, the substitute command below is never executed:

#!/bin/sh
# this example is WRONG
sed -e '1 {
	d
	s/.*//
}'


Click here to get file: sed_bad_example.sh

The earlier example is a crude version of the C preprocessor program. The file that is included has a predetermined name. It would be nice if sed allowed a variable (e.g "\1" ) instead of a fixed file name. Alas, sed doesn't have this ability. You could work around this limitation by creating sed commands on the fly, or by using shell quotes to pass variables into the sed script. Suppose you wanted to create a command that would include a file like cpp, but the filename is an argument to the script. An example of this script is:

% include 'sys/param.h' <file.c >file.c.new

A shell script to do this would be:

#!/bin/sh
# watch out for a '/' in the parameter
# use alternate search delimiter
sed -e '\_#INCLUDE <'"$1"'>_{
	r '"$1"'
	d
}'

Let me elaborate. If you had a file that contains

Test first file
#INCLUDE <file1>
Test second file
#INCLUDE <file2>

you could use the command

sed_include1.sh file1<input|sed_include1.sh file2

to include the specified files.


Click here to get file: sed_include1.sh
The # Comment Command

As we dig deeper into sed, comments will make the commands easier to follow. The older versions of sed only allow one line as a comment, and it must be the first line. SunOS (and GNU's sed) allows more than one comment, and these comments don't have to be first. The last example could be:

#!/bin/sh
# watch out for a '/' in the parameter
# use alternate search delimiter
sed -e '\_#INCLUDE <'"$1"'>_{

	# read the file
	r '"$1"'

	# delete any characters in the pattern space
	# and read the next line in
	d
}'


Click here to get file: sed_include2.sh
Adding, Changing, Inserting new lines

Sed has three commands used to add new lines to the output stream. Because an entire line is added, the new line is on a line by itself to emphasize this. There is no option, an entire line is used, and it must be on its own line. If you are familiar with many UNIX utilities, you would expect sed to use a similar convention: lines are continued by ending the previous line with a "\". The syntax to these commands is finicky, like the "r" and "w" commands.
Append a line with 'a'

The "a" command appends a line after the range or pattern. This example will add a line after every line with "WORD:"

#!/bin/sh
sed '
/WORD/ a\
Add this line after every line with WORD
'


Click here to get file: sed_add_line_after_word.sh

You could eliminate two lines in the shell script if you wish:

#!/bin/sh
sed '/WORD/ a\
Add this line after every line with WORD'


Click here to get file: sed_add_line_after_word1.sh

I prefer the first form because it's easier to add a new command by adding a new line and because the intent is clearer. There must not be a space after the "\".
Insert a line with 'i'

You can insert a new line before the pattern with the "i" command:

#!/bin/sh
sed '
/WORD/ i\
Add this line before every line with WORD
'


Click here to get file: sed_add_line_before_word.sh
Change a line with 'c'

You can change the current line with a new line.

#!/bin/sh
sed '
/WORD/ c\
Replace the current line with the line
'


Click here to get file: sed_change_line.sh

A "d" command followed by a "a" command won't work, as I discussed earlier. The "d" command would terminate the current actions. You can combine all three actions using curly braces:

#!/bin/sh
sed '
/WORD/ {
i\
Add this line before
a\
Add this line after
c\
Change the line to this one
}'


Click here to get file: sed_insert_append_change.sh
Leading tabs and spaces in a sed script

Sed ignores leading tabs and spaces in all commands. However these white space characters may or may not be ignored if they start the text following a "a," "c" or "i" command. In SunOS, both "features" are available. The Berkeley (and Linux) style sed is in /usr/bin, and the AT&T version (System V) is in /usr/5bin/.

To elaborate, the /usr/bin/sed command retains white space, while the /usr/5bin/sed strips off leading spaces. If you want to keep leading spaces, and not care about which version of sed you are using, put a "\" as the first character of the line:

#!/bin/sh
sed '
	a\
\	This line starts with a tab
'

Adding more than one line

All three commands will allow you to add more than one line. Just end each line with a "\:"

#!/bin/sh
sed '
/WORD/ a\
Add this line\
This line\
And this line
'

Adding lines and the pattern space

I have mentioned the pattern space before. Most commands operate on the pattern space, and subsequent commands may act on the results of the last modification. The three previous commands, like the read file command, add the new lines to the output stream, bypassing the pattern space.
Address ranges and the above commands

You may remember that earlier I warned you that some commands can take a range of lines, and others cannot. To be precise, the commands "a," "i," "r," and "q" will not take a range like "1,100" or "/begin/,/end/." The documentation states that the read command can take a range, but I got an error when I tried this. The "c" or change command allows this, and it will let you change several lines into one:

#!/bin/sh
sed '
/begin/,/end/ c\
***DELETED***
'

If you need to do this, you can use the curly braces, as that will let you perform the operation on every line:

#!/bin/sh
# add a blank line after every line
sed '1,$ {
	a\

}'

Multi-Line Patterns

Most UNIX utilities are line oriented. Regular expressions are line oriented. Searching for patterns that covers more than one line is not an easy task. (Hint: It will be very shortly.)

Sed reads in a line of text, performs commands which may modify the line, and outputs modification if desired. The main loop of a sed script looks like this:

    The next line is read from the input file and places it in the pattern space. If the end of file is found, and if there are additional files to read, the current file is closed, the next file is opened, and the first line of the new file is placed into the pattern space.
    The line count is incremented by one. Opening a new file does not reset this number.
    Each sed command is examined. If there is a restriction placed on the command, and the current line in the pattern space meets that restriction, the command is executed. Some commands, like "n" or "d" cause sed to go to the top of the loop. The "q" command causes sed to stop. Otherwise the next command is examined.
    After all of the commands are examined, the pattern space is output unless sed has the optional "-n" argument. 

The restriction before the command determines if the command is executed. If the restriction is a pattern, and the operation is the delete command, then the following will delete all lines that have the pattern:

/PATTERN/ d

If the restriction is a pair of numbers, then the deletion will happen if the line number is equal to the first number or greater than the first number and less than or equal to the last number:

10,20 d

If the restriction is a pair of patterns, there is a variable that is kept for each of these pairs. If the variable is false and the first pattern is found, the variable is made true. If the variable is true, the command is executed. If the variable is true, and the last pattern is on the line, after the command is executed the variable is turned off:

/begin/,/end/ d

Whew! That was a mouthful. If you have read carefully up to here, you should have breezed through this. You may want to refer back, because I covered several subtle points. My choice of words was deliberate. It covers some unusual cases, like:

# what happens if the second number
# is less than the first number?
sed -n '20,1 p' file

and

# generate a 10 line file with line numbers
# and see what happens when two patterns overlap
yes | head -10 | cat -n | \
sed -n -e '/1/,/7/ p' -e '/5/,/9/ p'

Enough mental punishment. Here is another review, this time in a table format. Assume the input file contains the following lines:

AB
CD
EF
GH
IJ

When sed starts up, the first line is placed in the pattern space. The next line is "CD." The operations of the "n," "d," and "p" commands can be summarized as:
Pattern Space 	Next Input 	Command 	Output 	New Pattern Space 	New Text Input
AB 	CD 	n 	<default> 	CD 	EF
AB 	CD 	d 	- 	CD 	EF
AB 	CD 	p 	AB 	CD 	EF

The "n" command may or may not generate output depending upon the existence of the "-n" flag.

That review is a little easier to follow, isn't it? Before I jump into multi-line patterns, I wanted to cover three more commands:
Print line number with =

The "=" command prints the current line number to standard output. One way to find out the line numbers that contain a pattern is to use:

# add line numbers first,
# then use grep, 
# then just print the number
cat -n file | grep 'PATTERN' | awk '{print $1}'

The sed solution is:

sed -n '/PATTERN/ =' file

Earlier I used the following to find the number of lines in a file

#!/bin/sh
lines=$(wc -l file | awk '{print $1}' )

Using the "=" command can simplify this:

#!/bin/sh
lines=$(sed -n '$=' file )

The "=" command only accepts one address, so if you want to print the number for a range of lines, you must use the curly braces:

#!/bin/sh
# Just print the line numbers 
sed -n '/begin/,/end/ {
=
d
}' file

Since the "=" command only prints to standard output, you cannot print the line number on the same line as the pattern. You need to edit multi-line patterns to do this.
Transform with y

If you wanted to change a word from lower case to upper case, you could write 26 character substitutions, converting "a" to "A," etc. Sed has a command that operates like the tr program. It is called the "y" command. For instance, to change the letters "a" through "f" into their upper case form, use:

sed 'y/abcdef/ABCDEF/' file

Here's a sed example that converts all uppercase letters to lowercase letters, like the tr command:

sed 'y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/' <uppercase >lowercase

If you wanted to convert a line that contained a hexadecimal number (e.g. 0x1aff) to upper case (0x1AFF), you could use:

sed '/0x[0-9a-zA-Z]*/ y/abcdef/ABCDEF' file

This works fine if there are only numbers in the file. If you wanted to change the second word in a line to upper case, and you are using classic sed, you are out of luck - unless you use multi-line editing. (Hey - I think there is some sort of theme here!)

However, GNU sed has a uppercase and lowercase extension.
Displaying control characters with a l

The "l" command prints the current pattern space. It is therefore useful in debugging sed scripts. It also converts unprintable characters into printing characters by outputting the value in octal preceded by a "\" character. I found it useful to print out the current pattern space, while probing the subtleties of sed.
Working with Multiple Lines

There are three new commands used in multiple-line patterns: "N," "D," and "P." I will explain their relation to the matching "n," "d," and "p" single-line commands.

The "n" command will print out the current pattern space (unless the "-n" flag is used), empty the current pattern space, and read in the next line of input. The "N" command does not print out the current pattern space and does not empty the pattern space. It reads in the next line, but appends a new line character along with the input line itself to the pattern space.

The "d" command deletes the current pattern space, reads in the next line, puts the new line into the pattern space, and aborts the current command, and starts execution at the first sed command. This is called starting a new "cycle." The "D" command deletes the first portion of the pattern space, up to the new line character, leaving the rest of the pattern alone. Like "d," it stops the current command and starts the command cycle over again. However, it will not print the current pattern space. You must print it yourself, a step earlier. If the "D" command is executed with a group of other commands in a curly brace, commands after the "D" command are ignored. The next group of sed commands is executed, unless the pattern space is emptied. If this happens, the cycle is started from the top and a new line is read.

The "p" command prints the entire pattern space. The "P" command only prints the first part of the pattern space, up to the NEWLINE character. Neither the "p" nor the "P" command changes the patterns space.

Some examples might demonstrate "N" by itself isn't very useful. the filter

sed -e 'N'

doesn't modify the input stream. Instead, it combines the first and second line, then prints them, combines the third and fourth line, and prints them, etc. It does allow you to use a new "anchor" character: "\n." This matches the new line character that separates multiple lines in the pattern space. If you wanted to search for a line that ended with the character "#," and append the next line to it, you could use

#!/bin/sh
sed '
# look for a "#" at the end of the line
/#$/ {
# Found one - now read in the next line
	N
# delete the "#" and the new line character, 
	s/#\n//
}' file

You could search for two lines containing "ONE" and "TWO" and only print out the two consecutive lines:

#!/bin/sh
sed -n '
/ONE/ {
# found "ONE" - read in next line
	N
# look for "TWO" on the second line
# and print if there.
	/\n.*TWO/ p
}' file

The next example would delete everything between "ONE" and "TWO:"

#!/bin/sh
sed '
/ONE/ {
# append a line
	N
# search for TWO on the second line	
	/\n.*TWO/ {
# found it - now edit making one line
		s/ONE.*\n.*TWO/ONE TWO/
	}
}' file

Matching three lines with sed

You can match multiple lines in searches.

Here is a way to look for the string "skip3", and if found, delete that line and the next two lines.

#!/bin/sh
sed '/skip3/ {
           N
           N
           s/skip3\n.*\n.*/# 3 lines deleted/
}'  

Note that it doesn't matter what the next two lines are. If you wanted to match 3 particular lines, it's a little more work.

This script looks for three lines, where the first line contains "one", the second contained "two" and the third contains "three", and if found, replace them with the string "1+2+3":

#!/bin/sh
sed '
/one/ {
      N
	  /two/ {
			N
			/three/ {
			        N
					s/one\ntwo\nthree/1+2+3/
					}
			}
	  }
'

Matching patterns that span multiple lines

You can either search for a particular pattern on two consecutive lines, or you can search for two consecutive words that may be split on a line boundary. The next example will look for two words which are either on the same line or one is on the end of a line and the second is on the beginning of the next line. If found, the first word is deleted:

#!/bin/sh
sed '
/ONE/ {
# append a line
	N
# "ONE TWO" on same line
	s/ONE TWO/TWO/
# "ONE
# TWO" on two consecutive lines
	s/ONE\nTWO/TWO/
}' file

Let's use the
"D" command, and if we find a line containing
"TWO" immediately after a line containing
"ONE," then delete the first line:


#!/bin/sh
sed '
/ONE/ {
# append a line
	N
# if TWO found, delete the first line
	/\n.*TWO/ D
}' file


Click here to get file: sed_delete_line_after_word.sh

If we wanted to print the first line instead of deleting it, and not print every other line, change the "D" to a "P" and add a "-n" as an argument to sed:

#!/bin/sh
sed -n '
# by default - do not print anything
/ONE/ {
# append a line
	N
# if TWO found, print the first line
	/\n.*TWO/ P
}' file


Click here to get file: sed_print_line_after_word.sh

It is very common to combine all three multi-line commands. The typical order is "N," "P" and lastly "D." This one will delete everything between "ONE" and "TWO" if they are on one or two consecutive lines:

#!/bin/sh
sed '
/ONE/ {
# append the next line
	N
# look for "ONE" followed by "TWO"
	/ONE.*TWO/ {
#	delete everything between
		s/ONE.*TWO/ONE TWO/
#	print
		P
#	then delete the first line
		D
	}
}' file


Click here to get file: sed_delete_between_two_words.sh

Earlier I talked about the "=" command, and using it to add line numbers to a file. You can use two invocations of sed to do this (although it is possible to do it with one, but that must wait until next section). The first sed command will output a line number on one line, and then print the line on the next line. The second invocation of sed will merge the two lines together:

#!/bin/sh
sed '=' file | \
sed '{
	N
	s/\n/ /
}'


Click here to get file: sed_merge_two_lines.sh

If you find it necessary, you can break one line into two lines, edit them, and merge them together again. As an example, if you had a file that had a hexadecimal number followed by a word, and you wanted to convert the first word to all upper case, you can use the "y" command, but you must first split the line into two lines, change one of the two, and merge them together. That is, a line containing

0x1fff table2

will be changed into two lines:

0x1fff
table2

and the first line will be converted into upper case. I will use tr to convert the space into a new line, and then use sed to do the rest. The command would be

./sed_split <file

and sed_split would be:

#!/bin/sh
tr ' ' '\012' | 
sed ' {
	y/abcdef/ABCDEF/
	N
	s/\n/ /
}'


Click here to get file: sed_split.sh

It isn't obvious, but sed could be used instead of tr. You can embed a new line in a substitute command, but you must escape it with a backslash. It is unfortunate that you must use "\n" in the left side of a substitute command, and an embedded new line in the right hand side. Heavy sigh. Here is the example:

#!/bin/sh
sed '
s/ /\
/' | \
sed ' {
	y/abcdef/ABCDEF/
	N
	s/\n/ /
}'


Click here to get file: sed_split_merge.sh

Sometimes I add a special character as a marker, and look for that character in the input stream. When found, it indicates the place a blank used to be. A backslash is a good character, except it must be escaped with a backslash, and makes the sed script obscure. Save it for that guy who keeps asking dumb questions. The sed script to change a blank into a "\" following by a new line would be:

#!/bin/sh
sed 's/ /\\\
/' file


Click here to get file: sed_addslash_before_blank.sh

Yeah. That's the ticket. Or use the C shell and really confuse him!

#!/bin/csh -f
sed '\
s/ /\\\\
/' file


Click here to get file: sed_addslash_before_blank.csh

A few more examples of that, and he'll never ask you a question again! I think I'm getting carried away. I'll summarize with a chart that covers the features we've talked about:
Pattern Space 	Next Input 	Command 	Output 	New Pattern Space 	New Text Input
AB 	CD 	n 	<default> 	CD 	EF
AB 	CD 	N 	- 	AB\nCD 	EF
AB 	CD 	d 	- 	- 	EF
AB 	CD 	D 	- 	- 	EF
AB 	CD 	p 	AB 	AB 	CD
AB 	CD 	P 	AB 	AB 	CD
AB\nCD 	EF 	n 	<default> 	EF 	GH
AB\nCD 	EF 	N 	- 	AB\nCD\nEF 	GH
AB\nCD 	EF 	d 	- 	EF 	GH
AB\nCD 	EF 	D 	- 	CD 	EF
AB\nCD 	EF 	p 	AB\nCD 	AB\nCD 	EF
AB\nCD 	EF 	P 	AB 	AB\nCD 	EF
Using newlines in sed scripts

Occasionally one wishes to use a new line character in a sed script. Well, this has some subtle issues here. If one wants to search for a new line, one has to use "\n." Here is an example where you search for a phrase, and delete the new line character after that phrase - joining two lines together.

(echo a;echo x;echo y) | sed '/x$/ {
N
s:x\n:x:
}'

which generates

a
xy

However, if you are inserting a new line, don't use "\n" - instead insert a literal new line character:

(echo a;echo x;echo y) | sed 's:x:X\
:'

generates

a
X

y

The Hold Buffer

So far we have talked about three concepts of sed: (1) The input stream or data before it is modified, (2) the output stream or data after it has been modified, and (3) the pattern space, or buffer containing characters that can be modified and send to the output stream.

There is one more "location" to be covered: the hold buffer or hold space. Think of it as a spare pattern buffer. It can be used to "copy" or "remember" the data in the pattern space for later. There are five commands that use the hold buffer.
Exchange with x

The "x" command eXchanges the pattern space with the hold buffer. By itself, the command isn't useful. Executing the sed command

sed 'x'

as a filter adds a blank line in the front, and deletes the last line. It looks like it didn't change the input stream significantly, but the sed command is modifying every line.

The hold buffer starts out containing a blank line. When the "x" command modifies the first line, line 1 is saved in the hold buffer, and the blank line takes the place of the first line. The second "x" command exchanges the second line with the hold buffer, which contains the first line. Each subsequent line is exchanged with the preceding line. The last line is placed in the hold buffer, and is not exchanged a second time, so it remains in the hold buffer when the program terminates, and never gets printed. This illustrates that care must be taken when storing data in the hold buffer, because it won't be output unless you explicitly request it.
Example of Context Grep

One use of the hold buffer is to remember previous lines. An example of this is a utility that acts like grep as it shows you the lines that match a pattern. In addition, it shows you the line before and after the pattern. That is, if line 8 contains the pattern, this utility would print lines 7, 8 and 9.

One way to do this is to see if the line has the pattern. If it does not have the pattern, put the current line in the hold buffer. If it does, print the line in the hold buffer, then the current line, and then the next line. After each set, three dashes are printed. The script checks for the existence of an argument, and if missing, prints an error. Passing the argument into the sed script is done by turning off the single quote mechanism, inserting the "$1" into the script, and starting up the single quote again:



#!/bin/sh
# grep3 - prints out three lines around pattern
# if there is only one argument, exit

case $# in 
	1);;
	*) echo "Usage: $0 pattern";exit;;
esac;
# I hope the argument doesn't contain a /
# if it does, sed will complain

# use sed -n to disable printing 
# unless we ask for it
sed -n '
'/"$1"/' !{
	#no match - put the current line in the hold buffer
	x
	# delete the old one, which is 
	# now in the pattern buffer
	d
}
'/"$1"/' {
	# a match - get last line
	x
	# print it
	p
	# get the original line back
	x
	# print it
	p
	# get the next line 
	n
	# print it
	p
	# now add three dashes as a marker
	a\
---
	# now put this line into the hold buffer
	x
}'


Click here to get file: grep3.sh

You could use this to show the three lines around a keyword, i.e.:

grep3 vt100 </etc/termcap

Hold with h or H

The "x" command exchanges the hold buffer and the pattern buffer. Both are changed. The "h" command copies the pattern buffer into the hold buffer. The pattern buffer is unchanged. An identical script to the above uses the hold commands:



#!/bin/sh
# grep3 version b - another version using the hold commands
# if there is only one argument, exit

case $# in 
	1);;
	*) echo "Usage: $0 pattern";exit;;
esac;

# again - I hope the argument doesn't contain a /

# use sed -n to disable printing 

sed -n '
'/"$1"/' !{
	# put the non-matching line in the hold buffer
	h
}
'/"$1"/' {
	# found a line that matches
	# append it to the hold buffer
	H
	# the hold buffer contains 2 lines
	# get the next line
	n
	# and add it to the hold buffer
	H
	# now print it back to the pattern space
	x
	# and print it.
	p
	# add the three hyphens as a marker
	a\
---
}'


Click here to get file: grep3a.sh
Keeping more than one line in the hold buffer

The "H" command allows you to combine several lines in the hold buffer. It acts like the "N" command as lines are appended to the buffer, with a "\n" between the lines. You can save several lines in the hold buffer, and print them only if a particular pattern is found later.

As an example, take a file that uses spaces as the first character of a line as a continuation character. The files /etc/termcap, /etc/printcap, makefile and mail messages use spaces or tabs to indicate a continuing of an entry. If you wanted to print the entry before a word, you could use this script. I use a "^I" to indicate an actual tab character:



#!/bin/sh 
# print previous entry
sed -n '
/^[ ^I]/!{
	# line does not start with a space or tab,
	# does it have the pattern we are interested in?
	'/"$1"/' {
		# yes it does. print three dashes
		i\
---
		# get hold buffer, save current line
		x
		# now print what was in the hold buffer
		p
		# get the original line back
		x
	}
	# store it in the hold buffer
	h
}
# what about lines that start
# with a space or tab?
/^[ ^I]/ {
	# append it to the hold buffer
	H
}'


Click here to get file: grep_previous.sh

You can also use the "H" to extend the context grep. In this example, the program prints out the two lines before the pattern, instead of a single line. The method to limit this to two lines is to use the "s" command to keep one new line, and deleting extra lines. I call it grep4:



#!/bin/sh

# grep4: prints out 4 lines around pattern
# if there is only one argument, exit

case $# in 
	1);;
	*) echo "Usage: $0 pattern";exit;;
esac;

sed -n '
'/"$1"/' !{
	# does not match - add this line to the hold space
	H
	# bring it back into the pattern space
	x
	# Two lines would look like .*\n.*
	# Three lines look like .*\n.*\n.*
	# Delete extra lines - keep two
	s/^.*\n\(.*\n.*\)$/\1/
	# now put the two lines (at most) into 
	# the hold buffer again
	x
}
'/"$1"/' {
	# matches - append the current line
	H
	# get the next line
	n
	# append that one also
	H
	# bring it back, but keep the current line in
	# the hold buffer. This is the line after the pattern,
	# and we want to place it in hold in case the next line
	# has the desired pattern
	x
	# print the 4 lines
	p
	# add the mark
	a\
---
}'


Click here to get file: grep4.sh
You can modify this to print any number of lines around a pattern. As you can see, you must remember what is in the hold space, and what is in the pattern space. There are other ways to write the same routine.
Get with g or G

Instead of exchanging the hold space with the pattern space, you can copy the hold space to the pattern space with the "g" command. This deletes the pattern space. If you want to append to the pattern space, use the "G" command. This adds a new line to the pattern space, and copies the hold space after the new line.

Here is another version of the "grep3" command. It works just like the previous one, but is implemented differently. This illustrates that sed has more than one way to solve many problems. What is important is you understand your problem, and document your solution:



#!/bin/sh
# grep3 version c: use 'G'  instead of H

# if there is only one argument, exit

case $# in 
	1);;
	*) echo "Usage: $0 pattern";exit;;
esac;

# again - I hope the argument doesn't contain a /

sed -n '
'/"$1"/' !{
	# put the non-matching line in the hold buffer
	h
}
'/"$1"/' {
	# found a line that matches
	# add the next line to the pattern space
	N
	# exchange the previous line with the 
	# 2 in pattern space
	x
	# now add the two lines back
	G
	# and print it.
	p
	# add the three hyphens as a marker
	a\
---
	# remove first 2 lines
	s/.*\n.*\n\(.*\)$/\1/
	# and place in the hold buffer for next time
	h
}'


Click here to get file: grep3c.sh

The "G" command makes it easy to have two copies of a line. Suppose you wanted to the convert the first hexadecimal number to uppercase, and don't want to use the sed_split.sh
script I described earlier. That script only works when there are exactly 2 words per line. If you wanted to allow more than one word on a line and only convert the first hex word to upperxase, then this is a better approach:

#!/bin/sh
# change the first hex number to upper case format, leave the rest of the line alone
# uses sed twice
# used as a filter
# convert2uc <in >out
sed '
s/ /\
/' | \
sed ' {
	y/abcdef/ABCDEF/
	N
	s/\n/ /
}'


Click here to get file: convert2uc.sh

Here is a solution that does not require two invocations of sed because it uses the "h" and "G" command:

#!/bin/sh
# convert2uc version b
# change the first hex number to upper case format, leave the rest of the line alone
# uses sed once
# used as a filter
# convert2uc <in >out
sed '
{
	# remember the line
	h
	#change the current line to upper case
	y/abcdef/ABCDEF/
	# add the old line back
	G
	# Keep the first word of the first line, 
	# and second word of the second line
	# with one humongous regular expression
	s/^\([^ ]*\) .*\n[^ ]* \(.*\)/\1 \2/
}'


Click here to get file: convert2uc1.sh
Carl Henrik Lunde suggested a way to make this simpler, but not as general purpose. The two previous verion converted works with lines with multiple words. This one only converts two words - the first and the last. However, it deletes any word in-between.

#!/bin/sh
# convert2uc version b
# change the first hex number to upper case format, and keeps the last word
# Note that it deletes the words in-between
# uses sed once
# used as a filter
# convert2uc <in >out
sed '
{
	# remember the line
	h
	#change the current line to upper case
	y/abcdef/ABCDEF/
	# add the old line back
	G
	# Keep the first word of the first line, 
	# and last word of the second line
	# with one humongous regular expression
	s/ .* / / # delete all but the first and last word
}'


Click here to get file: convert2uc2.sh
This example only converts the letters "a" through "f" to upper case. This was chosen to make the script easier to print in these narrow columns. You can easily modify the script to convert all letters to uppercase, or to change the first letter, second word, etc.
Branch (Flow Control)

As you learn about sed you realize that it has its own programming language. It is true that it's a very specialized and simple language. What language would be complete without a method of changing the flow control? There are three commands sed uses for this. You can specify a label with a text string preceded by a colon. The "b" command branches to the label. The label follows the command. If no label is there, branch to the end of the script. The "t" command is used to test conditions. Before I discuss the "t" command, I will show you an example using the "b" command.

This example remembers paragraphs, and if it contains the pattern (specified by an argument), the script prints out the entire paragraph.

#!/bin/sh
sed -n '
# if an empty line, check the paragraph
/^$/ b para
# else add it to the hold buffer
H
# at end of file, check paragraph
$ b para
# now branch to end of script
b
# this is where a paragraph is checked for the pattern
:para
# return the entire paragraph
# into the pattern space
x
# look for the pattern, if there - print
/'"$1"'/ p
'


Click here to get file: grep_paragraph.sh
Testing with t

You can execute a branch if a pattern is found. You may want to execute a branch only if a substitution is made. The command "t label" will branch to the label if the last substitute command modified the pattern space.

One use for this is recursive patterns. Suppose you wanted to remove white space inside parenthesis. These parentheses might be nested. That is, you would want to delete a string that looked like "( ( ( ())) )." The sed expressions

sed 's/([ ^I]*)/g'

would only remove the innermost set. You would have to pipe the data through the script four times to remove each set or parenthesis. You could use the regular expression

sed 's/([ ^I()]*)/g'

but that would delete non-matching sets of parenthesis. The "t" command would solve this:

#!/bin/sh
sed '
:again
	s/([ ^I]*)//
	t again
'

An earlier version had a 'g' after the 's' expression. This is not needed.


Click here to get file: delete_nested_parens.sh
Debugging with l

The 'l' command will print the pattern space in an unambiguous form. Non-printing characters are printed in a C-style escaped format.

This can be useful when debugging a complex multi-line sed script.
An alternate way of adding comments

There is one way to add comments in a sed script if you don't have a version that supports it. Use the "a" command with the line number of zero:

#!/bin/sh
sed '
/begin/ {
0i\
	This is a comment\
	It can cover several lines\
	It will work with any version of sed
}'


Click here to get file: sed_add_comments.sh
The poorly documented ;

There is one more sed command that isn't well documented. It is the ";" command. This can be used to combined several sed commands on one line. Here is the grep4 script I described earlier, but without the comments or error checking and with semicolons between commands:

#!/bin/sh
sed -n '
'/"$1"/' !{;H;x;s/^.*\n\(.*\n.*\)$/\1/;x;}
'/"$1"/' {;H;n;H;x;p;a\
---
}'


Click here to get file: grep4a.sh

Yessireebob! Definitely character building. I think I have made my point. As far as I am concerned, the only time the semicolon is useful is when you want to type the sed script on the command line. If you are going to place it in a script, format it so it is readable. I have mentioned earlier that many versions of sed do not support comments except on the first line. You may want to write your scripts with comments in them, and install them in "binary" form without comments. This should not be difficult. After all, you have become a sed guru by now. I won't even tell you how to write a script to strip out comments. That would be insulting your intelligence. Also - some operating systems do NOT let you use semicolons. So if you see a script with semicolons, and it does not work on a non-Linux system, replace the semicolon with a new line character. (As long as you are not using csh/tcsh, but that's another topic.
Passing regular expressions as arguments

In the earlier scripts, I mentioned that you would have problems if you passed an argument to the script that had a slash in it. In fact, regular expression might cause you problems. A script like the following is asking to be broken some day:

#!/bin/sh
sed 's/'"$1"'//g'

If the argument contains any of these characters in it, you may get a broken script: "/\.*[]^$" For instance, if someone types a "/" then the substitute command will see four delimiters instead of three. You will also get syntax errors if you provide a "]" without a "]". One solution is to have the user put a backslash before any of these characters when they pass it as an argument. However, the user has to know which characters are special.
Here's another solution - add a backslash before each of those special characters in the script.

#!/bin/sh
# put two backslashes before each of these characters: ][^$.*/
# Note that the first ']' doesn't need a backslash
arg=$(echo "$1" | sed 's:[]\[\^\$\.\*\/]:\\\\&:g')
# We need two backslashes because the shell converts each double backslash in quotes to a single backslash
sed 's/'"$arg"'//g'


Click here to get file: sed_with_regular_expressions1.sh
If you were searching for the pattern "^../," the script would convert this into "\^\.\.\/" before passing it to sed.
Inserting binary characters

Dealing with binary characters can be trick, especially when writing scripts for people to read. I can insert a binary character using an editor like EMACS but if I show the binary character, the terminal may change it to show it to you.

The easiest way I have found to do this in a script in a portable fashion is to use the tr(1) command. It understands octal notations, and it can be output into a variable which can be used.

Here's a script that will replace the string "ding" with the ASCII bell character:

#!/bin/sh
BELL=$(echo x | tr 'x' '\007')
sed "s/ding/$BELL/"

Please note that I used double quotes. Since special characters are interpreted, you have to be careful when you use this mechanism.
GNU sed Command Line arguments

One of the conventions UNIX systems have is to use single letters are command line arguments. This makes typing faster, and shorted, which is an advantage if you are in a contest. Normal people often find sed's terseness cryptic. You can improve the readability of sed scripts by using the long word equivalent options. That is, instead of typing

sed -n 20p

You can type the long word version of the -n argument

sed --quiet 20p

Or

sed --silent 20p

The long form of sed's command line arguments always have 2 hyphens before their names. GNU sed has the following long-form command line arguments:

GNU Command Line Arguments

Short Form
	

Long Form

-n
	

--quiet

--silent

-e script
	

--expression=SCRIPT

-f SCRIPTFILE
	

--file=SCRIPTFILE

-i[SUFFIX]
	

--in-place[=SUFFIX]

-l N
	

--line-length=N


	

--posix

-b
	

--binary


	

--follow-symlinks

-r
	

--regular-extended

-s
	

--separate

-u
	

--unbuffered


	

--help


	

--version

Let's define each of these.
The -posix argument

The GNU version of sed has many features that are not available in other versions. When portability is important, test your script with the -posix option. If you had an example that used a feature of GNU sed, such as the 'v' command to test the version number, such as

#this is a sed command file
v 4.0.1
# print the number of lines
$=

And you executed it with the command

sed -nf sedfile --posix <file

then the GNU version of sed program would give you a warning that your sed script is not compatible. It would report:

sed: -e expression #1, char 2: unknown command: `v'

The --version argument

You can determine which version of sed you are using with the GNU sed --version command. This is what it outputs on my computer

# sed --version
GNU sed version 4.2.1
Copyright (C) 2009 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE,
to the extent permitted by law.

GNU sed home page: <https://www.gnu.org/software/sed/>.
General help using GNU software: <https://www.gnu.org/gethelp/>.
E-mail bug reports to: <bug-gnu-utils@gnu.org>.
Be sure to include the word ``sed'' somewhere in the ``Subject:'' field.

The -h Help argument

The -h option will print a summary of the sed commands. The long argument of the command is

sed --help

It provides a nice summary of the command line arguments.
The -l Line Length Argument

I've already described the 'l' command. The default line width for the 'l' command is 70 characters. This default value can be changed by adding the '-l N' option and specifying the maximum line length as the number after the '-l'.

sed -n -l 80 'l' <file

The long form version of the command line is

 sed -n --line-length=80 'l' <file

The -s Separate argument

Normally, when you specify several files on the command line, sed concatenates the files into one stream, and then operates on that single stream. If you had three files, each with 100 lines, then the command

sed -n '1,10 p' file1 file2 file3

would only print the first 10 lines of file file1. The '-s' command tells GNU sed to treat the files are independent files, and to print out the first 10 lines of each file, which is similar to the head command. Here's another example: If you wanted to print the number of lines of each file, you could use 'wc -l' which prints the number of lines, and the filename, for each file, and at the end print the total number of lines. Here is a simple shell script that does something similar, just using sed:

#!/bin/sh
FILES=$*
sed -s -n '$=' $FILES # print the number of lines for each file
sed -n '$=' $FILES # print the total number of lines.

The 'wc -l' command does print out the filenames, unlike the above script. A better emulation of the 'wc -l' command would execute the command in a loop, and print the filenames. Here is a more advanced script that does this, but it doesn't use the '-s' command:

#!/bin/sh
for F in "$@"
do
 NL=$(sed -n '$=' < "$F" ) &&  printf "  %d %s\n" $NL "$F"
done
TOTAL=$(sed -n '$=' "$@")
printf "  %d total\n" $TOTAL

The -i in-place argument

I've already described in Editing multiple files the way I like to do this. For those who want a simpler method, GNU Sed allows you to do this with a command line option - "-i". Let's assume that we are going to make the same simple change - adding a tab before each line. This is a way to do this for all files in a directory with the ".txt" extension in the current directory:

sed -i 's/^/\t/' *.txt

The long argument name version is

sed --in-place 's/^/\t/' *.txt

This version deletes the original file. If you are as cautious as I am, you may prefer to specify an extension, which is used to keep a copy of the original:

sed -i.tmp 's/^/\t/' *.txt

And the long argument name version is

sed --in-place=.tmp 's/^/\t/'  *.txt

In the last two versions, the original version of the "a.txt" file would have the name "a.txt.tmp". You can then delete the original files after you make sure all worked as you expected. Please consider the backup option, and heed my warning. You can easily delete the backed-up original file, as long as the extension is unique.

The GNU version of sed allows you to use "-i" without an argument. The FreeBSD/Mac OS X does not. You must provide an extension for the FreeBSD/Mac OS X version. If you want to do in-place editing without creating a backup, you can use

sed -i ''  's/^/\t/'  *.txt

The --follow-symlinks argument

The in-place editing feature is handy to have. But what happens if the file you are editing is a symbolic link to another file? Let's assume you have a file named "b" in a directory called "tmp", with a symbolic link to this file:

$ ls -l b
lrwxrwxrwx 1 barnett adm 6 Mar 16 16:03 b.txt -> tmp/b.txt

If you executed the above command to do in place editing, there will be a new file called "b.txt" in the current directory, and "tmp/b.txt" will be unchanged. Now you have two versions of the file, one is changed (in the current directory), and one is not (in the "tmp" directory). And where you had a symbolic link, it has been replaced with a modified version of the original file. If you want to edit the real file, and keep the symbolic link in place, use the "--follow-symlinks" command line option:

sed -i --follow-symlinks 's/^/\t/' *.txt

This follows the symlink to the original location, and modifies the file in the "tmp" directory, If you specify an extension, the original file will be found with that extension in the same directory as the real source. Without the --follow-symlinks command line option, the "backup" file "b.tmp" will be in the same directory that held the symbolic link, and will still be a symbolic link - just renamed to give it a new extension.
The -b Binary argument

Unix and Linux systems consider the new line character "\n" to be the end of the line. However, MS-DOS, Windows, and Cygwin systems end each line with "\r\n" - Carriage return and line-feed. If you are using any of these operating systems, the "-b" or --binary" command line option will treat the carriage return/new line combination as the end of the line. Otherwise the carriage return is treated as an unprintable character immediately before the end-of-line. I think. (Note to self - verify this).
The -r Extended Regular Expression argument

When I mention patterns, such as "s/pattern/", the pattern is a regular expression. There are two common classes of regular expressions, the original "basic" expressions, and the "extended" regular expressions. For more on the differences see My tutorial on regular expressions and the the section on extended regular expressions. Because the meaning of certain characters are different between the regular and extended expressions, you need a command line argument to enable sed to use the extension. To enable this extension, use the "-r" command, as mentioned in the example on finding duplicated words on a line

sed -r -n '/\([a-z]+\) \1/p'

or

sed --regular-extended -quiet '/\([a-z]+\) \1/p'

I already mentioned that Mac OS X and FreeBSD uses -E instead of -r.
The -u Unbuffered argument

Normally - Unix and Linux systems apply some intelligence to handling standard output. It's assumed that if you are sending results to a terminal, you want the output as soon as it becomes available. However, if you are sending the output to a file, then it's assumed you want better performance, so it buffers the output until the buffer is full, and then the contents of the buffer is written to the file. Let me elaborate on this. Let's assume for this example you have a very large file, and you are using sed to search for a string, and to print it when it is found:

sed -n '/MATCH/p' <file

Since the output is the terminal, as soon as a match is found, it is printed. However, if sed pipes its output to another program, it will buffer the results. But there are times when you want immediate results. This is especially true when you are dealing with large files, or files that occasionally generate data. To summarize, you have lots of input data, and you want sed to process it, and then send this to another program that processes the results, but you want the results when it happens, and not delayed. Let me make up a simple example. It's contrived, but it does explain how this works. Here's a program called SlowText that prints numbers from 1 to 60, once a second:

#!/bin/sh
for i in $(seq 1 60)
do
  echo $i
  sleep 1
done

Let's use sed to search for lines that have the character '1', and have it send results to awk, which will calculate the square of that number. This would be the admittedly contrived script:

SlowText | sed -n '/1/p' | awk '{print $1*$1}'

This works, but because sed is buffering the results, we have to wait until the buffer fills up, or until the SlowText program exists, before we the results. You can eliminate the buffering, and see the results as soon as SlowText outputs them, by using the "-u" option. With this option, you will see the squares printed as soon as possible:

SlowText | sed -un '/1/p' | awk '{print $1*$1}'

The long form of the argument is "--unbuffered".

Mac OS X and FreeBSD use the argument "-l".

GNU Sed 4.2.2 and later will also be unbuffered while reading files, not just writing them.
The -z Null Data argument

Normally, sed reads a line by reading a string of characters up to the end-of-line character (new line or carriage return). See the -b Binary command line argument The GNU version of sed added a feature in version 4.2.2 to use the "NULL" character instead. This can be useful if you have files that use the NULL as a record separator. Some GNU utilities can generate output that uses a NULL instead a new line, such as "find . -print0" or "grep -lZ". This feature is useful if you are operating on filenames that might contain spaces or binary characters.

For instance, if you wanted to use "find" to search for files and you used the "-print0" option to print a NULL at the end of each filename, you could use sed to delete the directory pathname:

find . -type f -print0  | sed -z 's:^.*/::' | xargs -0 echo 

The above example is not terribly useful as the "xargs" use of echo does not retain the ability to retain spaces as part of the filename. But is does show how to use the sed "-z" command.

GNU grep also has a -Z option to search for strings in files, placing a "NULL" at the end of each filename instead of a new line. And with the -l command, grep will print the filename that contains the string, retaining non-printing and binary characters:

grep -lZ STRING */*/* | sed -z 's:^.*/::' | xargs -0 echo

This feature is very useful when users have the ability to create their own filenames.
FreeBSD Extensions

Apple uses the FreeBSD version of sed for Mac OS X instead of the GNU sed. However, the FreeBSD version has a couple of additions.
The -a or delayed open Argument

Normally, as soon as sed starts up, it opens all files that are referred to by the "w" command. The FreeBSD version of sed has an option to delay this action until the "w" command is executed.
The -I in-place argument

FreeBSD added a "-I" option that is similar to the -i option. The "-i" option treats the editing each file as a separate instance of sed. If the "-I" option is used, then line numbers do not get reset at the beginning of each line, and ranges of addresses continue from one file to the next. That is, if you used the range '/BEGIN/,/END/' and you used the "-I" option, you can have the "BEGIN" in the first file, and "END" in the second file, and the commands executed within the range would span both files. If you used "-i", then the commands would not.

And like the -i option, the extension used to store the backup file must be specified.
-E or Extended Regular Expressions

I mentioned extended regular expressions earlier. FreeBSD (and Mac OS X) uses "-E" to enable this. However, FreeBSD later added the -r command to be compatible with GNU sed.
Using word boundaries

Someone once asked me to help them solve a tricky sed problem involving word boundaries. Let's suppose you have the following input

/usr/bin /usr/local/bin /usr/local /usr/local/project/bin

and you wanted to delete '/usr/local' but leave the other 3 paths alone. You could use the simple (and incorrect) command:

sed 's@/usr/local@@'

which would output

/usr/bin /bin /usr/local /usr/local/project/bin

That is, it would mistakenly change '/usr/local/bin' to '/bin' and not delete '/usr/local' which was the intention of the programmer. The better method is to include spaces around the search:

sed 's@ /usr/local @ @'

However, this won't work if '/usr/local' is at the beginning, or at the end of the line. It also won't work if '/usr/local' is the only path on the line. To handle these edge cases, you can simply describe all of these conditions as separate cases:

#!/bin/sh
sed '
s@ /usr/local @ @g
s@^/usr/local @@
s@ /usr/local$@@
s@^/usr/local$@@
'

This works fine if the string you are searching for is surrounded by a space. But what happens if the string is surrounded by other characters, which may be one of several possible characters? You can always make up your own class of characters that define the 'end of a word'; For instance, if your string consists of alphanumeric characters and the slash, the class of characters can be defined by '[a-zA-Z0-9/]' or the more flexible '[[:alnum:]/]'. We can define the class of characters to be all but these, by using the caret, i.e. '[^[:alnum:]/]'. And unlike the space before, if you are going to use character classes, you may have to remember what these characters are and not delete them. So we can replace the space with '[^[:alnum:]/]' and then change the command to be

#!/bin/sh
sed '
s@\([^[:alnum:]/]\)/usr/local\([^[:alnum:]/]\)@\1\2@g
s@^/usr/local\([^[:alnum:]/]\)@\1@
s@\([^[:alnum:]/]\)/usr/local$@\1@
s@^/usr/local$@@
'

The first version would replace ' /usr/local ' with a single space. This method would replace ':/usr/local:' with '::' - because the redundant delimiters are not deleted. Be sure to fix this if you need to.

This method always works, but it is inelegant and error prone. There are other methods, but they may not be portable. Solaris's version of sed used the special characters ‘\<’ and ‘\>’ as anchors that indicated a word boundary. So you could use

s@\</usr/local\>@@

However, the GNU version of sed says the usage of these special characters are undefined. According to the manual page:

Regex syntax clashes (problems with backslashes)
     `sed' uses the POSIX basic regular expression syntax.  According to
     the standard, the meaning of some escape sequences is undefined in
     this syntax;  notable in the case of `sed' are `\|', `\+', `\?',
     `\`', `\'', `\<', `\>', `\b', `\B', `\w', and `\W'.

     As in all GNU programs that use POSIX basic regular expressions,
     `sed' interprets these escape sequences as special characters.
     So, `x\+' matches one or more occurrences of `x'.  `abc\|def'
     matches either `abc' or `def'.

When in doubt, experiment.
Command Summary

As I promised earlier, here is a table that summarizes the different commands. The second column specifies if the command can have a range or pair of addresses or a single address or pattern. The next four columns specifies which of the four buffers or streams are modified by the command. Some commands only affect the output stream, others only affect the hold buffer. If you remember that the pattern space is output (unless a "-n" was given to sed), this table should help you keep track of the various commands.
Command 	Address or Range 	Modification to
Input Stream 	Modification to
Output Stream 	Modification to
Pattern Space 	Modification to
Hold Buffer
= 	- 	- 	Y 	- 	-
a 	Address 	- 	Y 	- 	-
b 	Range 	- 	- 	- 	-
c 	Range 	- 	Y 	- 	-
d 	Range 	Y 	- 	Y 	-
D 	Range 	Y 	- 	Y 	-
g 	Range 	- 	- 	Y 	-
G 	Range 	- 	- 	Y 	-
h 	Range 	- 	- 	- 	Y
H 	Range 	- 	- 	- 	Y
i 	Address 	- 	Y 	- 	-
l 	Address 	- 	Y 	- 	-
n 	Range 	Y 	* 	- 	-
N 	Range 	Y 	- 	Y 	-
p 	Range 	- 	Y 	- 	-
P 	Range 	- 	Y 	- 	-
q 	Address 	- 	- 	- 	-
r 	Address 	- 	Y 	- 	-
s 	Range 	- 	- 	Y 	-
t 	Range 	- 	- 	- 	-
w 	Range 	- 	Y 	- 	-
x 	Range 	- 	- 	Y 	Y
y 	Range 	- 	- 	Y 	-

The "n" command may or may not generate output, depending on the "-n" option. The "r" command can only have one address, despite the documentation.

Check out my Sed Reference Chart
In Conclusion

This concludes my tutorial on sed. It is possible to find shorter forms of some of my scripts. However, I chose these examples to illustrate some basic constructs. I wanted clarity, not obscurity. I hope you enjoyed it.

More References

This concludes my tutorial on sed. Other of my UNIX shell tutorials can be found here. Other shell tutorials and references can be found at

    FreeBSD Sed Man Page
    Apple/Mac OS X Sed Man Page
    GNU Sed Manual
    GNU Sed 4.2.2 Release Notes
    sed(1) Seventh Edition Unix
    sed(1) manual page from Sun/Oracle
    Heiner's SHELLdorado
    Chris F. A. Johnson's UNIX Shell Page
    The Wikipedia Entry on SED
    SED one-liners

    And don't forget
    The SED FAQ


This document was originally converted from NROFF to TEXT to HTML.
Please forgive errors in the translation.
If you are confused, grab the actual script if possible. No translations occurred in the scripts.
Thanks for the feedback, gang


Thanks to Keelan Evans, Fredrik Nilsson, and Kurt McKee for spotting some typos.
Thanks to Wim Stolker and Jose' Sebrosa as well.
Thanks to Olivier Mengue.
Thanks to Andrew M. Goth.
Thanks to David P. Brown.
Thanks to Axel Schulze for some corrections
Thanks to Martin Jan for the corrections in sed format (grin)
Thanks to David Ward for some corrections
A big thanks for Fazl Rahman for spotting dozens of errors.
Thanks to Carl Henrik Lunde who suggested an improvement to convert2uc1.sh
A big thanks to Bryan Hyun Huh who spotted an error in the table and reference chart
Thanks for input from

	Marten Jan
	Gordon Wilson
	Tom Konantz
	Peter Bratton
	Grant Root
	Keith Briggs
	Zoltan Miklos
	Peggy Russell
	Lorens Kockkum.net
	John Poulin
	Rihards
	Corey Richardson
	Eric Mathison
	Ildar Mulyukov 
	Tom Zhu
	Abhijeet Rastogi @shadyabhi
	Steve LeBlanc   @sleveo
	dontforget yourtowel @whatissixbynine
	Yiming
	Fei Wang
	Kenneth R. Beesley
	Duncan Sung W. Kim @DuncanSungWKim
	Juan Eugenio Abadie
	Zander Hill @_ZPH
    Cornelius Roemer @CorneliusRoemer 
    Rob Smith
    Peter Moore

This document was translated by troff2html v0.21 on September 22, 2001 and then manually edited to make it compliant with: Valid HTML 4.01!


SA+VEgdiTto lockscreen kbdin pis0857polsiren


<<< Previous 	Home 	Next >>>
The Open Group Base Specifications Issue 7, 2018 edition
IEEE Std 1003.1-2017 (Revision of IEEE Std 1003.1-2008)
Copyright © 2001-2018 IEEE and The Open Group
NAME

    sed - stream editor

SYNOPSIS

    sed [-n] script [file...]

    sed [-n] -e script [-e script]... [-f script_file]... [file...]

    sed [-n] [-e script]... -f script_file [-f script_file]... [file...]

DESCRIPTION

    The sed utility is a stream editor that shall read one or more text files, make editing changes according to a script of editing commands, and write the results to standard output. The script shall be obtained from either the script operand string or a combination of the option-arguments from the -e script and -f script_file options.

OPTIONS

    The sed utility shall conform to XBD Utility Syntax Guidelines , except that the order of presentation of the -e and -f options is significant.

    The following options shall be supported:

    -e  script
        Add the editing commands specified by the script option-argument to the end of the script of editing commands.
    -f  script_file
        Add the editing commands in the file script_file to the end of the script of editing commands.
    -n
        Suppress the default output (in which each line, after it is examined for editing, is written to standard output). Only lines explicitly selected for output are written.

    If any -e or -f options are specified, the script of editing commands shall initially be empty. The commands specified by each -e or -f option shall be added to the script in the order specified. When each addition is made, if the previous addition (if any) was from a -e option, a <newline> shall be inserted before the new addition. The resulting script shall have the same properties as the script operand, described in the OPERANDS section.

OPERANDS

    The following operands shall be supported:

    file
        A pathname of a file whose contents are read and edited. If multiple file operands are specified, the named files shall be read in the order specified and the concatenation shall be edited. If no file operands are specified, the standard input shall be used.
    script
        A string to be used as the script of editing commands. The application shall not present a script that violates the restrictions of a text file except that the final character need not be a <newline>.

STDIN

    The standard input shall be used if no file operands are specified, and shall be used if a file operand is '-' and the implementation treats the '-' as meaning standard input. Otherwise, the standard input shall not be used. See the INPUT FILES section.

INPUT FILES

    The input files shall be text files. The script_files named by the -f option shall consist of editing commands.

ENVIRONMENT VARIABLES

    The following environment variables shall affect the execution of sed:

    LANG
        Provide a default value for the internationalization variables that are unset or null. (See XBD Internationalization Variables for the precedence of internationalization variables used to determine the values of locale categories.)
    LC_ALL
        If set to a non-empty string value, override the values of all the other internationalization variables.
    LC_COLLATE
        Determine the locale for the behavior of ranges, equivalence classes, and multi-character collating elements within regular expressions.
    LC_CTYPE
        Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as opposed to multi-byte characters in arguments and input files), and the behavior of character classes within regular expressions.
    LC_MESSAGES
        Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
    NLSPATH
        [XSI] [Option Start] Determine the location of message catalogs for the processing of LC_MESSAGES. [Option End]

ASYNCHRONOUS EVENTS

    Default.

STDOUT

    The input files shall be written to standard output, with the editing commands specified in the script applied. If the -n option is specified, only those input lines selected by the script shall be written to standard output.

STDERR

    The standard error shall be used only for diagnostic and warning messages.

OUTPUT FILES

    The output files shall be text files whose formats are dependent on the editing commands given.

EXTENDED DESCRIPTION

    The script shall consist of editing commands of the following form:

    [address[,address]]function

    where function represents a single-character command verb from the list in Editing Commands in sed, followed by any applicable arguments.

    The command can be preceded by <blank> characters and/or <semicolon> characters. The function can be preceded by <blank> characters. These optional characters shall have no effect.

    In default operation, sed cyclically shall append a line of input, less its terminating <newline> character, into the pattern space. Reading from input shall be skipped if a <newline> was in the pattern space prior to a D command ending the previous cycle. The sed utility shall then apply in sequence all commands whose addresses select that pattern space, until a command starts the next cycle or quits. If no commands explicitly started a new cycle, then at the end of the script the pattern space shall be copied to standard output (except when -n is specified) and the pattern space shall be deleted. Whenever the pattern space is written to standard output or a named file, sed shall immediately follow it with a <newline>.

    Some of the editing commands use a hold space to save all or part of the pattern space for subsequent retrieval. The pattern and hold spaces shall each be able to hold at least 8192 bytes.
    Addresses in sed

    An address is either a decimal number that counts input lines cumulatively across files, a '$' character that addresses the last line of input, or a context address (which consists of a BRE, as described in Regular Expressions in sed, preceded and followed by a delimiter, usually a <slash>).

    An editing command with no addresses shall select every pattern space.

    An editing command with one address shall select each pattern space that matches the address.

    An editing command with two addresses shall select the inclusive range from the first pattern space that matches the first address through the next pattern space that matches the second. (If the second address is a number less than or equal to the line number first selected, only one line shall be selected.) Starting at the first line following the selected range, sed shall look again for the first address. Thereafter, the process shall be repeated. Omitting either or both of the address components in the following form produces undefined results:

    [address[,address]]

    Regular Expressions in sed

    The sed utility shall support the BREs described in XBD Basic Regular Expressions, with the following additions:

        In a context address, the construction "\cBREc", where c is any character other than <backslash> or <newline>, shall be identical to "/BRE/". If the character designated by c appears following a <backslash>, then it shall be considered to be that literal character, which shall not terminate the BRE. For example, in the context address "\xabc\xdefx", the second x stands for itself, so that the BRE is "abcxdef".

        The escape sequence '\n' shall match a <newline> embedded in the pattern space. A literal <newline> shall not be used in the BRE of a context address or in the substitute function.

        If an RE is empty (that is, no pattern is specified) sed shall behave as if the last RE used in the last command applied (either as an address or as part of a substitute command) was specified.

    Editing Commands in sed

    In the following list of editing commands, the maximum number of permissible addresses for each function is indicated by [ 0addr], [ 1addr], or [ 2addr], representing zero, one, or two addresses.

    The argument text shall consist of one or more lines. Each embedded <newline> in the text shall be preceded by a <backslash>. Other <backslash> characters in text shall be removed, and the following character shall be treated literally.

    The r and w command verbs, and the w flag to the s command, take an rfile (or wfile) parameter, separated from the command verb letter or flag by one or more <blank> characters; implementations may allow zero separation as an extension.

    The argument rfile or the argument wfile shall terminate the editing command. Each wfile shall be created before processing begins. Implementations shall support at least ten wfile arguments in the script; the actual number (greater than or equal to 10) that is supported by the implementation is unspecified. The use of the wfile parameter shall cause that file to be initially created, if it does not exist, or shall replace the contents of an existing file.

    The b, r, s, t, w, y, and : command verbs shall accept additional arguments. The following synopses indicate which arguments shall be separated from the command verbs by a single <space>.

    The a and r commands schedule text for later output. The text specified for the a command, and the contents of the file specified for the r command, shall be written to standard output just before the next attempt to fetch a line of input when executing the N or n commands, or when reaching the end of the script. If written when reaching the end of the script, and the -n option was not specified, the text shall be written after copying the pattern space to standard output. The contents of the file specified for the r command shall be as of the time the output is written, not the time the r command is applied. The text shall be output in the order in which the a and r commands were applied to the input.

    Editing commands other than {...}, a, b, c, i, r, t, w, :, and # can be followed by a <semicolon>, optional <blank> characters, and another editing command. However, when an s editing command is used with the w flag, following it with another command in this manner produces undefined results.

    A function can be preceded by a '!' character, in which case the function shall be applied if the addresses do not select the pattern space. Zero or more <blank> characters shall be accepted before the '!' character. It is unspecified whether <blank> characters can follow the '!' character, and conforming applications shall not follow the '!' character with <blank> characters.

    If a label argument (to a b, t, or : command) contains characters outside of the portable filename character set, or if a label is longer than 8 bytes, the behavior is unspecified. The implementation shall support label arguments recognized as unique up to at least 8 bytes; the actual length (greater than or equal to 8) supported by the implementation is unspecified. It is unspecified whether exceeding the maximum supported label length causes an error or a silent truncation.

    [2addr] {editing command
    editing command
    ...
    }
        Execute a list of sed editing commands only when the pattern space is selected. The list of sed editing commands shall be surrounded by braces. The braces can be preceded or followed by <blank> characters. The <right-brace> shall be preceded by a <newline> or <semicolon> (before any optional <blank> characters preceding the <right-brace>).

        Each command in the list of commands shall be terminated by a <newline> character, or by a <semicolon> character if permitted when the command is used outside the braces. The editing commands can be preceded by <blank> characters, but shall not be followed by <blank> characters.
    [1addr]a\
    text
        Write text to standard output as described previously.
    [2addr]b [label]
        Branch to the : command verb bearing the label argument. If label is not specified, branch to the end of the script.
    [2addr]c\
    text
        Delete the pattern space. With a 0 or 1 address or at the end of a 2-address range, place text on the output and start the next cycle.
    [2addr]d
        Delete the pattern space and start the next cycle.
    [2addr]D
        If the pattern space contains no <newline>, delete the pattern space and start a normal new cycle as if the d command was issued. Otherwise, delete the initial segment of the pattern space through the first <newline>, and start the next cycle with the resultant pattern space and without reading any new input.
    [2addr]g
        Replace the contents of the pattern space by the contents of the hold space.
    [2addr]G
        Append to the pattern space a <newline> followed by the contents of the hold space.
    [2addr]h
        Replace the contents of the hold space with the contents of the pattern space.
    [2addr]H
        Append to the hold space a <newline> followed by the contents of the pattern space.
    [1addr]i\
    text
        Write text to standard output.
    [2addr]l
        (The letter ell.) Write the pattern space to standard output in a visually unambiguous form. The characters listed in XBD Escape Sequences and Associated Actions ( '\\', '\a', '\b', '\f', '\r', '\t', '\v' ) shall be written as the corresponding escape sequence; the '\n' in that table is not applicable. Non-printable characters not in that table shall be written as one three-digit octal number (with a preceding <backslash>) for each byte in the character (most significant byte first).

        Long lines shall be folded, with the point of folding indicated by writing a <backslash> followed by a <newline>; the length at which folding occurs is unspecified, but should be appropriate for the output device. The end of each line shall be marked with a '$'.
    [2addr]n
        Write the pattern space to standard output if the default output has not been suppressed, and replace the pattern space with the next line of input, less its terminating <newline>.

        If no next line of input is available, the n command verb shall branch to the end of the script and quit without starting a new cycle.
    [2addr]N
        Append the next line of input, less its terminating <newline>, to the pattern space, using an embedded <newline> to separate the appended material from the original material. Note that the current line number changes.

        If no next line of input is available, the N command verb shall branch to the end of the script and quit without starting a new cycle or copying the pattern space to standard output.
    [2addr]p
        Write the pattern space to standard output.
    [2addr]P
        Write the pattern space, up to the first <newline>, to standard output.
    [1addr]q
        Branch to the end of the script and quit without starting a new cycle.
    [1addr]r  rfile
        Copy the contents of rfile to standard output as described previously. If rfile does not exist or cannot be read, it shall be treated as if it were an empty file, causing no error condition.
    [2addr]s/BRE/replacement/flags
        Substitute the replacement string for instances of the BRE in the pattern space. Any character other than <backslash> or <newline> can be used instead of a <slash> to delimit the BRE and the replacement. Within the BRE and the replacement, the BRE delimiter itself can be used as a literal character if it is preceded by a <backslash>.

        The replacement string shall be scanned from beginning to end. An <ampersand> ( '&' ) appearing in the replacement shall be replaced by the string matching the BRE. The special meaning of '&' in this context can be suppressed by preceding it by a <backslash>. The characters "\n", where n is a digit, shall be replaced by the text matched by the corresponding back-reference expression. If the corresponding back-reference expression does not match, then the characters "\n" shall be replaced by the empty string. The special meaning of "\n" where n is a digit in this context, can be suppressed by preceding it by a <backslash>. For each other <backslash> encountered, the following character shall lose its special meaning (if any).

        A line can be split by substituting a <newline> into it. The application shall escape the <newline> in the replacement by preceding it by a <backslash>.

        The meaning of an unescaped <backslash> immediately followed by any character other than '&', <backslash>, a digit, <newline>, or the delimiter character used for this command, is unspecified.

        A substitution shall be considered to have been performed even if the replacement string is identical to the string that it replaces. Any <backslash> used to alter the default meaning of a subsequent character shall be discarded from the BRE or the replacement before evaluating the BRE or using the replacement.

        The value of flags shall be zero or more of:

        n
            Substitute for the nth occurrence only of the BRE found within the pattern space.
        g
            Globally substitute for all non-overlapping instances of the BRE rather than just the first one. If both g and n are specified, the results are unspecified.
        p
            Write the pattern space to standard output if a replacement was made.
        w  wfile
            Write. Append the pattern space to wfile if a replacement was made. A conforming application shall precede the wfile argument with one or more <blank> characters. If the w flag is not the last flag value given in a concatenation of multiple flag values, the results are undefined.

    [2addr]t [label]
        Test. Branch to the : command verb bearing the label if any substitutions have been made since the most recent reading of an input line or execution of a t. If label is not specified, branch to the end of the script.
    [2addr]w  wfile
        Append (write) the pattern space to wfile.
    [2addr]x
        Exchange the contents of the pattern and hold spaces.
    [2addr]y/string1/string2/
        Replace all occurrences of characters in string1 with the corresponding characters in string2. If a <backslash> followed by an 'n' appear in string1 or string2, the two characters shall be handled as a single <newline>. If the number of characters in string1 and string2 are not equal, or if any of the characters in string1 appear more than once, the results are undefined. Any character other than <backslash> or <newline> can be used instead of <slash> to delimit the strings. If the delimiter is not 'n', within string1 and string2, the delimiter itself can be used as a literal character if it is preceded by a <backslash>. If a <backslash> character is immediately followed by a <backslash> character in string1 or string2, the two <backslash> characters shall be counted as a single literal <backslash> character. The meaning of a <backslash> followed by any character that is not 'n', a <backslash>, or the delimiter character is undefined.
    [0addr]:label
        Do nothing. This command bears a label to which the b and t commands branch.
    [1addr]=
        Write the following to standard output:

        "%d\n", <current line number>

    [0addr]
        Ignore this empty command.
    [0addr]#
        Ignore the '#' and the remainder of the line (treat them as a comment), with the single exception that if the first two characters in the script are "#n", the default output shall be suppressed; this shall be the equivalent of specifying -n on the command line.

EXIT STATUS

    The following exit values shall be returned:

     0
        Successful completion.
    >0
        An error occurred.

CONSEQUENCES OF ERRORS

    Default.

The following sections are informative.
APPLICATION USAGE

    Regular expressions match entire strings, not just individual lines, but a <newline> is matched by '\n' in a sed RE; a <newline> is not allowed by the general definition of regular expression in POSIX.1-2017. Also note that '\n' cannot be used to match a <newline> at the end of an arbitrary input line; <newline> characters appear in the pattern space as a result of the N editing command.

    When using sed to process pathnames, it is recommended that LC_ALL, or at least LC_CTYPE and LC_COLLATE, are set to POSIX or C in the environment, since pathnames can contain byte sequences that do not form valid characters in some locales, in which case the utility's behavior would be undefined. In the POSIX locale each byte is a valid single-byte character, and therefore this problem is avoided.

EXAMPLES

    This sed script simulates the BSD cat -s command, squeezing excess empty lines from standard input.

    sed -n '
    # Write non-empty lines.
    /./ {
        p
        d
        }
    # Write a single empty line, then look for more empty lines.
    /^$/    p
    # Get next line, discard the held <newline> (empty line),
    # and look for more empty lines.
    :Empty
    /^$/    {
        N
        s/.//
        b Empty
        }
    # Write the non-empty line before going back to search
    # for the first in a set of empty lines.
        p
    '

    The following sed command is a much simpler method of squeezing empty lines, although it is not quite the same as cat -s since it removes any initial empty lines:

    sed -n '/./,/^$/p'

RATIONALE

    This volume of POSIX.1-2017 requires implementations to support at least ten distinct wfiles, matching historical practice on many implementations. Implementations are encouraged to support more, but conforming applications should not exceed this limit.

    The exit status codes specified here are different from those in System V. System V returns 2 for garbled sed commands, but returns zero with its usage message or if the input file could not be opened. The standard developers considered this to be a bug.

    The manner in which the l command writes non-printable characters was changed to avoid the historical backspace-overstrike method, and other requirements to achieve unambiguous output were added. See the RATIONALE for ed for details of the format chosen, which is the same as that chosen for sed.

    This volume of POSIX.1-2017 requires implementations to provide pattern and hold spaces of at least 8192 bytes, larger than the 4000 bytes spaces used by some historical implementations, but less than the 20480 bytes limit used in an early proposal. Implementations are encouraged to allocate dynamically larger pattern and hold spaces as needed.

    The requirements for acceptance of <blank> and <space> characters in command lines has been made more explicit than in early proposals to describe clearly the historical practice and to remove confusion about the phrase "protect initial blanks [sic] and tabs from the stripping that is done on every script line" that appears in much of the historical documentation of the sed utility description of text. (Not all implementations are known to have stripped <blank> characters from text lines, although they all have allowed leading <blank> characters preceding the address on a command line.)

    The treatment of '#' comments differs from the SVID which only allows a comment as the first line of the script, but matches BSD-derived implementations. The comment character is treated as a command, and it has the same properties in terms of being accepted with leading <blank> characters; the BSD implementation has historically supported this.

    Early proposals required that a script_file have at least one non-comment line. Some historical implementations have behaved in unexpected ways if this were not the case. The standard developers considered that this was incorrect behavior and that application developers should not have to avoid this feature. A correct implementation of this volume of POSIX.1-2017 shall permit script_files that consist only of comment lines.

    Early proposals indicated that if -e and -f options were intermixed, all -e options were processed before any -f options. This has been changed to process them in the order presented because it matches historical practice and is more intuitive.

    The treatment of the p flag to the s command differs between System V and BSD-based systems when the default output is suppressed. In the two examples:

    echo a | sed    's/a/A/p'
    echo a | sed -n 's/a/A/p'

    this volume of POSIX.1-2017, BSD, System V documentation, and the SVID indicate that the first example should write two lines with A, whereas the second should write one. Some System V systems write the A only once in both examples because the p flag is ignored if the -n option is not specified.

    This is a case of a diametrical difference between systems that could not be reconciled through the compromise of declaring the behavior to be unspecified. The SVID/BSD/System V documentation behavior was adopted for this volume of POSIX.1-2017 because:

        No known documentation for any historic system describes the interaction between the p flag and the -n option.

        The selected behavior is more correct as there is no technical justification for any interaction between the p flag and the -n option. A relationship between -n and the p flag might imply that they are only used together, but this ignores valid scripts that interrupt the cyclical nature of the processing through the use of the D, d, q, or branching commands. Such scripts rely on the p suffix to write the pattern space because they do not make use of the default output at the "bottom" of the script.

        Because the -n option makes the p flag unnecessary, any interaction would only be useful if sed scripts were written to run both with and without the -n option. This is believed to be unlikely. It is even more unlikely that programmers have coded the p flag expecting it to be unnecessary. Because the interaction was not documented, the likelihood of a programmer discovering the interaction and depending on it is further decreased.

        Finally, scripts that break under the specified behavior produce too much output instead of too little, which is easier to diagnose and correct.

    The form of the substitute command that uses the n suffix was limited to the first 512 matches in an early proposal. This limit has been removed because there is no reason an editor processing lines of {LINE_MAX} length should have this restriction. The command s/a/A/2047 should be able to substitute the 2047th occurrence of a on a line.

    The b, t, and : commands are documented to ignore leading white space, but no mention is made of trailing white space. Historical implementations of sed assigned different locations to the labels 'x' and "x ". This is not useful, and leads to subtle programming errors, but it is historical practice, and changing it could theoretically break working scripts. Implementors are encouraged to provide warning messages about labels that are never referenced by a b or t command, jumps to labels that do not exist, and label arguments that are subject to truncation.

    Earlier versions of this standard allowed for implementations with bytes other than eight bits, but this has been modified in this version.

FUTURE DIRECTIONS

    None.

SEE ALSO

    awk, ed, grep

    XBD Escape Sequences and Associated Actions, Environment Variables, Basic Regular Expressions, Utility Syntax Guidelines

CHANGE HISTORY

    First released in Issue 2.

Issue 5

    The FUTURE DIRECTIONS section is added.

Issue 6

    The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:

        Implementations are required to support at least ten wfile arguments in an editing command.

    The EXTENDED DESCRIPTION is changed to align with the IEEE P1003.2b draft standard.

    IEEE PASC Interpretation 1003.2 #190 is applied.

    IEEE PASC Interpretation 1003.2 #203 is applied, clarifying the meaning of the <backslash>-escape sequences in a replacement string for a BRE.

    IEEE Std 1003.1-2001/Cor 2-2004, item XCU/TC2/D6/28 is applied, removing text describing behavior on systems with bytes consisting of more than eight bits.

    IEEE Std 1003.1-2001/Cor 2-2004, item XCU/TC2/D6/29 is applied, making an editorial correction within the Editing Commands in sed section.

Issue 7

    Austin Group Interpretations 1003.1-2001 #006, #036, and #092 are applied.

    SD5-XCU-ERN-97 and SD5-XCU-ERN-123 are applied, updating the SYNOPSIS.

    A second example is added.

    POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0133 [262], XCU/TC1-2008/0134 [282,431], XCU/TC1-2008/0135 [269], and XCU/TC1-2008/0136 [282,431] are applied.

    POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0166 [945], XCU/TC2-2008/0167 [944], XCU/TC2-2008/0168 [945], XCU/TC2-2008/0169 [944], XCU/TC2-2008/0170 [945], XCU/TC2-2008/0171 [533], XCU/TC2-2008/0172 [663], XCU/TC2-2008/0173 [945], and XCU/TC2-2008/0174 [944] are applied.

End of informative text.

 
return to top of page
UNIX ® is a registered Trademark of The Open Group.
POSIX ™ is a Trademark of The IEEE.
Copyright © 2001-2018 IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT ]
<<< Previous 	Home 	Next >>>



A+VgeDItto lockscreen kbdin pis0853polsiren


sed, a stream editor
Table of Contents

    1 Introduction
    2 Running sed
        2.1 Overview
        2.2 Command-Line Options
        2.3 Exit status
    3 sed scripts
        3.1 sed script overview
        3.2 sed commands summary
        3.3 The s Command
        3.4 Often-Used Commands
        3.5 Less Frequently-Used Commands
        3.6 Commands for sed gurus
        3.7 Commands Specific to GNU sed
        3.8 Multiple commands syntax
            3.8.1 Commands Requiring a newline
    4 Addresses: selecting lines
        4.1 Addresses overview
        4.2 Selecting lines by numbers
        4.3 selecting lines by text matching
        4.4 Range Addresses
    5 Regular Expressions: selecting text
        5.1 Overview of regular expression in sed
        5.2 Basic (BRE) and extended (ERE) regular expression
        5.3 Overview of basic regular expression syntax
        5.4 Overview of extended regular expression syntax
        5.5 Character Classes and Bracket Expressions
        5.6 regular expression extensions
        5.7 Back-references and Subexpressions
        5.8 Escape Sequences - specifying special characters
            5.8.1 Escaping Precedence
        5.9 Multibyte characters and Locale Considerations
            5.9.1 Invalid multibyte characters
            5.9.2 Upper/Lower case conversion
            5.9.3 Multibyte regexp character classes
    6 Advanced sed: cycles and buffers
        6.1 How sed Works
        6.2 Hold and Pattern Buffers
        6.3 Multiline techniques - using D,G,H,N,P to process multiple lines
        6.4 Branching and Flow Control
            6.4.1 Branching and Cycles
            6.4.2 Branching example: joining lines
    7 Some Sample Scripts
        7.1 Joining lines
        7.2 Centering Lines
        7.3 Increment a Number
        7.4 Rename Files to Lower Case
        7.5 Print bash Environment
        7.6 Reverse Characters of Lines
        7.7 Text search across multiple lines
        7.8 Line length adjustment
        7.9 Reverse Lines of Files
        7.10 Numbering Lines
        7.11 Numbering Non-blank Lines
        7.12 Counting Characters
        7.13 Counting Words
        7.14 Counting Lines
        7.15 Printing the First Lines
        7.16 Printing the Last Lines
        7.17 Make Duplicate Lines Unique
        7.18 Print Duplicated Lines of Input
        7.19 Remove All Duplicated Lines
        7.20 Squeezing Blank Lines
    8 GNU sed’s Limitations and Non-limitations
    9 Other Resources for Learning About sed
    10 Reporting Bugs
    Appendix A GNU Free Documentation License
    Concept Index
    Command and Option Index

Next: Introduction, Up: (dir)   [Contents][Index]
GNU sed

This file documents version 4.8 of GNU sed, a stream editor.

Copyright © 1998–2020 Free Software Foundation, Inc.

    Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in the section entitled “GNU Free Documentation License”. 

• Introduction:	  	Introduction
• Invoking sed:	  	Invocation
• sed scripts:	  	sed scripts
• sed addresses:	  	Addresses: selecting lines
• sed regular expressions:	  	Regular expressions: selecting text
• advanced sed:	  	Advanced sed: cycles and buffers
• Examples:	  	Some sample scripts
• Limitations:	  	Limitations and (non-)limitations of GNU sed
• Other Resources:	  	Other resources for learning about sed
• Reporting Bugs:	  	Reporting bugs
• GNU Free Documentation License:	  	Copying and sharing this manual
• Concept Index:	  	A menu with all the topics in this manual.
• Command and Option Index:	  	A menu with all sed commands and command-line options.

Next: Invoking sed, Previous: Top, Up: Top   [Contents][Index]
1 Introduction

sed is a stream editor. A stream editor is used to perform basic text transformations on an input stream (a file or input from a pipeline). While in some ways similar to an editor which permits scripted edits (such as ed), sed works by making only one pass over the input(s), and is consequently more efficient. But it is sed’s ability to filter text in a pipeline which particularly distinguishes it from other types of editors.

Next: sed scripts, Previous: Introduction, Up: Top   [Contents][Index]
2 Running sed

This chapter covers how to run sed. Details of sed scripts and individual sed commands are discussed in the next chapter.
• Overview:	  	
• Command-Line Options:	  	
• Exit status:	  	

Next: Command-Line Options, Up: Invoking sed   [Contents][Index]
2.1 Overview

Normally sed is invoked like this:

sed SCRIPT INPUTFILE...

For example, to replace all occurrences of ‘hello’ to ‘world’ in the file input.txt:

sed 's/hello/world/' input.txt > output.txt

If you do not specify INPUTFILE, or if INPUTFILE is -, sed filters the contents of the standard input. The following commands are equivalent:

sed 's/hello/world/' input.txt > output.txt
sed 's/hello/world/' < input.txt > output.txt
cat input.txt | sed 's/hello/world/' - > output.txt

sed writes output to standard output. Use -i to edit files in-place instead of printing to standard output. See also the W and s///w commands for writing output to other files. The following command modifies file.txt and does not produce any output:

sed -i 's/hello/world/' file.txt

By default sed prints all processed input (except input that has been modified/deleted by commands such as d). Use -n to suppress output, and the p command to print specific lines. The following command prints only line 45 of the input file:

sed -n '45p' file.txt

sed treats multiple input files as one long stream. The following example prints the first line of the first file (one.txt) and the last line of the last file (three.txt). Use -s to reverse this behavior.

sed -n  '1p ; $p' one.txt two.txt three.txt

Without -e or -f options, sed uses the first non-option parameter as the script, and the following non-option parameters as input files. If -e or -f options are used to specify a script, all non-option parameters are taken as input files. Options -e and -f can be combined, and can appear multiple times (in which case the final effective script will be concatenation of all the individual scripts).

The following examples are equivalent:

sed 's/hello/world/' input.txt > output.txt

sed -e 's/hello/world/' input.txt > output.txt
sed --expression='s/hello/world/' input.txt > output.txt

echo 's/hello/world/' > myscript.sed
sed -f myscript.sed input.txt > output.txt
sed --file=myscript.sed input.txt > output.txt

Next: Exit status, Previous: Overview, Up: Invoking sed   [Contents][Index]
2.2 Command-Line Options

The full format for invoking sed is:

sed OPTIONS... [SCRIPT] [INPUTFILE...]

sed may be invoked with the following command-line options:

--version

    Print out the version of sed that is being run and a copyright notice, then exit.
--help

    Print a usage message briefly summarizing these command-line options and the bug-reporting address, then exit.
-n
--quiet
--silent

    By default, sed prints out the pattern space at the end of each cycle through the script (see How sed works). These options disable this automatic printing, and sed only produces output when explicitly told to via the p command.
--debug

    Print the input sed program in canonical form, and annotate program execution.

    $ echo 1 | sed '\%1%s21232'
    3

    $ echo 1 | sed --debug '\%1%s21232'
    SED PROGRAM:
      /1/ s/1/3/
    INPUT:   'STDIN' line 1
    PATTERN: 1
    COMMAND: /1/ s/1/3/
    PATTERN: 3
    END-OF-CYCLE:
    3

-e script
--expression=script

    Add the commands in script to the set of commands to be run while processing the input.
-f script-file
--file=script-file

    Add the commands contained in the file script-file to the set of commands to be run while processing the input.
-i[SUFFIX]
--in-place[=SUFFIX]

    This option specifies that files are to be edited in-place. GNU sed does this by creating a temporary file and sending output to this file rather than to the standard output.1.

    This option implies -s.

    When the end of the file is reached, the temporary file is renamed to the output file’s original name. The extension, if supplied, is used to modify the name of the old file before renaming the temporary file, thereby making a backup copy2).

    This rule is followed: if the extension doesn’t contain a *, then it is appended to the end of the current filename as a suffix; if the extension does contain one or more * characters, then each asterisk is replaced with the current filename. This allows you to add a prefix to the backup file, instead of (or in addition to) a suffix, or even to place backup copies of the original files into another directory (provided the directory already exists).

    If no extension is supplied, the original file is overwritten without making a backup.

    Because -i takes an optional argument, it should not be followed by other short options:

    sed -Ei '...' FILE

        Same as -E -i with no backup suffix - FILE will be edited in-place without creating a backup.
    sed -iE '...' FILE

        This is equivalent to --in-place=E, creating FILEE as backup of FILE 

    Be cautious of using -n with -i: the former disables automatic printing of lines and the latter changes the file in-place without a backup. Used carelessly (and without an explicit p command), the output file will be empty:

    # WRONG USAGE: 'FILE' will be truncated.
    sed -ni 's/foo/bar/' FILE

-l N
--line-length=N

    Specify the default line-wrap length for the l command. A length of 0 (zero) means to never wrap long lines. If not specified, it is taken to be 70.
--posix

    GNU sed includes several extensions to POSIX sed. In order to simplify writing portable scripts, this option disables all the extensions that this manual documents, including additional commands. Most of the extensions accept sed programs that are outside the syntax mandated by POSIX, but some of them (such as the behavior of the N command described in Reporting Bugs) actually violate the standard. If you want to disable only the latter kind of extension, you can set the POSIXLY_CORRECT variable to a non-empty value.
-b
--binary

    This option is available on every platform, but is only effective where the operating system makes a distinction between text files and binary files. When such a distinction is made—as is the case for MS-DOS, Windows, Cygwin—text files are composed of lines separated by a carriage return and a line feed character, and sed does not see the ending CR. When this option is specified, sed will open input files in binary mode, thus not requesting this special processing and considering lines to end at a line feed.
--follow-symlinks

    This option is available only on platforms that support symbolic links and has an effect only if option -i is specified. In this case, if the file that is specified on the command line is a symbolic link, sed will follow the link and edit the ultimate destination of the link. The default behavior is to break the symbolic link, so that the link destination will not be modified.
-E
-r
--regexp-extended

    Use extended regular expressions rather than basic regular expressions. Extended regexps are those that egrep accepts; they can be clearer because they usually have fewer backslashes. Historically this was a GNU extension, but the -E extension has since been added to the POSIX standard (http://austingroupbugs.net/view.php?id=528), so use -E for portability. GNU sed has accepted -E as an undocumented option for years, and *BSD seds have accepted -E for years as well, but scripts that use -E might not port to other older systems. See Extended regular expressions.
-s
--separate

    By default, sed will consider the files specified on the command line as a single continuous long stream. This GNU sed extension allows the user to consider them as separate files: range addresses (such as ‘/abc/,/def/’) are not allowed to span several files, line numbers are relative to the start of each file, $ refers to the last line of each file, and files invoked from the R commands are rewound at the start of each file.
--sandbox

    In sandbox mode, e/w/r commands are rejected - programs containing them will be aborted without being run. Sandbox mode ensures sed operates only on the input files designated on the command line, and cannot run external programs.
-u
--unbuffered

    Buffer both input and output as minimally as practical. (This is particularly useful if the input is coming from the likes of ‘tail -f’, and you wish to see the transformed output as soon as possible.)
-z
--null-data
--zero-terminated

    Treat the input as a set of lines, each terminated by a zero byte (the ASCII ‘NUL’ character) instead of a newline. This option can be used with commands like ‘sort -z’ and ‘find -print0’ to process arbitrary file names. 

If no -e, -f, --expression, or --file options are given on the command-line, then the first non-option argument on the command line is taken to be the script to be executed.

If any command-line parameters remain after processing the above, these parameters are interpreted as the names of input files to be processed. A file name of ‘-’ refers to the standard input stream. The standard input will be processed if no file names are specified.

Previous: Command-Line Options, Up: Invoking sed   [Contents][Index]
2.3 Exit status

An exit status of zero indicates success, and a nonzero value indicates failure. GNU sed returns the following exit status error values:

0

    Successful completion.
1

    Invalid command, invalid syntax, invalid regular expression or a GNU sed extension command used with --posix.
2

    One or more of the input file specified on the command line could not be opened (e.g. if a file is not found, or read permission is denied). Processing continued with other files.
4

    An I/O error, or a serious processing error during runtime, GNU sed aborted immediately. 

Additionally, the commands q and Q can be used to terminate sed with a custom exit code value (this is a GNU sed extension):

$ echo | sed 'Q42' ; echo $?
42

Next: sed addresses, Previous: Invoking sed, Up: Top   [Contents][Index]
3 sed scripts
• sed script overview:	  	sed script overview
• sed commands list:	  	sed commands summary
• The "s" Command:	  	sed’s Swiss Army Knife
• Common Commands:	  	Often used commands
• Other Commands:	  	Less frequently used commands
• Programming Commands:	  	Commands for sed gurus
• Extended Commands:	  	Commands specific of GNU sed
• Multiple commands syntax:	  	Extension for easier scripting

Next: sed commands list, Up: sed scripts   [Contents][Index]
3.1 sed script overview

A sed program consists of one or more sed commands, passed in by one or more of the -e, -f, --expression, and --file options, or the first non-option argument if zero of these options are used. This document will refer to “the” sed script; this is understood to mean the in-order concatenation of all of the scripts and script-files passed in. See Overview.

sed commands follow this syntax:

[addr]X[options]

X is a single-letter sed command. [addr] is an optional line address. If [addr] is specified, the command X will be executed only on the matched lines. [addr] can be a single line number, a regular expression, or a range of lines (see sed addresses). Additional [options] are used for some sed commands.

The following example deletes lines 30 to 35 in the input. 30,35 is an address range. d is the delete command:

sed '30,35d' input.txt > output.txt

The following example prints all input until a line starting with the word ‘foo’ is found. If such line is found, sed will terminate with exit status 42. If such line was not found (and no other error occurred), sed will exit with status 0. /^foo/ is a regular-expression address. q is the quit command. 42 is the command option.

sed '/^foo/q42' input.txt > output.txt

Commands within a script or script-file can be separated by semicolons (;) or newlines (ASCII 10). Multiple scripts can be specified with -e or -f options.

The following examples are all equivalent. They perform two sed operations: deleting any lines matching the regular expression /^foo/, and replacing all occurrences of the string ‘hello’ with ‘world’:

sed '/^foo/d ; s/hello/world/' input.txt > output.txt

sed -e '/^foo/d' -e 's/hello/world/' input.txt > output.txt

echo '/^foo/d' > script.sed
echo 's/hello/world/' >> script.sed
sed -f script.sed input.txt > output.txt

echo 's/hello/world/' > script2.sed
sed -e '/^foo/d' -f script2.sed input.txt > output.txt

Commands a, c, i, due to their syntax, cannot be followed by semicolons working as command separators and thus should be terminated with newlines or be placed at the end of a script or script-file. Commands can also be preceded with optional non-significant whitespace characters. See Multiple commands syntax.

Next: The "s" Command, Previous: sed script overview, Up: sed scripts   [Contents][Index]
3.2 sed commands summary

The following commands are supported in GNU sed. Some are standard POSIX commands, while other are GNU extensions. Details and examples for each command are in the following sections. (Mnemonics) are shown in parentheses.

a\
text

    Append text after a line.
a text

    Append text after a line (alternative syntax).
b label

    Branch unconditionally to label. The label may be omitted, in which case the next cycle is started.
c\
text

    Replace (change) lines with text.
c text

    Replace (change) lines with text (alternative syntax).
d

    Delete the pattern space; immediately start next cycle.
D

    If pattern space contains newlines, delete text in the pattern space up to the first newline, and restart cycle with the resultant pattern space, without reading a new line of input.

    If pattern space contains no newline, start a normal new cycle as if the d command was issued.
e

    Executes the command that is found in pattern space and replaces the pattern space with the output; a trailing newline is suppressed.
e command

    Executes command and sends its output to the output stream. The command can run across multiple lines, all but the last ending with a back-slash.
F

    (filename) Print the file name of the current input file (with a trailing newline).
g

    Replace the contents of the pattern space with the contents of the hold space.
G

    Append a newline to the contents of the pattern space, and then append the contents of the hold space to that of the pattern space.
h

    (hold) Replace the contents of the hold space with the contents of the pattern space.
H

    Append a newline to the contents of the hold space, and then append the contents of the pattern space to that of the hold space.
i\
text

    insert text before a line.
i text

    insert text before a line (alternative syntax).
l

    Print the pattern space in an unambiguous form.
n

    (next) If auto-print is not disabled, print the pattern space, then, regardless, replace the pattern space with the next line of input. If there is no more input then sed exits without processing any more commands.
N

    Add a newline to the pattern space, then append the next line of input to the pattern space. If there is no more input then sed exits without processing any more commands.
p

    Print the pattern space.
P

    Print the pattern space, up to the first <newline>.
q[exit-code]

    (quit) Exit sed without processing any more commands or input.
Q[exit-code]

    (quit) This command is the same as q, but will not print the contents of pattern space. Like q, it provides the ability to return an exit code to the caller.
r filename

    Reads file filename.
R filename

    Queue a line of filename to be read and inserted into the output stream at the end of the current cycle, or when the next input line is read.
s/regexp/replacement/[flags]

    (substitute) Match the regular-expression against the content of the pattern space. If found, replace matched string with replacement.
t label

    (test) Branch to label only if there has been a successful substitution since the last input line was read or conditional branch was taken. The label may be omitted, in which case the next cycle is started.
T label

    (test) Branch to label only if there have been no successful substitutions since the last input line was read or conditional branch was taken. The label may be omitted, in which case the next cycle is started.
v [version]

    (version) This command does nothing, but makes sed fail if GNU sed extensions are not supported, or if the requested version is not available.
w filename

    Write the pattern space to filename.
W filename

    Write to the given filename the portion of the pattern space up to the first newline
x

    Exchange the contents of the hold and pattern spaces.
y/src/dst/

    Transliterate any characters in the pattern space which match any of the source-chars with the corresponding character in dest-chars.
z

    (zap) This command empties the content of pattern space.
#

    A comment, until the next newline.
{ cmd ; cmd ... }

    Group several commands together.
=

    Print the current input line number (with a trailing newline).
: label

    Specify the location of label for branch commands (b, t, T).

Next: Common Commands, Previous: sed commands list, Up: sed scripts   [Contents][Index]
3.3 The s Command

The s command (as in substitute) is probably the most important in sed and has a lot of different options. The syntax of the s command is ‘s/regexp/replacement/flags’.

Its basic concept is simple: the s command attempts to match the pattern space against the supplied regular expression regexp; if the match is successful, then that portion of the pattern space which was matched is replaced with replacement.

For details about regexp syntax see Regular Expression Addresses.

The replacement can contain \n (n being a number from 1 to 9, inclusive) references, which refer to the portion of the match which is contained between the nth \( and its matching \). Also, the replacement can contain unescaped & characters which reference the whole matched portion of the pattern space.

The / characters may be uniformly replaced by any other single character within any given s command. The / character (or whatever other character is used in its stead) can appear in the regexp or replacement only if it is preceded by a \ character.

Finally, as a GNU sed extension, you can include a special sequence made of a backslash and one of the letters L, l, U, u, or E. The meaning is as follows:

\L

    Turn the replacement to lowercase until a \U or \E is found,
\l

    Turn the next character to lowercase,
\U

    Turn the replacement to uppercase until a \L or \E is found,
\u

    Turn the next character to uppercase,
\E

    Stop case conversion started by \L or \U. 

When the g flag is being used, case conversion does not propagate from one occurrence of the regular expression to another. For example, when the following command is executed with ‘a-b-’ in pattern space:

s/\(b\?\)-/x\u\1/g

the output is ‘axxB’. When replacing the first ‘-’, the ‘\u’ sequence only affects the empty replacement of ‘\1’. It does not affect the x character that is added to pattern space when replacing b- with xB.

On the other hand, \l and \u do affect the remainder of the replacement text if they are followed by an empty substitution. With ‘a-b-’ in pattern space, the following command:

s/\(b\?\)-/\u\1x/g

will replace ‘-’ with ‘X’ (uppercase) and ‘b-’ with ‘Bx’. If this behavior is undesirable, you can prevent it by adding a ‘\E’ sequence—after ‘\1’ in this case.

To include a literal \, &, or newline in the final replacement, be sure to precede the desired \, &, or newline in the replacement with a \.

The s command can be followed by zero or more of the following flags:

g

    Apply the replacement to all matches to the regexp, not just the first.
number

    Only replace the numberth match of the regexp.

    interaction in s command Note: the POSIX standard does not specify what should happen when you mix the g and number modifiers, and currently there is no widely agreed upon meaning across sed implementations. For GNU sed, the interaction is defined to be: ignore matches before the numberth, and then match and replace all matches from the numberth on.
p

    If the substitution was made, then print the new pattern space.

    Note: when both the p and e options are specified, the relative ordering of the two produces very different results. In general, ep (evaluate then print) is what you want, but operating the other way round can be useful for debugging. For this reason, the current version of GNU sed interprets specially the presence of p options both before and after e, printing the pattern space before and after evaluation, while in general flags for the s command show their effect just once. This behavior, although documented, might change in future versions.
w filename

    If the substitution was made, then write out the result to the named file. As a GNU sed extension, two special values of filename are supported: /dev/stderr, which writes the result to the standard error, and /dev/stdout, which writes to the standard output.3
e

    This command allows one to pipe input from a shell command into pattern space. If a substitution was made, the command that is found in pattern space is executed and pattern space is replaced with its output. A trailing newline is suppressed; results are undefined if the command to be executed contains a NUL character. This is a GNU sed extension.
I
i

    The I modifier to regular-expression matching is a GNU extension which makes sed match regexp in a case-insensitive manner.
M
m

    The M modifier to regular-expression matching is a GNU sed extension which directs GNU sed to match the regular expression in multi-line mode. The modifier causes ^ and $ to match respectively (in addition to the normal behavior) the empty string after a newline, and the empty string before a newline. There are special character sequences (\` and \') which always match the beginning or the end of the buffer. In addition, the period character does not match a new-line character in multi-line mode.

Next: Other Commands, Previous: The "s" Command, Up: sed scripts   [Contents][Index]
3.4 Often-Used Commands

If you use sed at all, you will quite likely want to know these commands.

#

    [No addresses allowed.]

    The # character begins a comment; the comment continues until the next newline.

    If you are concerned about portability, be aware that some implementations of sed (which are not POSIX conforming) may only support a single one-line comment, and then only when the very first character of the script is a #.

    Warning: if the first two characters of the sed script are #n, then the -n (no-autoprint) option is forced. If you want to put a comment in the first line of your script and that comment begins with the letter ‘n’ and you do not want this behavior, then be sure to either use a capital ‘N’, or place at least one space before the ‘n’.
q [exit-code]

    Exit sed without processing any more commands or input.

    Example: stop after printing the second line:

    $ seq 3 | sed 2q
    1
    2

    This command accepts only one address. Note that the current pattern space is printed if auto-print is not disabled with the -n options. The ability to return an exit code from the sed script is a GNU sed extension.

    See also the GNU sed extension Q command which quits silently without printing the current pattern space.
d

    Delete the pattern space; immediately start next cycle.

    Example: delete the second input line:

    $ seq 3 | sed 2d
    1
    3

p

    Print out the pattern space (to the standard output). This command is usually only used in conjunction with the -n command-line option.

    Example: print only the second input line:

    $ seq 3 | sed -n 2p
    2

n

    If auto-print is not disabled, print the pattern space, then, regardless, replace the pattern space with the next line of input. If there is no more input then sed exits without processing any more commands.

    This command is useful to skip lines (e.g. process every Nth line).

    Example: perform substitution on every 3rd line (i.e. two n commands skip two lines):

    $ seq 6 | sed 'n;n;s/./x/'
    1
    2
    x
    4
    5
    x

    GNU sed provides an extension address syntax of first~step to achieve the same result:

    $ seq 6 | sed '0~3s/./x/'
    1
    2
    x
    4
    5
    x

{ commands }

    A group of commands may be enclosed between { and } characters. This is particularly useful when you want a group of commands to be triggered by a single address (or address-range) match.

    Example: perform substitution then print the second input line:

    $ seq 3 | sed -n '2{s/2/X/ ; p}'
    X

Next: Programming Commands, Previous: Common Commands, Up: sed scripts   [Contents][Index]
3.5 Less Frequently-Used Commands

Though perhaps less frequently used than those in the previous section, some very small yet useful sed scripts can be built with these commands.

y/source-chars/dest-chars/

    Transliterate any characters in the pattern space which match any of the source-chars with the corresponding character in dest-chars.

    Example: transliterate ‘a-j’ into ‘0-9’:

    $ echo hello world | sed 'y/abcdefghij/0123456789/'
    74llo worl3

    (The / characters may be uniformly replaced by any other single character within any given y command.)

    Instances of the / (or whatever other character is used in its stead), \, or newlines can appear in the source-chars or dest-chars lists, provide that each instance is escaped by a \. The source-chars and dest-chars lists must contain the same number of characters (after de-escaping).

    See the tr command from GNU coreutils for similar functionality.
a text

    Appending text after a line. This is a GNU extension to the standard a command - see below for details.

    Example: Add the word ‘hello’ after the second line:

    $ seq 3 | sed '2a hello'
    1
    2
    hello
    3

    Leading whitespace after the a command is ignored. The text to add is read until the end of the line.
a\
text

    Appending text after a line.

    Example: Add ‘hello’ after the second line (-| indicates printed output lines):

    $ seq 3 | sed '2a\
    hello'
    -|1
    -|2
    -|hello
    -|3

    The a command queues the lines of text which follow this command (each but the last ending with a \, which are removed from the output) to be output at the end of the current cycle, or when the next input line is read.

    As a GNU extension, this command accepts two addresses.

    Escape sequences in text are processed, so you should use \\ in text to print a single backslash.

    The commands resume after the last line without a backslash (\) - ‘world’ in the following example:

    $ seq 3 | sed '2a\
    hello\
    world
    3s/./X/'
    -|1
    -|2
    -|hello
    -|world
    -|X

    As a GNU extension, the a command and text can be separated into two -e parameters, enabling easier scripting:

    $ seq 3 | sed -e '2a\' -e hello
    1
    2
    hello
    3

    $ sed -e '2a\' -e "$VAR"

i text

    insert text before a line. This is a GNU extension to the standard i command - see below for details.

    Example: Insert the word ‘hello’ before the second line:

    $ seq 3 | sed '2i hello'
    1
    hello
    2
    3

    Leading whitespace after the i command is ignored. The text to add is read until the end of the line.
i\
text

    Immediately output the lines of text which follow this command.

    Example: Insert ‘hello’ before the second line (-| indicates printed output lines):

    $ seq 3 | sed '2i\
    hello'
    -|1
    -|hello
    -|2
    -|3

    As a GNU extension, this command accepts two addresses.

    Escape sequences in text are processed, so you should use \\ in text to print a single backslash.

    The commands resume after the last line without a backslash (\) - ‘world’ in the following example:

    $ seq 3 | sed '2i\
    hello\
    world
    s/./X/'
    -|X
    -|hello
    -|world
    -|X
    -|X

    As a GNU extension, the i command and text can be separated into two -e parameters, enabling easier scripting:

    $ seq 3 | sed -e '2i\' -e hello
    1
    hello
    2
    3

    $ sed -e '2i\' -e "$VAR"

c text

    Replaces the line(s) with text. This is a GNU extension to the standard c command - see below for details.

    Example: Replace the 2nd to 9th lines with the word ‘hello’:

    $ seq 10 | sed '2,9c hello'
    1
    hello
    10

    Leading whitespace after the c command is ignored. The text to add is read until the end of the line.
c\
text

    Delete the lines matching the address or address-range, and output the lines of text which follow this command.

    Example: Replace 2nd to 4th lines with the words ‘hello’ and ‘world’ (-| indicates printed output lines):

    $ seq 5 | sed '2,4c\
    hello\
    world'
    -|1
    -|hello
    -|world
    -|5

    If no addresses are given, each line is replaced.

    A new cycle is started after this command is done, since the pattern space will have been deleted. In the following example, the c starts a new cycle and the substitution command is not performed on the replaced text:

    $ seq 3 | sed '2c\
    hello
    s/./X/'
    -|X
    -|hello
    -|X

    As a GNU extension, the c command and text can be separated into two -e parameters, enabling easier scripting:

    $ seq 3 | sed -e '2c\' -e hello
    1
    hello
    3

    $ sed -e '2c\' -e "$VAR"

=

    Print out the current input line number (with a trailing newline).

    $ printf '%s\n' aaa bbb ccc | sed =
    1
    aaa
    2
    bbb
    3
    ccc

    As a GNU extension, this command accepts two addresses.
l n

    Print the pattern space in an unambiguous form: non-printable characters (and the \ character) are printed in C-style escaped form; long lines are split, with a trailing \ character to indicate the split; the end of each line is marked with a $.

    n specifies the desired line-wrap length; a length of 0 (zero) means to never wrap long lines. If omitted, the default as specified on the command line is used. The n parameter is a GNU sed extension.
r filename

    Reads file filename. Example:

    $ seq 3 | sed '2r/etc/hostname'
    1
    2
    fencepost.gnu.org
    3

    Queue the contents of filename to be read and inserted into the output stream at the end of the current cycle, or when the next input line is read. Note that if filename cannot be read, it is treated as if it were an empty file, without any error indication.

    As a GNU sed extension, the special value /dev/stdin is supported for the file name, which reads the contents of the standard input.

    As a GNU extension, this command accepts two addresses. The file will then be reread and inserted on each of the addressed lines.
w filename

    Write the pattern space to filename. As a GNU sed extension, two special values of filename are supported: /dev/stderr, which writes the result to the standard error, and /dev/stdout, which writes to the standard output.4

    The file will be created (or truncated) before the first input line is read; all w commands (including instances of the w flag on successful s commands) which refer to the same filename are output without closing and reopening the file.
D

    If pattern space contains no newline, start a normal new cycle as if the d command was issued. Otherwise, delete text in the pattern space up to the first newline, and restart cycle with the resultant pattern space, without reading a new line of input.
N

    Add a newline to the pattern space, then append the next line of input to the pattern space. If there is no more input then sed exits without processing any more commands.

    When -z is used, a zero byte (the ascii ‘NUL’ character) is added between the lines (instead of a new line).

    By default sed does not terminate if there is no ’next’ input line. This is a GNU extension which can be disabled with --posix. See N command on the last line.
P

    Print out the portion of the pattern space up to the first newline.
h

    Replace the contents of the hold space with the contents of the pattern space.
H

    Append a newline to the contents of the hold space, and then append the contents of the pattern space to that of the hold space.
g

    Replace the contents of the pattern space with the contents of the hold space.
G

    Append a newline to the contents of the pattern space, and then append the contents of the hold space to that of the pattern space.
x

    Exchange the contents of the hold and pattern spaces.

Next: Extended Commands, Previous: Other Commands, Up: sed scripts   [Contents][Index]
3.6 Commands for sed gurus

In most cases, use of these commands indicates that you are probably better off programming in something like awk or Perl. But occasionally one is committed to sticking with sed, and these commands can enable one to write quite convoluted scripts.

: label

    [No addresses allowed.]

    Specify the location of label for branch commands. In all other respects, a no-op.
b label

    Unconditionally branch to label. The label may be omitted, in which case the next cycle is started.
t label

    Branch to label only if there has been a successful substitution since the last input line was read or conditional branch was taken. The label may be omitted, in which case the next cycle is started.

Next: Multiple commands syntax, Previous: Programming Commands, Up: sed scripts   [Contents][Index]
3.7 Commands Specific to GNU sed

These commands are specific to GNU sed, so you must use them with care and only when you are sure that hindering portability is not evil. They allow you to check for GNU sed extensions or to do tasks that are required quite often, yet are unsupported by standard seds.

e [command]

    This command allows one to pipe input from a shell command into pattern space. Without parameters, the e command executes the command that is found in pattern space and replaces the pattern space with the output; a trailing newline is suppressed.

    If a parameter is specified, instead, the e command interprets it as a command and sends its output to the output stream. The command can run across multiple lines, all but the last ending with a back-slash.

    In both cases, the results are undefined if the command to be executed contains a NUL character.

    Note that, unlike the r command, the output of the command will be printed immediately; the r command instead delays the output to the end of the current cycle.
F

    Print out the file name of the current input file (with a trailing newline).
Q [exit-code]

    This command accepts only one address.

    This command is the same as q, but will not print the contents of pattern space. Like q, it provides the ability to return an exit code to the caller.

    This command can be useful because the only alternative ways to accomplish this apparently trivial function are to use the -n option (which can unnecessarily complicate your script) or resorting to the following snippet, which wastes time by reading the whole file without any visible effect:

    :eat
    $d       Quit silently on the last line
    N        Read another line, silently
    g        Overwrite pattern space each time to save memory
    b eat

R filename

    Queue a line of filename to be read and inserted into the output stream at the end of the current cycle, or when the next input line is read. Note that if filename cannot be read, or if its end is reached, no line is appended, without any error indication.

    As with the r command, the special value /dev/stdin is supported for the file name, which reads a line from the standard input.
T label

    Branch to label only if there have been no successful substitutions since the last input line was read or conditional branch was taken. The label may be omitted, in which case the next cycle is started.
v version

    This command does nothing, but makes sed fail if GNU sed extensions are not supported, simply because other versions of sed do not implement it. In addition, you can specify the version of sed that your script requires, such as 4.0.5. The default is 4.0 because that is the first version that implemented this command.

    This command enables all GNU extensions even if POSIXLY_CORRECT is set in the environment.
W filename

    Write to the given filename the portion of the pattern space up to the first newline. Everything said under the w command about file handling holds here too.
z

    This command empties the content of pattern space. It is usually the same as ‘s/.*//’, but is more efficient and works in the presence of invalid multibyte sequences in the input stream. POSIX mandates that such sequences are not matched by ‘.’, so that there is no portable way to clear sed’s buffers in the middle of the script in most multibyte locales (including UTF-8 locales). 

Previous: Extended Commands, Up: sed scripts   [Contents][Index]
3.8 Multiple commands syntax

There are several methods to specify multiple commands in a sed program.

Using newlines is most natural when running a sed script from a file (using the -f option).

On the command line, all sed commands may be separated by newlines. Alternatively, you may specify each command as an argument to an -e option:

$ seq 6 | sed '1d
3d
5d'
2
4
6

$ seq 6 | sed -e 1d -e 3d -e 5d
2
4
6

A semicolon (‘;’) may be used to separate most simple commands:

$ seq 6 | sed '1d;3d;5d'
2
4
6

The {,},b,t,T,: commands can be separated with a semicolon (this is a non-portable GNU sed extension).

$ seq 4 | sed '{1d;3d}'
2
4

$ seq 6 | sed '{1d;3d};5d'
2
4
6

Labels used in b,t,T,: commands are read until a semicolon. Leading and trailing whitespace is ignored. In the examples below the label is ‘x’. The first example works with GNU sed. The second is a portable equivalent. For more information about branching and labels see Branching and flow control.

$ seq 3 | sed '/1/b x ; s/^/=/ ; :x ; 3d'
1
=2

$ seq 3 | sed -e '/1/bx' -e 's/^/=/' -e ':x' -e '3d'
1
=2

3.8.1 Commands Requiring a newline

The following commands cannot be separated by a semicolon and require a newline:

a,c,i (append/change/insert)

    All characters following a,c,i commands are taken as the text to append/change/insert. Using a semicolon leads to undesirable results:

    $ seq 2 | sed '1aHello ; 2d'
    1
    Hello ; 2d
    2

    Separate the commands using -e or a newline:

    $ seq 2 | sed -e 1aHello -e 2d
    1
    Hello

    $ seq 2 | sed '1aHello
    2d'
    1
    Hello

    Note that specifying the text to add (‘Hello’) immediately after a,c,i is itself a GNU sed extension. A portable, POSIX-compliant alternative is:

    $ seq 2 | sed '1a\
    Hello
    2d'
    1
    Hello

# (comment)

    All characters following ‘#’ until the next newline are ignored.

    $ seq 3 | sed '# this is a comment ; 2d'
    1
    2
    3


    $ seq 3 | sed '# this is a comment
    2d'
    1
    3

r,R,w,W (reading and writing files)

    The r,R,w,W commands parse the filename until end of the line. If whitespace, comments or semicolons are found, they will be included in the filename, leading to unexpected results:

    $ seq 2 | sed '1w hello.txt ; 2d'
    1
    2

    $ ls -log
    total 4
    -rw-rw-r-- 1 2 Jan 23 23:03 hello.txt ; 2d

    $ cat 'hello.txt ; 2d'
    1

    Note that sed silently ignores read/write errors in r,R,w,W commands (such as missing files). In the following example, sed tries to read a file named ‘hello.txt ; N’. The file is missing, and the error is silently ignored:

    $ echo x | sed '1rhello.txt ; N'
    x

e (command execution)

    Any characters following the e command until the end of the line will be sent to the shell. If whitespace, comments or semicolons are found, they will be included in the shell command, leading to unexpected results:

    $ echo a | sed '1e touch foo#bar'
    a

    $ ls -1
    foo#bar

    $ echo a | sed '1e touch foo ; s/a/b/'
    sh: 1: s/a/b/: not found
    a

s///[we] (substitute with e or w flags)

    In a substitution command, the w flag writes the substitution result to a file, and the e flag executes the subsitution result as a shell command. As with the r/R/w/W/e commands, these must be terminated with a newline. If whitespace, comments or semicolons are found, they will be included in the shell command or filename, leading to unexpected results:

    $ echo a | sed 's/a/b/w1.txt#foo'
    b

    $ ls -1
    1.txt#foo

Next: sed regular expressions, Previous: sed scripts, Up: Top   [Contents][Index]
4 Addresses: selecting lines
• Addresses overview:	  	Addresses overview
• Numeric Addresses:	  	selecting lines by numbers
• Regexp Addresses:	  	selecting lines by text matching
• Range Addresses:	  	selecting a range of lines

Next: Numeric Addresses, Up: sed addresses   [Contents][Index]
4.1 Addresses overview

Addresses determine on which line(s) the sed command will be executed. The following command replaces the word ‘hello’ with ‘world’ only on line 144:

sed '144s/hello/world/' input.txt > output.txt

If no addresses are given, the command is performed on all lines. The following command replaces the word ‘hello’ with ‘world’ on all lines in the input file:

sed 's/hello/world/' input.txt > output.txt

Addresses can contain regular expressions to match lines based on content instead of line numbers. The following command replaces the word ‘hello’ with ‘world’ only in lines containing the word ‘apple’:

sed '/apple/s/hello/world/' input.txt > output.txt

An address range is specified with two addresses separated by a comma (,). Addresses can be numeric, regular expressions, or a mix of both. The following command replaces the word ‘hello’ with ‘world’ only in lines 4 to 17 (inclusive):

sed '4,17s/hello/world/' input.txt > output.txt

Appending the ! character to the end of an address specification (before the command letter) negates the sense of the match. That is, if the ! character follows an address or an address range, then only lines which do not match the addresses will be selected. The following command replaces the word ‘hello’ with ‘world’ only in lines not containing the word ‘apple’:

sed '/apple/!s/hello/world/' input.txt > output.txt

The following command replaces the word ‘hello’ with ‘world’ only in lines 1 to 3 and 18 till the last line of the input file (i.e. excluding lines 4 to 17):

sed '4,17!s/hello/world/' input.txt > output.txt

Next: Regexp Addresses, Previous: Addresses overview, Up: sed addresses   [Contents][Index]
4.2 Selecting lines by numbers

Addresses in a sed script can be in any of the following forms:

number

    Specifying a line number will match only that line in the input. (Note that sed counts lines continuously across all input files unless -i or -s options are specified.)
$

    This address matches the last line of the last file of input, or the last line of each file when the -i or -s options are specified.
first~step

    This GNU extension matches every stepth line starting with line first. In particular, lines will be selected when there exists a non-negative n such that the current line-number equals first + (n * step). Thus, one would use 1~2 to select the odd-numbered lines and 0~2 for even-numbered lines; to pick every third line starting with the second, ‘2~3’ would be used; to pick every fifth line starting with the tenth, use ‘10~5’; and ‘50~0’ is just an obscure way of saying 50.

    The following commands demonstrate the step address usage:

    $ seq 10 | sed -n '0~4p'
    4
    8

    $ seq 10 | sed -n '1~3p'
    1
    4
    7
    10

Next: Range Addresses, Previous: Numeric Addresses, Up: sed addresses   [Contents][Index]
4.3 selecting lines by text matching

GNU sed supports the following regular expression addresses. The default regular expression is Basic Regular Expression (BRE). If -E or -r options are used, The regular expression should be in Extended Regular Expression (ERE) syntax. See BRE vs ERE.

/regexp/

    This will select any line which matches the regular expression regexp. If regexp itself includes any / characters, each must be escaped by a backslash (\).

    The following command prints lines in /etc/passwd which end with ‘bash’5:

    sed -n '/bash$/p' /etc/passwd

    The empty regular expression ‘//’ repeats the last regular expression match (the same holds if the empty regular expression is passed to the s command). Note that modifiers to regular expressions are evaluated when the regular expression is compiled, thus it is invalid to specify them together with the empty regular expression.
\%regexp%

    (The % may be replaced by any other single character.)

    This also matches the regular expression regexp, but allows one to use a different delimiter than /. This is particularly useful if the regexp itself contains a lot of slashes, since it avoids the tedious escaping of every /. If regexp itself includes any delimiter characters, each must be escaped by a backslash (\).

    The following commands are equivalent. They print lines which start with ‘/home/alice/documents/’:

    sed -n '/^\/home\/alice\/documents\//p'
    sed -n '\%^/home/alice/documents/%p'
    sed -n '\;^/home/alice/documents/;p'

/regexp/I
\%regexp%I

    The I modifier to regular-expression matching is a GNU extension which causes the regexp to be matched in a case-insensitive manner.

    In many other programming languages, a lower case i is used for case-insensitive regular expression matching. However, in sed the i is used for the insert command (see insert command).

    Observe the difference between the following examples.

    In this example, /b/I is the address: regular expression with I modifier. d is the delete command:

    $ printf "%s\n" a b c | sed '/b/Id'
    a
    c

    Here, /b/ is the address: a regular expression. i is the insert command. d is the value to insert. A line with ‘d’ is then inserted above the matched line:

    $ printf "%s\n" a b c | sed '/b/id'
    a
    d
    b
    c

/regexp/M
\%regexp%M

    The M modifier to regular-expression matching is a GNU sed extension which directs GNU sed to match the regular expression in multi-line mode. The modifier causes ^ and $ to match respectively (in addition to the normal behavior) the empty string after a newline, and the empty string before a newline. There are special character sequences (\` and \') which always match the beginning or the end of the buffer. In addition, the period character does not match a new-line character in multi-line mode. 

Regex addresses operate on the content of the current pattern space. If the pattern space is changed (for example with s/// command) the regular expression matching will operate on the changed text.

In the following example, automatic printing is disabled with -n. The s/2/X/ command changes lines containing ‘2’ to ‘X’. The command /[0-9]/p matches lines with digits and prints them. Because the second line is changed before the /[0-9]/ regex, it will not match and will not be printed:

$ seq 3 | sed -n 's/2/X/ ; /[0-9]/p'
1
3

Previous: Regexp Addresses, Up: sed addresses   [Contents][Index]
4.4 Range Addresses

An address range can be specified by specifying two addresses separated by a comma (,). An address range matches lines starting from where the first address matches, and continues until the second address matches (inclusively):

$ seq 10 | sed -n '4,6p'
4
5
6

If the second address is a regexp, then checking for the ending match will start with the line following the line which matched the first address: a range will always span at least two lines (except of course if the input stream ends).

$ seq 10 | sed -n '4,/[0-9]/p'
4
5

If the second address is a number less than (or equal to) the line matching the first address, then only the one line is matched:

$ seq 10 | sed -n '4,1p'
4

GNU sed also supports some special two-address forms; all these are GNU extensions:

0,/regexp/

    A line number of 0 can be used in an address specification like 0,/regexp/ so that sed will try to match regexp in the first input line too. In other words, 0,/regexp/ is similar to 1,/regexp/, except that if addr2 matches the very first line of input the 0,/regexp/ form will consider it to end the range, whereas the 1,/regexp/ form will match the beginning of its range and hence make the range span up to the second occurrence of the regular expression.

    Note that this is the only place where the 0 address makes sense; there is no 0-th line and commands which are given the 0 address in any other way will give an error.

    The following examples demonstrate the difference between starting with address 1 and 0:

    $ seq 10 | sed -n '1,/[0-9]/p'
    1
    2

    $ seq 10 | sed -n '0,/[0-9]/p'
    1

addr1,+N

    Matches addr1 and the N lines following addr1.

    $ seq 10 | sed -n '6,+2p'
    6
    7
    8

    addr1 can be a line number or a regular expression.
addr1,~N

    Matches addr1 and the lines following addr1 until the next line whose input line number is a multiple of N. The following command prints starting at line 6, until the next line which is a multiple of 4 (i.e. line 8):

    $ seq 10 | sed -n '6,~4p'
    6
    7
    8

    addr1 can be a line number or a regular expression.

Next: advanced sed, Previous: sed addresses, Up: Top   [Contents][Index]
5 Regular Expressions: selecting text
• Regular Expressions Overview:	  	Overview of Regular expression in sed
• BRE vs ERE:	  	Basic (BRE) and extended (ERE) regular expression syntax
• BRE syntax:	  	Overview of basic regular expression syntax
• ERE syntax:	  	Overview of extended regular expression syntax
• Character Classes and Bracket Expressions:	  	
• regexp extensions:	  	Additional regular expression commands
• Back-references and Subexpressions:	  	Back-references and Subexpressions
• Escapes:	  	Specifying special characters
• Locale Considerations:	  	Multibyte characters and locale considrations

Next: BRE vs ERE, Up: sed regular expressions   [Contents][Index]
5.1 Overview of regular expression in sed

To know how to use sed, people should understand regular expressions (regexp for short). A regular expression is a pattern that is matched against a subject string from left to right. Most characters are ordinary: they stand for themselves in a pattern, and match the corresponding characters. Regular expressions in sed are specified between two slashes.

The following command prints lines containing the word ‘hello’:

sed -n '/hello/p'

The above example is equivalent to this grep command:

grep 'hello'

The power of regular expressions comes from the ability to include alternatives and repetitions in the pattern. These are encoded in the pattern by the use of special characters, which do not stand for themselves but instead are interpreted in some special way.

The character ^ (caret) in a regular expression matches the beginning of the line. The character . (dot) matches any single character. The following sed command matches and prints lines which start with the letter ‘b’, followed by any single character, followed by the letter ‘d’:

$ printf "%s\n" abode bad bed bit bid byte body | sed -n '/^b.d/p'
bad
bed
bid
body

The following sections explain the meaning and usage of special characters in regular expressions.

Next: BRE syntax, Previous: Regular Expressions Overview, Up: sed regular expressions   [Contents][Index]
5.2 Basic (BRE) and extended (ERE) regular expression

Basic and extended regular expressions are two variations on the syntax of the specified pattern. Basic Regular Expression (BRE) syntax is the default in sed (and similarly in grep). Use the POSIX-specified -E option (-r, --regexp-extended) to enable Extended Regular Expression (ERE) syntax.

In GNU sed, the only difference between basic and extended regular expressions is in the behavior of a few special characters: ‘?’, ‘+’, parentheses, braces (‘{}’), and ‘|’.

With basic (BRE) syntax, these characters do not have special meaning unless prefixed with a backslash (‘\’); While with extended (ERE) syntax it is reversed: these characters are special unless they are prefixed with backslash (‘\’).
Desired pattern	Basic (BRE) Syntax	Extended (ERE) Syntax
literal ‘+’ (plus sign)	

$ echo 'a+b=c' > foo
$ sed -n '/a+b/p' foo
a+b=c

	

$ echo 'a+b=c' > foo
$ sed -E -n '/a\+b/p' foo
a+b=c

One or more ‘a’ characters followed by ‘b’ (plus sign as special meta-character)	

$ echo aab > foo
$ sed -n '/a\+b/p' foo
aab

	

$ echo aab > foo
$ sed -E -n '/a+b/p' foo
aab

Next: ERE syntax, Previous: BRE vs ERE, Up: sed regular expressions   [Contents][Index]
5.3 Overview of basic regular expression syntax

Here is a brief description of regular expression syntax as used in sed.

char

    A single ordinary character matches itself.
*

    Matches a sequence of zero or more instances of matches for the preceding regular expression, which must be an ordinary character, a special character preceded by \, a ., a grouped regexp (see below), or a bracket expression. As a GNU extension, a postfixed regular expression can also be followed by *; for example, a** is equivalent to a*. POSIX 1003.1-2001 says that * stands for itself when it appears at the start of a regular expression or subexpression, but many nonGNU implementations do not support this and portable scripts should instead use \* in these contexts. 
.

    Matches any character, including newline.
^

    Matches the null string at beginning of the pattern space, i.e. what appears after the circumflex must appear at the beginning of the pattern space.

    In most scripts, pattern space is initialized to the content of each line (see How sed works). So, it is a useful simplification to think of ^#include as matching only lines where ‘#include’ is the first thing on line—if there are spaces before, for example, the match fails. This simplification is valid as long as the original content of pattern space is not modified, for example with an s command.

    ^ acts as a special character only at the beginning of the regular expression or subexpression (that is, after \( or \|). Portable scripts should avoid ^ at the beginning of a subexpression, though, as POSIX allows implementations that treat ^ as an ordinary character in that context.
$

    It is the same as ^, but refers to end of pattern space. $ also acts as a special character only at the end of the regular expression or subexpression (that is, before \) or \|), and its use at the end of a subexpression is not portable.
[list]
[^list]

    Matches any single character in list: for example, [aeiou] matches all vowels. A list may include sequences like char1-char2, which matches any character between (inclusive) char1 and char2. See Character Classes and Bracket Expressions.
\+

    As *, but matches one or more. It is a GNU extension.
\?

    As *, but only matches zero or one. It is a GNU extension.
\{i\}

    As *, but matches exactly i sequences (i is a decimal integer; for portability, keep it between 0 and 255 inclusive).
\{i,j\}

    Matches between i and j, inclusive, sequences.
\{i,\}

    Matches more than or equal to i sequences.
\(regexp\)

    Groups the inner regexp as a whole, this is used to:

        Apply postfix operators, like \(abcd\)*: this will search for zero or more whole sequences of ‘abcd’, while abcd* would search for ‘abc’ followed by zero or more occurrences of ‘d’. Note that support for \(abcd\)* is required by POSIX 1003.1-2001, but many non-GNU implementations do not support it and hence it is not universally portable.
        Use back references (see below). 

regexp1\|regexp2

    Matches either regexp1 or regexp2. Use parentheses to use complex alternative regular expressions. The matching process tries each alternative in turn, from left to right, and the first one that succeeds is used. It is a GNU extension.
regexp1regexp2

    Matches the concatenation of regexp1 and regexp2. Concatenation binds more tightly than \|, ^, and $, but less tightly than the other regular expression operators.
\digit

    Matches the digit-th \(…\) parenthesized subexpression in the regular expression. This is called a back reference. Subexpressions are implicitly numbered by counting occurrences of \( left-to-right.
\n

    Matches the newline character.
\char

    Matches char, where char is one of $, *, ., [, \, or ^. Note that the only C-like backslash sequences that you can portably assume to be interpreted are \n and \\; in particular \t is not portable, and matches a ‘t’ under most implementations of sed, rather than a tab character.

Note that the regular expression matcher is greedy, i.e., matches are attempted from left to right and, if two or more matches are possible starting at the same character, it selects the longest.

Examples:

‘abcdef’

    Matches ‘abcdef’.
‘a*b’

    Matches zero or more ‘a’s followed by a single ‘b’. For example, ‘b’ or ‘aaaaab’.
‘a\?b’

    Matches ‘b’ or ‘ab’.
‘a\+b\+’

    Matches one or more ‘a’s followed by one or more ‘b’s: ‘ab’ is the shortest possible match, but other examples are ‘aaaab’ or ‘abbbbb’ or ‘aaaaaabbbbbbb’.
‘.*’
‘.\+’

    These two both match all the characters in a string; however, the first matches every string (including the empty string), while the second matches only strings containing at least one character.
‘^main.*(.*)’

    This matches a string starting with ‘main’, followed by an opening and closing parenthesis. The ‘n’, ‘(’ and ‘)’ need not be adjacent.
‘^#’

    This matches a string beginning with ‘#’.
‘\\$’

    This matches a string ending with a single backslash. The regexp contains two backslashes for escaping.
‘\$’

    Instead, this matches a string consisting of a single dollar sign, because it is escaped.
‘[a-zA-Z0-9]’

    In the C locale, this matches any ASCII letters or digits.
‘[^ TAB]\+’

    (Here TAB stands for a single tab character.) This matches a string of one or more characters, none of which is a space or a tab. Usually this means a word.
‘^\(.*\)\n\1$’

    This matches a string consisting of two equal substrings separated by a newline.
‘.\{9\}A$’

    This matches nine characters followed by an ‘A’ at the end of a line.
‘^.\{15\}A’

    This matches the start of a string that contains 16 characters, the last of which is an ‘A’.

Next: Character Classes and Bracket Expressions, Previous: BRE syntax, Up: sed regular expressions   [Contents][Index]
5.4 Overview of extended regular expression syntax

The only difference between basic and extended regular expressions is in the behavior of a few characters: ‘?’, ‘+’, parentheses, braces (‘{}’), and ‘|’. While basic regular expressions require these to be escaped if you want them to behave as special characters, when using extended regular expressions you must escape them if you want them to match a literal character. ‘|’ is special here because ‘\|’ is a GNU extension – standard basic regular expressions do not provide its functionality.

Examples:

abc?

    becomes ‘abc\?’ when using extended regular expressions. It matches the literal string ‘abc?’.
c\+

    becomes ‘c+’ when using extended regular expressions. It matches one or more ‘c’s.
a\{3,\}

    becomes ‘a{3,}’ when using extended regular expressions. It matches three or more ‘a’s.
\(abc\)\{2,3\}

    becomes ‘(abc){2,3}’ when using extended regular expressions. It matches either ‘abcabc’ or ‘abcabcabc’.
\(abc*\)\1

    becomes ‘(abc*)\1’ when using extended regular expressions. Backreferences must still be escaped when using extended regular expressions.
a\|b

    becomes ‘a|b’ when using extended regular expressions. It matches ‘a’ or ‘b’. 

Next: regexp extensions, Previous: ERE syntax, Up: sed regular expressions   [Contents][Index]
5.5 Character Classes and Bracket Expressions

A bracket expression is a list of characters enclosed by ‘[’ and ‘]’. It matches any single character in that list; if the first character of the list is the caret ‘^’, then it matches any character not in the list. For example, the following command replaces the words ‘gray’ or ‘grey’ with ‘blue’:

sed  's/gr[ae]y/blue/'

Bracket expressions can be used in both basic and extended regular expressions (that is, with or without the -E/-r options).

Within a bracket expression, a range expression consists of two characters separated by a hyphen. It matches any single character that sorts between the two characters, inclusive. In the default C locale, the sorting sequence is the native character order; for example, ‘[a-d]’ is equivalent to ‘[abcd]’.

Finally, certain named classes of characters are predefined within bracket expressions, as follows.

These named classes must be used inside brackets themselves. Correct usage:

$ echo 1 | sed 's/[[:digit:]]/X/'
X

Incorrect usage is rejected by newer sed versions. Older versions accepted it but treated it as a single bracket expression (which is equivalent to ‘[dgit:]’, that is, only the characters d/g/i/t/:):

# current GNU sed versions - incorrect usage rejected
$ echo 1 | sed 's/[:digit:]/X/'
sed: character class syntax is [[:space:]], not [:space:]

# older GNU sed versions
$ echo 1 | sed 's/[:digit:]/X/'
1

‘[:alnum:]’

    Alphanumeric characters: ‘[:alpha:]’ and ‘[:digit:]’; in the ‘C’ locale and ASCII character encoding, this is the same as ‘[0-9A-Za-z]’.
‘[:alpha:]’

    Alphabetic characters: ‘[:lower:]’ and ‘[:upper:]’; in the ‘C’ locale and ASCII character encoding, this is the same as ‘[A-Za-z]’.
‘[:blank:]’

    Blank characters: space and tab.
‘[:cntrl:]’

    Control characters. In ASCII, these characters have octal codes 000 through 037, and 177 (DEL). In other character sets, these are the equivalent characters, if any.
‘[:digit:]’

    Digits: 0 1 2 3 4 5 6 7 8 9.
‘[:graph:]’

    Graphical characters: ‘[:alnum:]’ and ‘[:punct:]’.
‘[:lower:]’

    Lower-case letters; in the ‘C’ locale and ASCII character encoding, this is a b c d e f g h i j k l m n o p q r s t u v w x y z.
‘[:print:]’

    Printable characters: ‘[:alnum:]’, ‘[:punct:]’, and space.
‘[:punct:]’

    Punctuation characters; in the ‘C’ locale and ASCII character encoding, this is ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~.
‘[:space:]’

    Space characters: in the ‘C’ locale, this is tab, newline, vertical tab, form feed, carriage return, and space.
‘[:upper:]’

    Upper-case letters: in the ‘C’ locale and ASCII character encoding, this is A B C D E F G H I J K L M N O P Q R S T U V W X Y Z.
‘[:xdigit:]’

    Hexadecimal digits: 0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f.

Note that the brackets in these class names are part of the symbolic names, and must be included in addition to the brackets delimiting the bracket expression.

Most meta-characters lose their special meaning inside bracket expressions:

‘]’

    ends the bracket expression if it’s not the first list item. So, if you want to make the ‘]’ character a list item, you must put it first.
‘-’

    represents the range if it’s not first or last in a list or the ending point of a range.
‘^’

    represents the characters not in the list. If you want to make the ‘^’ character a list item, place it anywhere but first. 

TODO: incorporate this paragraph (copied verbatim from BRE section).

The characters $, *, ., [, and \ are normally not special within list. For example, [\*] matches either ‘\’ or ‘*’, because the \ is not special here. However, strings like [.ch.], [=a=], and [:space:] are special within list and represent collating symbols, equivalence classes, and character classes, respectively, and [ is therefore special within list when it is followed by ., =, or :. Also, when not in POSIXLY_CORRECT mode, special escapes like \n and \t are recognized within list. See Escapes.

‘[.’

    represents the open collating symbol.
‘.]’

    represents the close collating symbol.
‘[=’

    represents the open equivalence class.
‘=]’

    represents the close equivalence class.
‘[:’

    represents the open character class symbol, and should be followed by a valid character class name.
‘:]’

    represents the close character class symbol. 

Next: Back-references and Subexpressions, Previous: Character Classes and Bracket Expressions, Up: sed regular expressions   [Contents][Index]
5.6 regular expression extensions

The following sequences have special meaning inside regular expressions (used in addresses and the s command).

These can be used in both basic and extended regular expressions (that is, with or without the -E/-r options).

\w

    Matches any “word” character. A “word” character is any letter or digit or the underscore character.

    $ echo "abc %-= def." | sed 's/\w/X/g'
    XXX %-= XXX.

\W

    Matches any “non-word” character.

    $ echo "abc %-= def." | sed 's/\W/X/g'
    abcXXXXXdefX

\b

    Matches a word boundary; that is it matches if the character to the left is a “word” character and the character to the right is a “non-word” character, or vice-versa.

    $ echo "abc %-= def." | sed 's/\b/X/g'
    XabcX %-= XdefX.

\B

    Matches everywhere but on a word boundary; that is it matches if the character to the left and the character to the right are either both “word” characters or both “non-word” characters.

    $ echo "abc %-= def." | sed 's/\B/X/g'
    aXbXc X%X-X=X dXeXf.X

\s

    Matches whitespace characters (spaces and tabs). Newlines embedded in the pattern/hold spaces will also match:

    $ echo "abc %-= def." | sed 's/\s/X/g'
    abcX%-=Xdef.

\S

    Matches non-whitespace characters.

    $ echo "abc %-= def." | sed 's/\S/X/g'
    XXX XXX XXXX

\<

    Matches the beginning of a word.

    $ echo "abc %-= def." | sed 's/\</X/g'
    Xabc %-= Xdef.

\>

    Matches the end of a word.

    $ echo "abc %-= def." | sed 's/\>/X/g'
    abcX %-= defX.

\`

    Matches only at the start of pattern space. This is different from ^ in multi-line mode.

    Compare the following two examples:

    $ printf "a\nb\nc\n" | sed 'N;N;s/^/X/gm'
    Xa
    Xb
    Xc

    $ printf "a\nb\nc\n" | sed 'N;N;s/\`/X/gm'
    Xa
    b
    c

\'

    Matches only at the end of pattern space. This is different from $ in multi-line mode.

Next: Escapes, Previous: regexp extensions, Up: sed regular expressions   [Contents][Index]
5.7 Back-references and Subexpressions

back-references are regular expression commands which refer to a previous part of the matched regular expression. Back-references are specified with backslash and a single digit (e.g. ‘\1’). The part of the regular expression they refer to is called a subexpression, and is designated with parentheses.

Back-references and subexpressions are used in two cases: in the regular expression search pattern, and in the replacement part of the s command (see Regular Expression Addresses and The "s" Command).

In a regular expression pattern, back-references are used to match the same content as a previously matched subexpression. In the following example, the subexpression is ‘.’ - any single character (being surrounded by parentheses makes it a subexpression). The back-reference ‘\1’ asks to match the same content (same character) as the sub-expression.

The command below matches words starting with any character, followed by the letter ‘o’, followed by the same character as the first.

$ sed -E -n '/^(.)o\1$/p' /usr/share/dict/words
bob
mom
non
pop
sos
tot
wow

Multiple subexpressions are automatically numbered from left-to-right. This command searches for 6-letter palindromes (the first three letters are 3 subexpressions, followed by 3 back-references in reverse order):

$ sed -E -n '/^(.)(.)(.)\3\2\1$/p' /usr/share/dict/words
redder

In the s command, back-references can be used in the replacement part to refer back to subexpressions in the regexp part.

The following example uses two subexpressions in the regular expression to match two space-separated words. The back-references in the replacement part prints the words in a different order:

$ echo "James Bond" | sed -E 's/(.*) (.*)/The name is \2, \1 \2./'
The name is Bond, James Bond.

When used with alternation, if the group does not participate in the match then the back-reference makes the whole match fail. For example, ‘a(.)|b\1’ will not match ‘ba’. When multiple regular expressions are given with -e or from a file (‘-f file’), back-references are local to each expression.

Next: Locale Considerations, Previous: Back-references and Subexpressions, Up: sed regular expressions   [Contents][Index]
5.8 Escape Sequences - specifying special characters

Until this chapter, we have only encountered escapes of the form ‘\^’, which tell sed not to interpret the circumflex as a special character, but rather to take it literally. For example, ‘\*’ matches a single asterisk rather than zero or more backslashes.

This chapter introduces another kind of escape6—that is, escapes that are applied to a character or sequence of characters that ordinarily are taken literally, and that sed replaces with a special character. This provides a way of encoding non-printable characters in patterns in a visible manner. There is no restriction on the appearance of non-printing characters in a sed script but when a script is being prepared in the shell or by text editing, it is usually easier to use one of the following escape sequences than the binary character it represents:

The list of these escapes is:

\a

    Produces or matches a BEL character, that is an “alert” (ASCII 7).
\f

    Produces or matches a form feed (ASCII 12).
\n

    Produces or matches a newline (ASCII 10).
\r

    Produces or matches a carriage return (ASCII 13).
\t

    Produces or matches a horizontal tab (ASCII 9).
\v

    Produces or matches a so called “vertical tab” (ASCII 11).
\cx

    Produces or matches CONTROL-x, where x is any character. The precise effect of ‘\cx’ is as follows: if x is a lower case letter, it is converted to upper case. Then bit 6 of the character (hex 40) is inverted. Thus ‘\cz’ becomes hex 1A, but ‘\c{’ becomes hex 3B, while ‘\c;’ becomes hex 7B.
\dxxx

    Produces or matches a character whose decimal ASCII value is xxx.
\oxxx

    Produces or matches a character whose octal ASCII value is xxx.
\xxx

    Produces or matches a character whose hexadecimal ASCII value is xx. 

‘\b’ (backspace) was omitted because of the conflict with the existing “word boundary” meaning.
5.8.1 Escaping Precedence

GNU sed processes escape sequences before passing the text onto the regular-expression matching of the s/// command and Address matching. Thus the follwing two commands are equivalent (‘0x5e’ is the hexadecimal ASCII value of the character ‘^’):

$ echo 'a^c' | sed 's/^/b/'
ba^c

$ echo 'a^c' | sed 's/\x5e/b/'
ba^c

As are the following (‘0x5b’,‘0x5d’ are the hexadecimal ASCII values of ‘[’,‘]’, respectively):

$ echo abc | sed 's/[a]/x/'
Xbc
$ echo abc | sed 's/\x5ba\x5d/x/'
Xbc

However it is recommended to avoid such special characters due to unexpected edge-cases. For example, the following are not equivalent:

$ echo 'a^c' | sed 's/\^/b/'
abc

$ echo 'a^c' | sed 's/\\\x5e/b/'
a^c

Previous: Escapes, Up: sed regular expressions   [Contents][Index]
5.9 Multibyte characters and Locale Considerations

GNU sed processes valid multibyte characters in multibyte locales (e.g. UTF-8). 7

The following example uses the Greek letter Capital Sigma (Σ, Unicode code point 0x03A3). In a UTF-8 locale, sed correctly processes the Sigma as one character despite it being 2 octets (bytes):

$ locale | grep LANG
LANG=en_US.UTF-8

$ printf 'a\u03A3b'
aΣb

$ printf 'a\u03A3b' | sed 's/./X/g'
XXX

$ printf 'a\u03A3b' | od -tx1 -An
 61 ce a3 62

To force sed to process octets separately, use the C locale (also known as the POSIX locale):

$ printf 'a\u03A3b' | LC_ALL=C sed 's/./X/g'
XXXX

5.9.1 Invalid multibyte characters

sed’s regular expressions do not match invalid multibyte sequences in a multibyte locale.

In the following examples, the ascii value 0xCE is an incomplete multibyte character (shown here as �). The regular expression ‘.’ does not match it:

$ printf 'a\xCEb\n'
a�e

$ printf 'a\xCEb\n' | sed 's/./X/g'
X�X

$ printf 'a\xCEc\n' | sed 's/./X/g' | od -tx1c -An
  58  ce  58  0a
   X      X   \n

Similarly, the ’catch-all’ regular expression ‘.*’ does not match the entire line:

$ printf 'a\xCEc\n' | sed 's/.*//' | od -tx1c -An
  ce  63  0a
       c  \n

GNU sed offers the special z command to clear the current pattern space regardless of invalid multibyte characters (i.e. it works like s/.*// but also removes invalid multibyte characters):

$ printf 'a\xCEc\n' | sed 'z' | od -tx1c -An
   0a
   \n

Alternatively, force the C locale to process each octet separately (every octet is a valid character in the C locale):

$ printf 'a\xCEc\n' | LC_ALL=C sed 's/.*//' | od -tx1c -An
  0a
  \n

sed’s inability to process invalid multibyte characters can be used to detect such invalid sequences in a file. In the following examples, the \xCE\xCE is an invalid multibyte sequence, while \xCE\A3 is a valid multibyte sequence (of the Greek Sigma character).

The following sed program removes all valid characters using s/.//g. Any content left in the pattern space (the invalid characters) are added to the hold space using the H command. On the last line ($), the hold space is retrieved (x), newlines are removed (s/\n//g), and any remaining octets are printed unambiguously (l). Thus, any invalid multibyte sequences are printed as octal values:

$ printf 'ab\nc\n\xCE\xCEde\n\xCE\xA3f\n' > invalid.txt

$ cat invalid.txt
ab
c
��de
Σf

$ sed -n 's/.//g ; H ; ${x;s/\n//g;l}' invalid.txt
\316\316$

With a few more commands, sed can print the exact line number corresponding to each invalid characters (line 3). These characters can then be removed by forcing the C locale and using octal escape sequences:

$ sed -n 's/.//g;=;l' invalid.txt | paste - -  | awk '$2!="$"'
3       \316\316$

$ LC_ALL=C sed '3s/\o316\o316//' invalid.txt > fixed.txt

5.9.2 Upper/Lower case conversion

GNU sed’s substitute command (s) supports upper/lower case conversions using \U,\L codes. These conversions support multibyte characters:

$ printf 'ABC\u03a3\n'
ABCΣ

$ printf 'ABC\u03a3\n' | sed 's/.*/\L&/'
abcσ

See The "s" Command.
5.9.3 Multibyte regexp character classes

In other locales, the sorting sequence is not specified, and ‘[a-d]’ might be equivalent to ‘[abcd]’ or to ‘[aBbCcDd]’, or it might fail to match any character, or the set of characters that it matches might even be erratic. To obtain the traditional interpretation of bracket expressions, you can use the ‘C’ locale by setting the LC_ALL environment variable to the value ‘C’.

# TODO: is there any real-world system/locale where 'A'
#       is replaced by '-' ?
$ echo A | sed 's/[a-z]/-/'
A

Their interpretation depends on the LC_CTYPE locale; for example, ‘[[:alnum:]]’ means the character class of numbers and letters in the current locale.

TODO: show example of collation

# TODO: this works on glibc systems, not on musl-libc/freebsd/macosx.
$ printf 'clichÃ©\n' | LC_ALL=fr_FR.utf8 sed 's/[[=e=]]/X/g'
clichX

Next: Examples, Previous: sed regular expressions, Up: Top   [Contents][Index]
6 Advanced sed: cycles and buffers
• Execution Cycle:	  	How sed works
• Hold and Pattern Buffers:	  	
• Multiline techniques:	  	Using D,G,H,N,P to process multiple lines
• Branching and flow control:	  	

Next: Hold and Pattern Buffers, Up: advanced sed   [Contents][Index]
6.1 How sed Works

sed maintains two data buffers: the active pattern space, and the auxiliary hold space. Both are initially empty.

sed operates by performing the following cycle on each line of input: first, sed reads one line from the input stream, removes any trailing newline, and places it in the pattern space. Then commands are executed; each command can have an address associated to it: addresses are a kind of condition code, and a command is only executed if the condition is verified before the command is to be executed.

When the end of the script is reached, unless the -n option is in use, the contents of pattern space are printed out to the output stream, adding back the trailing newline if it was removed.8 Then the next cycle starts for the next input line.

Unless special commands (like ‘D’) are used, the pattern space is deleted between two cycles. The hold space, on the other hand, keeps its data between cycles (see commands ‘h’, ‘H’, ‘x’, ‘g’, ‘G’ to move data between both buffers).

Next: Multiline techniques, Previous: Execution Cycle, Up: advanced sed   [Contents][Index]
6.2 Hold and Pattern Buffers

TODO

Next: Branching and flow control, Previous: Hold and Pattern Buffers, Up: advanced sed   [Contents][Index]
6.3 Multiline techniques - using D,G,H,N,P to process multiple lines

Multiple lines can be processed as one buffer using the D,G,H,N,P. They are similar to their lowercase counterparts (d,g, h,n,p), except that these commands append or subtract data while respecting embedded newlines - allowing adding and removing lines from the pattern and hold spaces.

They operate as follows:

D

    deletes line from the pattern space until the first newline, and restarts the cycle.
G

    appends line from the hold space to the pattern space, with a newline before it.
H

    appends line from the pattern space to the hold space, with a newline before it.
N

    appends line from the input file to the pattern space.
P

    prints line from the pattern space until the first newline.

The following example illustrates the operation of N and D commands:

$ seq 6 | sed -n 'N;l;D'
1\n2$
2\n3$
3\n4$
4\n5$
5\n6$

    sed starts by reading the first line into the pattern space (i.e. ‘1’).
    At the beginning of every cycle, the N command appends a newline and the next line to the pattern space (i.e. ‘1’, ‘\n’, ‘2’ in the first cycle).
    The l command prints the content of the pattern space unambiguously.
    The D command then removes the content of pattern space up to the first newline (leaving ‘2’ at the end of the first cycle).
    At the next cycle the N command appends a newline and the next input line to the pattern space (e.g. ‘2’, ‘\n’, ‘3’). 

A common technique to process blocks of text such as paragraphs (instead of line-by-line) is using the following construct:

sed '/./{H;$!d} ; x ; s/REGEXP/REPLACEMENT/'

    The first expression, /./{H;$!d} operates on all non-empty lines, and adds the current line (in the pattern space) to the hold space. On all lines except the last, the pattern space is deleted and the cycle is restarted.
    The other expressions x and s are executed only on empty lines (i.e. paragraph separators). The x command fetches the accumulated lines from the hold space back to the pattern space. The s/// command then operates on all the text in the paragraph (including the embedded newlines). 

The following example demonstrates this technique:

$ cat input.txt
a a a aa aaa
aaaa aaaa aa
aaaa aaa aaa

bbbb bbb bbb
bb bb bbb bb
bbbbbbbb bbb

ccc ccc cccc
cccc ccccc c
cc cc cc cc

$ sed '/./{H;$!d} ; x ; s/^/\nSTART-->/ ; s/$/\n<--END/' input.txt

START-->
a a a aa aaa
aaaa aaaa aa
aaaa aaa aaa
<--END

START-->
bbbb bbb bbb
bb bb bbb bb
bbbbbbbb bbb
<--END

START-->
ccc ccc cccc
cccc ccccc c
cc cc cc cc
<--END

For more annotated examples, see Text search across multiple lines and Line length adjustment.

Previous: Multiline techniques, Up: advanced sed   [Contents][Index]
6.4 Branching and Flow Control

The branching commands b, t, and T enable changing the flow of sed programs.

By default, sed reads an input line into the pattern buffer, then continues to processes all commands in order. Commands without addresses affect all lines. Commands with addresses affect only matching lines. See Execution Cycle and Addresses overview.

sed does not support a typical if/then construct. Instead, some commands can be used as conditionals or to change the default flow control:

d

    delete (clears) the current pattern space, and restart the program cycle without processing the rest of the commands and without printing the pattern space.
D

    delete the contents of the pattern space up to the first newline, and restart the program cycle without processing the rest of the commands and without printing the pattern space.
[addr]X
[addr]{ X ; X ; X }
/regexp/X
/regexp/{ X ; X ; X }

    Addresses and regular expressions can be used as an if/then conditional: If [addr] matches the current pattern space, execute the command(s). For example: The command /^#/d means: if the current pattern matches the regular expression ^# (a line starting with a hash), then execute the d command: delete the line without printing it, and restart the program cycle immediately.
b

    branch unconditionally (that is: always jump to a label, skipping or repeating other commands, without restarting a new cycle). Combined with an address, the branch can be conditionally executed on matched lines.
t

    branch conditionally (that is: jump to a label) only if a s/// command has succeeded since the last input line was read or another conditional branch was taken.
T

    similar but opposite to the t command: branch only if there has been no successful substitutions since the last input line was read. 

The following two sed programs are equivalent. The first (contrived) example uses the b command to skip the s/// command on lines containing ‘1’. The second example uses an address with negation (‘!’) to perform substitution only on desired lines. The y/// command is still executed on all lines:

$ printf '%s\n' a1 a2 a3 | sed -E '/1/bx ; s/a/z/ ; :x ; y/123/456/'
a4
z5
z6

$ printf '%s\n' a1 a2 a3 | sed -E '/1/!s/a/z/ ; y/123/456/'
a4
z5
z6

6.4.1 Branching and Cycles

The b,t and T commands can be followed by a label (typically a single letter). Labels are defined with a colon followed by one or more letters (e.g. ‘:x’). If the label is omitted the branch commands restart the cycle. Note the difference between branching to a label and restarting the cycle: when a cycle is restarted, sed first prints the current content of the pattern space, then reads the next input line into the pattern space; Jumping to a label (even if it is at the beginning of the program) does not print the pattern space and does not read the next input line.

The following program is a no-op. The b command (the only command in the program) does not have a label, and thus simply restarts the cycle. On each cycle, the pattern space is printed and the next input line is read:

$ seq 3 | sed b
1
2
3

The following example is an infinite-loop - it doesn’t terminate and doesn’t print anything. The b command jumps to the ‘x’ label, and a new cycle is never started:

$ seq 3 | sed ':x ; bx'

# The above command requires gnu sed (which supports additional
# commands following a label, without a newline). A portable equivalent:
#     sed -e ':x' -e bx

Branching is often complemented with the n or N commands: both commands read the next input line into the pattern space without waiting for the cycle to restart. Before reading the next input line, n prints the current pattern space then empties it, while N appends a newline and the next input line to the pattern space.

Consider the following two examples:

$ seq 3 | sed ':x ; n ; bx'
1
2
3

$ seq 3 | sed ':x ; N ; bx'
1
2
3

    Both examples do not inf-loop, despite never starting a new cycle.
    In the first example, the n commands first prints the content of the pattern space, empties the pattern space then reads the next input line.
    In the second example, the N commands appends the next input line to the pattern space (with a newline). Lines are accumulated in the pattern space until there are no more input lines to read, then the N command terminates the sed program. When the program terminates, the end-of-cycle actions are performed, and the entire pattern space is printed.
    The second example requires GNU sed, because it uses the non-POSIX-standard behavior of N. See the “N command on the last line” paragraph in Reporting Bugs.
    To further examine the difference between the two examples, try the following commands:

    printf '%s\n' aa bb cc dd | sed ':x ; n ; = ; bx'
    printf '%s\n' aa bb cc dd | sed ':x ; N ; = ; bx'
    printf '%s\n' aa bb cc dd | sed ':x ; n ; s/\n/***/ ; bx'
    printf '%s\n' aa bb cc dd | sed ':x ; N ; s/\n/***/ ; bx'

6.4.2 Branching example: joining lines

As a real-world example of using branching, consider the case of quoted-printable files, typically used to encode email messages. In these files long lines are split and marked with a soft line break consisting of a single ‘=’ character at the end of the line:

$ cat jaques.txt
All the wor=
ld's a stag=
e,
And all the=
 men and wo=
men merely =
players:
They have t=
heir exits =
and their e=
ntrances;
And one man=
 in his tim=
e plays man=
y parts.

The following program uses an address match ‘/=$/’ as a conditional: If the current pattern space ends with a ‘=’, it reads the next input line using N, replaces all ‘=’ characters which are followed by a newline, and unconditionally branches (b) to the beginning of the program without restarting a new cycle. If the pattern space does not ends with ‘=’, the default action is performed: the pattern space is printed and a new cycle is started:

$ sed ':x ; /=$/ { N ; s/=\n//g ; bx }' jaques.txt
All the world's a stage,
And all the men and women merely players:
They have their exits and their entrances;
And one man in his time plays many parts.

Here’s an alternative program with a slightly different approach: On all lines except the last, N appends the line to the pattern space. A substitution command then removes soft line breaks (‘=’ at the end of a line, i.e. followed by a newline) by replacing them with an empty string. if the substitution was successful (meaning the pattern space contained a line which should be joined), The conditional branch command t jumps to the beginning of the program without completing or restarting the cycle. If the substitution failed (meaning there were no soft line breaks), The t command will not branch. Then, P will print the pattern space content until the first newline, and D will delete the pattern space content until the first new line. (To learn more about N, P and D commands see Multiline techniques).

$ sed ':x ; $!N ; s/=\n// ; tx ; P ; D' jaques.txt
All the world's a stage,
And all the men and women merely players:
They have their exits and their entrances;
And one man in his time plays many parts.

For more line-joining examples see Joining lines.

Next: Limitations, Previous: advanced sed, Up: Top   [Contents][Index]
7 Some Sample Scripts

Here are some sed scripts to guide you in the art of mastering sed.


Useful one-liners:

• Joining lines:	  	


Some exotic examples:

• Centering lines:	  	
• Increment a number:	  	
• Rename files to lower case:	  	
• Print bash environment:	  	
• Reverse chars of lines:	  	
• Text search across multiple lines:	  	
• Line length adjustment:	  	


Emulating standard utilities:

• tac:	  	Reverse lines of files
• cat -n:	  	Numbering lines
• cat -b:	  	Numbering non-blank lines
• wc -c:	  	Counting chars
• wc -w:	  	Counting words
• wc -l:	  	Counting lines
• head:	  	Printing the first lines
• tail:	  	Printing the last lines
• uniq:	  	Make duplicate lines unique
• uniq -d:	  	Print duplicated lines of input
• uniq -u:	  	Remove all duplicated lines
• cat -s:	  	Squeezing blank lines

Next: Centering lines, Up: Examples   [Contents][Index]
7.1 Joining lines

This section uses N, D and P commands to process multiple lines, and the b and t commands for branching. See Multiline techniques and Branching and flow control.

Join specific lines (e.g. if lines 2 and 3 need to be joined):

$ cat lines.txt
hello
hel
lo
hello

$ sed '2{N;s/\n//;}' lines.txt
hello
hello
hello

Join backslash-continued lines:

$ cat 1.txt
this \
is \
a \
long \
line
and another \
line

$ sed -e ':x /\\$/ { N; s/\\\n//g ; bx }'  1.txt
this is a long line
and another line


#TODO: The above requires gnu sed.
#      non-gnu seds need newlines after ':' and 'b'

Join lines that start with whitespace (e.g SMTP headers):

$ cat 2.txt
Subject: Hello
    World
Content-Type: multipart/alternative;
    boundary=94eb2c190cc6370f06054535da6a
Date: Tue, 3 Jan 2017 19:41:16 +0000 (GMT)
Authentication-Results: mx.gnu.org;
       dkim=pass header.i=@gnu.org;
       spf=pass
Message-ID: <abcdef@gnu.org>
From: John Doe <jdoe@gnu.org>
To: Jane Smith <jsmith@gnu.org>

$ sed -E ':a ; $!N ; s/\n\s+/ / ; ta ; P ; D' 2.txt
Subject: Hello World
Content-Type: multipart/alternative; boundary=94eb2c190cc6370f06054535da6a
Date: Tue, 3 Jan 2017 19:41:16 +0000 (GMT)
Authentication-Results: mx.gnu.org; dkim=pass header.i=@gnu.org; spf=pass
Message-ID: <abcdef@gnu.org>
From: John Doe <jdoe@gnu.org>
To: Jane Smith <jsmith@gnu.org>

# A portable (non-gnu) variation:
#   sed -e :a -e '$!N;s/\n  */ /;ta' -e 'P;D'

Next: Increment a number, Previous: Joining lines, Up: Examples   [Contents][Index]
7.2 Centering Lines

This script centers all lines of a file on a 80 columns width. To change that width, the number in \{…\} must be replaced, and the number of added spaces also must be changed.

Note how the buffer commands are used to separate parts in the regular expressions to be matched—this is a common technique.

#!/usr/bin/sed -f

# Put 80 spaces in the buffer
1 {
  x
  s/^$/          /
  s/^.*$/&&&&&&&&/
  x
}


# delete leading and trailing spaces
y/TAB/ /
s/^ *//
s/ *$//


# add a newline and 80 spaces to end of line
G


# keep first 81 chars (80 + a newline)
s/^\(.\{81\}\).*$/\1/


# \2 matches half of the spaces, which are moved to the beginning
s/^\(.*\)\n\(.*\)\2/\2\1/

Next: Rename files to lower case, Previous: Centering lines, Up: Examples   [Contents][Index]
7.3 Increment a Number

This script is one of a few that demonstrate how to do arithmetic in sed. This is indeed possible,9 but must be done manually.

To increment one number you just add 1 to last digit, replacing it by the following digit. There is one exception: when the digit is a nine the previous digits must be also incremented until you don’t have a nine.

This solution by Bruno Haible is very clever and smart because it uses a single buffer; if you don’t have this limitation, the algorithm used in Numbering lines, is faster. It works by replacing trailing nines with an underscore, then using multiple s commands to increment the last digit, and then again substituting underscores with zeros.

#!/usr/bin/sed -f

/[^0-9]/ d

# replace all trailing 9s by _ (any other character except digits, could
# be used)
:d
s/9\(_*\)$/_\1/
td


# incr last digit only.  The first line adds a most-significant
# digit of 1 if we have to add a digit.


s/^\(_*\)$/1\1/; tn
s/8\(_*\)$/9\1/; tn
s/7\(_*\)$/8\1/; tn
s/6\(_*\)$/7\1/; tn
s/5\(_*\)$/6\1/; tn
s/4\(_*\)$/5\1/; tn
s/3\(_*\)$/4\1/; tn
s/2\(_*\)$/3\1/; tn
s/1\(_*\)$/2\1/; tn
s/0\(_*\)$/1\1/; tn


:n
y/_/0/

Next: Print bash environment, Previous: Increment a number, Up: Examples   [Contents][Index]
7.4 Rename Files to Lower Case

This is a pretty strange use of sed. We transform text, and transform it to be shell commands, then just feed them to shell. Don’t worry, even worse hacks are done when using sed; I have seen a script converting the output of date into a bc program!

The main body of this is the sed script, which remaps the name from lower to upper (or vice-versa) and even checks out if the remapped name is the same as the original name. Note how the script is parameterized using shell variables and proper quoting.

#! /bin/sh
# rename files to lower/upper case...
#
# usage:
#    move-to-lower *
#    move-to-upper *
# or
#    move-to-lower -R .
#    move-to-upper -R .
#


help()
{
        cat << eof
Usage: $0 [-n] [-r] [-h] files...


-n      do nothing, only see what would be done
-R      recursive (use find)
-h      this message
files   files to remap to lower case


Examples:
       $0 -n *        (see if everything is ok, then...)
       $0 *


       $0 -R .

eof
}


apply_cmd='sh'
finder='echo "$@" | tr " " "\n"'
files_only=


while :
do
    case "$1" in
        -n) apply_cmd='cat' ;;
        -R) finder='find "$@" -type f';;
        -h) help ; exit 1 ;;
        *) break ;;
    esac
    shift
done


if [ -z "$1" ]; then
        echo Usage: $0 [-h] [-n] [-r] files...
        exit 1
fi


LOWER='abcdefghijklmnopqrstuvwxyz'
UPPER='ABCDEFGHIJKLMNOPQRSTUVWXYZ'


case `basename $0` in
        *upper*) TO=$UPPER; FROM=$LOWER ;;
        *)       FROM=$UPPER; TO=$LOWER ;;
esac


eval $finder | sed -n '

# remove all trailing slashes
s/\/*$//


# add ./ if there is no path, only a filename
/\//! s/^/.\//


# save path+filename
h


# remove path
s/.*\///


# do conversion only on filename
y/'$FROM'/'$TO'/


# now line contains original path+file, while
# hold space contains the new filename
x


# add converted file name to line, which now contains
# path/file-name\nconverted-file-name
G


# check if converted file name is equal to original file name,
# if it is, do not print anything
/^.*\/\(.*\)\n\1/b


# escape special characters for the shell
s/["$`\\]/\\&/g


# now, transform path/fromfile\n, into
# mv path/fromfile path/tofile and print it
s/^\(.*\/\)\(.*\)\n\(.*\)$/mv "\1\2" "\1\3"/p


' | $apply_cmd

Next: Reverse chars of lines, Previous: Rename files to lower case, Up: Examples   [Contents][Index]
7.5 Print bash Environment

This script strips the definition of the shell functions from the output of the set Bourne-shell command.

#!/bin/sh

set | sed -n '
:x


# if no occurrence of ‘=()’ print and load next line
/=()/! { p; b; }
/ () $/! { p; b; }


# possible start of functions section
# save the line in case this is a var like FOO="() "
h


# if the next line has a brace, we quit because
# nothing comes after functions
n
/^{/ q


# print the old line
x; p


# work on the new line now
x; bx
'

Next: Text search across multiple lines, Previous: Print bash environment, Up: Examples   [Contents][Index]
7.6 Reverse Characters of Lines

This script can be used to reverse the position of characters in lines. The technique moves two characters at a time, hence it is faster than more intuitive implementations.

Note the tx command before the definition of the label. This is often needed to reset the flag that is tested by the t command.

Imaginative readers will find uses for this script. An example is reversing the output of banner.10

#!/usr/bin/sed -f

/../! b

# Reverse a line.  Begin embedding the line between two newlines
s/^.*$/\
&\
/


# Move first character at the end.  The regexp matches until
# there are zero or one characters between the markers
tx
:x
s/\(\n.\)\(.*\)\(.\n\)/\3\2\1/
tx


# Remove the newline markers
s/\n//g

Next: Line length adjustment, Previous: Reverse chars of lines, Up: Examples   [Contents][Index]
7.7 Text search across multiple lines

This section uses N and D commands to search for consecutive words spanning multiple lines. See Multiline techniques.

These examples deal with finding doubled occurrences of words in a document.

Finding doubled words in a single line is easy using GNU grep and similarly with GNU sed:

$ cat two-cities-dup1.txt
It was the best of times,
it was the worst of times,
it was the the age of wisdom,
it was the age of foolishness,

$ grep -E '\b(\w+)\s+\1\b' two-cities-dup1.txt
it was the the age of wisdom,

$ grep -n -E '\b(\w+)\s+\1\b' two-cities-dup1.txt
3:it was the the age of wisdom,

$ sed -En '/\b(\w+)\s+\1\b/p' two-cities-dup1.txt
it was the the age of wisdom,

$ sed -En '/\b(\w+)\s+\1\b/{=;p}' two-cities-dup1.txt
3
it was the the age of wisdom,

    The regular expression ‘\b\w+\s+’ searches for word-boundary (‘\b’), followed by one-or-more word-characters (‘\w+’), followed by whitespace (‘\s+’). See regexp extensions.
    Adding parentheses around the ‘(\w+)’ expression creates a subexpression. The regular expression pattern ‘(PATTERN)\s+\1’ defines a subexpression (in the parentheses) followed by a back-reference, separated by whitespace. A successful match means the PATTERN was repeated twice in succession. See Back-references and Subexpressions.
    The word-boundery expression (‘\b’) at both ends ensures partial words are not matched (e.g. ‘the then’ is not a desired match).
    The -E option enables extended regular expression syntax, alleviating the need to add backslashes before the parenthesis. See ERE syntax. 

When the doubled word span two lines the above regular expression will not find them as grep and sed operate line-by-line.

By using N and D commands, sed can apply regular expressions on multiple lines (that is, multiple lines are stored in the pattern space, and the regular expression works on it):

$ cat two-cities-dup2.txt
It was the best of times, it was the
worst of times, it was the
the age of wisdom,
it was the age of foolishness,

$ sed -En '{N; /\b(\w+)\s+\1\b/{=;p} ; D}'  two-cities-dup2.txt
3
worst of times, it was the
the age of wisdom,

    The N command appends the next line to the pattern space (thus ensuring it contains two consecutive lines in every cycle).
    The regular expression uses ‘\s+’ for word separator which matches both spaces and newlines.
    The regular expression matches, the entire pattern space is printed with p. No lines are printed by default due to the -n option.
    The D removes the first line from the pattern space (up until the first newline), readying it for the next cycle. 

See the GNU coreutils manual for an alternative solution using tr -s and uniq at https://gnu.org/s/coreutils/manual/html_node/Squeezing-and-deleting.html.

Next: tac, Previous: Text search across multiple lines, Up: Examples   [Contents][Index]
7.8 Line length adjustment

This section uses N and D commands to search for consecutive words spanning multiple lines, and the b command for branching. See Multiline techniques and Branching and flow control.

This (somewhat contrived) example deal with formatting and wrapping lines of text of the following input file:

$ cat two-cities-mix.txt
It was the best of times, it was
the worst of times, it
was the age of
wisdom,
it
was
the age
of foolishness,

The following sed program wraps lines at 40 characters:

$ cat wrap40.sed
# outer loop
:x

# Appead a newline followed by the next input line to the pattern buffer
N

# Remove all newlines from the pattern buffer
s/\n/ /g


# Inner loop
:y

# Add a newline after the first 40 characters
s/(.{40,40})/\1\n/

# If there is a newline in the pattern buffer
# (i.e. the previous substitution added a newline)
/\n/ {
    # There are newlines in the pattern buffer -
    # print the content until the first newline.
    P

   # Remove the printed characters and the first newline
   s/.*\n//

   # branch to label 'y' - repeat inner loop
   by
 }

# No newlines in the pattern buffer - Branch to label 'x' (outer loop)
# and read the next input line
bx

The wrapped output:

$ sed -E -f wrap40.sed two-cities-mix.txt
It was the best of times, it was the wor
st of times, it was the age of wisdom, i
t was the age of foolishness,

Next: cat -n, Previous: Line length adjustment, Up: Examples   [Contents][Index]
7.9 Reverse Lines of Files

This one begins a series of totally useless (yet interesting) scripts emulating various Unix commands. This, in particular, is a tac workalike.

Note that on implementations other than GNU sed this script might easily overflow internal buffers.

#!/usr/bin/sed -nf

# reverse all lines of input, i.e. first line became last, ...

# from the second line, the buffer (which contains all previous lines)
# is *appended* to current line, so, the order will be reversed
1! G


# on the last line we're done -- print everything
$ p


# store everything on the buffer again
h

Next: cat -b, Previous: tac, Up: Examples   [Contents][Index]
7.10 Numbering Lines

This script replaces ‘cat -n’; in fact it formats its output exactly like GNU cat does.

Of course this is completely useless and for two reasons: first, because somebody else did it in C, second, because the following Bourne-shell script could be used for the same purpose and would be much faster:

#! /bin/sh
sed -e "=" $@ | sed -e '
  s/^/      /
  N
  s/^ *\(......\)\n/\1  /
'

It uses sed to print the line number, then groups lines two by two using N. Of course, this script does not teach as much as the one presented below.

The algorithm used for incrementing uses both buffers, so the line is printed as soon as possible and then discarded. The number is split so that changing digits go in a buffer and unchanged ones go in the other; the changed digits are modified in a single step (using a y command). The line number for the next line is then composed and stored in the hold space, to be used in the next iteration.

#!/usr/bin/sed -nf

# Prime the pump on the first line
x
/^$/ s/^.*$/1/


# Add the correct line number before the pattern
G
h


# Format it and print it
s/^/      /
s/^ *\(......\)\n/\1  /p


# Get the line number from hold space; add a zero
# if we're going to add a digit on the next line
g
s/\n.*$//
/^9*$/ s/^/0/


# separate changing/unchanged digits with an x
s/.9*$/x&/


# keep changing digits in hold space
h
s/^.*x//
y/0123456789/1234567890/
x


# keep unchanged digits in pattern space
s/x.*$//


# compose the new number, remove the newline implicitly added by G
G
s/\n//
h

Next: wc -c, Previous: cat -n, Up: Examples   [Contents][Index]
7.11 Numbering Non-blank Lines

Emulating ‘cat -b’ is almost the same as ‘cat -n’—we only have to select which lines are to be numbered and which are not.

The part that is common to this script and the previous one is not commented to show how important it is to comment sed scripts properly...

#!/usr/bin/sed -nf

/^$/ {
  p
  b
}


# Same as cat -n from now
x
/^$/ s/^.*$/1/
G
h
s/^/      /
s/^ *\(......\)\n/\1  /p
x
s/\n.*$//
/^9*$/ s/^/0/
s/.9*$/x&/
h
s/^.*x//
y/0123456789/1234567890/
x
s/x.*$//
G
s/\n//
h

Next: wc -w, Previous: cat -b, Up: Examples   [Contents][Index]
7.12 Counting Characters

This script shows another way to do arithmetic with sed. In this case we have to add possibly large numbers, so implementing this by successive increments would not be feasible (and possibly even more complicated to contrive than this script).

The approach is to map numbers to letters, kind of an abacus implemented with sed. ‘a’s are units, ‘b’s are tens and so on: we simply add the number of characters on the current line as units, and then propagate the carry to tens, hundreds, and so on.

As usual, running totals are kept in hold space.

On the last line, we convert the abacus form back to decimal. For the sake of variety, this is done with a loop rather than with some 80 s commands11: first we convert units, removing ‘a’s from the number; then we rotate letters so that tens become ‘a’s, and so on until no more letters remain.

#!/usr/bin/sed -nf

# Add n+1 a's to hold space (+1 is for the newline)
s/./a/g
H
x
s/\n/a/


# Do the carry.  The t's and b's are not necessary,
# but they do speed up the thing
t a
: a;  s/aaaaaaaaaa/b/g; t b; b done
: b;  s/bbbbbbbbbb/c/g; t c; b done
: c;  s/cccccccccc/d/g; t d; b done
: d;  s/dddddddddd/e/g; t e; b done
: e;  s/eeeeeeeeee/f/g; t f; b done
: f;  s/ffffffffff/g/g; t g; b done
: g;  s/gggggggggg/h/g; t h; b done
: h;  s/hhhhhhhhhh//g


: done
$! {
  h
  b
}


# On the last line, convert back to decimal

: loop
/a/! s/[b-h]*/&0/
s/aaaaaaaaa/9/
s/aaaaaaaa/8/
s/aaaaaaa/7/
s/aaaaaa/6/
s/aaaaa/5/
s/aaaa/4/
s/aaa/3/
s/aa/2/
s/a/1/


: next
y/bcdefgh/abcdefg/
/[a-h]/ b loop
p

Next: wc -l, Previous: wc -c, Up: Examples   [Contents][Index]
7.13 Counting Words

This script is almost the same as the previous one, once each of the words on the line is converted to a single ‘a’ (in the previous script each letter was changed to an ‘a’).

It is interesting that real wc programs have optimized loops for ‘wc -c’, so they are much slower at counting words rather than characters. This script’s bottleneck, instead, is arithmetic, and hence the word-counting one is faster (it has to manage smaller numbers).

Again, the common parts are not commented to show the importance of commenting sed scripts.

#!/usr/bin/sed -nf

# Convert words to a's
s/[ TAB][ TAB]*/ /g
s/^/ /
s/ [^ ][^ ]*/a /g
s/ //g


# Append them to hold space
H
x
s/\n//


# From here on it is the same as in wc -c.
/aaaaaaaaaa/! bx;   s/aaaaaaaaaa/b/g
/bbbbbbbbbb/! bx;   s/bbbbbbbbbb/c/g
/cccccccccc/! bx;   s/cccccccccc/d/g
/dddddddddd/! bx;   s/dddddddddd/e/g
/eeeeeeeeee/! bx;   s/eeeeeeeeee/f/g
/ffffffffff/! bx;   s/ffffffffff/g/g
/gggggggggg/! bx;   s/gggggggggg/h/g
s/hhhhhhhhhh//g
:x
$! { h; b; }
:y
/a/! s/[b-h]*/&0/
s/aaaaaaaaa/9/
s/aaaaaaaa/8/
s/aaaaaaa/7/
s/aaaaaa/6/
s/aaaaa/5/
s/aaaa/4/
s/aaa/3/
s/aa/2/
s/a/1/
y/bcdefgh/abcdefg/
/[a-h]/ by
p

Next: head, Previous: wc -w, Up: Examples   [Contents][Index]
7.14 Counting Lines

No strange things are done now, because sed gives us ‘wc -l’ functionality for free!!! Look:

#!/usr/bin/sed -nf
$=

Next: tail, Previous: wc -l, Up: Examples   [Contents][Index]
7.15 Printing the First Lines

This script is probably the simplest useful sed script. It displays the first 10 lines of input; the number of displayed lines is right before the q command.

#!/usr/bin/sed -f
10q

Next: uniq, Previous: head, Up: Examples   [Contents][Index]
7.16 Printing the Last Lines

Printing the last n lines rather than the first is more complex but indeed possible. n is encoded in the second line, before the bang character.

This script is similar to the tac script in that it keeps the final output in the hold space and prints it at the end:

#!/usr/bin/sed -nf

1! {; H; g; }
1,10 !s/[^\n]*\n//
$p
h

Mainly, the scripts keeps a window of 10 lines and slides it by adding a line and deleting the oldest (the substitution command on the second line works like a D command but does not restart the loop).

The “sliding window” technique is a very powerful way to write efficient and complex sed scripts, because commands like P would require a lot of work if implemented manually.

To introduce the technique, which is fully demonstrated in the rest of this chapter and is based on the N, P and D commands, here is an implementation of tail using a simple “sliding window.”

This looks complicated but in fact the working is the same as the last script: after we have kicked in the appropriate number of lines, however, we stop using the hold space to keep inter-line state, and instead use N and D to slide pattern space by one line:

#!/usr/bin/sed -f

1h
2,10 {; H; g; }
$q
1,9d
N
D

Note how the first, second and fourth line are inactive after the first ten lines of input. After that, all the script does is: exiting on the last line of input, appending the next input line to pattern space, and removing the first line.

Next: uniq -d, Previous: tail, Up: Examples   [Contents][Index]
7.17 Make Duplicate Lines Unique

This is an example of the art of using the N, P and D commands, probably the most difficult to master.

#!/usr/bin/sed -f
h


:b
# On the last line, print and exit
$b
N
/^\(.*\)\n\1$/ {
    # The two lines are identical.  Undo the effect of
    # the n command.
    g
    bb
}


# If the N command had added the last line, print and exit
$b


# The lines are different; print the first and go
# back working on the second.
P
D

As you can see, we maintain a 2-line window using P and D. This technique is often used in advanced sed scripts.

Next: uniq -u, Previous: uniq, Up: Examples   [Contents][Index]
7.18 Print Duplicated Lines of Input

This script prints only duplicated lines, like ‘uniq -d’.

#!/usr/bin/sed -nf

$b
N
/^\(.*\)\n\1$/ {
    # Print the first of the duplicated lines
    s/.*\n//
    p


    # Loop until we get a different line
    :b
    $b
    N
    /^\(.*\)\n\1$/ {
        s/.*\n//
        bb
    }
}


# The last line cannot be followed by duplicates
$b


# Found a different one.  Leave it alone in the pattern space
# and go back to the top, hunting its duplicates
D

Next: cat -s, Previous: uniq -d, Up: Examples   [Contents][Index]
7.19 Remove All Duplicated Lines

This script prints only unique lines, like ‘uniq -u’.

#!/usr/bin/sed -f

# Search for a duplicate line --- until that, print what you find.
$b
N
/^\(.*\)\n\1$/ ! {
    P
    D
}


:c
# Got two equal lines in pattern space.  At the
# end of the file we simply exit
$d


# Else, we keep reading lines with N until we
# find a different one
s/.*\n//
N
/^\(.*\)\n\1$/ {
    bc
}


# Remove the last instance of the duplicate line
# and go back to the top
D

Previous: uniq -u, Up: Examples   [Contents][Index]
7.20 Squeezing Blank Lines

As a final example, here are three scripts, of increasing complexity and speed, that implement the same function as ‘cat -s’, that is squeezing blank lines.

The first leaves a blank line at the beginning and end if there are some already.

#!/usr/bin/sed -f

# on empty lines, join with next
# Note there is a star in the regexp
:x
/^\n*$/ {
N
bx
}


# now, squeeze all '\n', this can be also done by:
# s/^\(\n\)*/\1/
s/\n*/\
/

This one is a bit more complex and removes all empty lines at the beginning. It does leave a single blank line at end if one was there.

#!/usr/bin/sed -f

# delete all leading empty lines
1,/^./{
/./!d
}


# on an empty line we remove it and all the following
# empty lines, but one
:x
/./!{
N
s/^\n$//
tx
}

This removes leading and trailing blank lines. It is also the fastest. Note that loops are completely done with n and b, without relying on sed to restart the script automatically at the end of a line.

#!/usr/bin/sed -nf

# delete all (leading) blanks
/./!d


# get here: so there is a non empty
:x
# print it
p
# get next
n
# got chars? print it again, etc...
/./bx


# no, don't have chars: got an empty line
:z
# get next, if last line we finish here so no trailing
# empty lines are written
n
# also empty? then ignore it, and get next... this will
# remove ALL empty lines
/./!bz


# all empty lines were deleted/ignored, but we have a non empty.  As
# what we want to do is to squeeze, insert a blank line artificially
i\


bx

Next: Other Resources, Previous: Examples, Up: Top   [Contents][Index]
8 GNU sed’s Limitations and Non-limitations

For those who want to write portable sed scripts, be aware that some implementations have been known to limit line lengths (for the pattern and hold spaces) to be no more than 4000 bytes. The POSIX standard specifies that conforming sed implementations shall support at least 8192 byte line lengths. GNU sed has no built-in limit on line length; as long as it can malloc() more (virtual) memory, you can feed or construct lines as long as you like.

However, recursion is used to handle subpatterns and indefinite repetition. This means that the available stack space may limit the size of the buffer that can be processed by certain patterns.

Next: Reporting Bugs, Previous: Limitations, Up: Top   [Contents][Index]
9 Other Resources for Learning About sed

For up to date information about GNU sed please visit https://www.gnu.org/software/sed/.

Send general questions and suggestions to sed-devel@gnu.org. Visit the mailing list archives for past discussions at https://lists.gnu.org/archive/html/sed-devel/.

The following resources provide information about sed (both GNU sed and other variations). Note these not maintained by GNU sed developers.

    sed $HOME: http://sed.sf.net
    sed FAQ: http://sed.sf.net/sedfaq.html
    seder’s grabbag: http://sed.sf.net/grabbag
    The sed-users mailing list maintained by Sven Guckes: http://groups.yahoo.com/group/sed-users/ (note this is not the GNU sed mailing list). 

Next: GNU Free Documentation License, Previous: Other Resources, Up: Top   [Contents][Index]
10 Reporting Bugs

Email bug reports to bug-sed@gnu.org. Also, please include the output of ‘sed --version’ in the body of your report if at all possible.

Please do not send a bug report like this:

while building frobme-1.3.4
$ configure
error→ sed: file sedscr line 1: Unknown option to 's'

If GNU sed doesn’t configure your favorite package, take a few extra minutes to identify the specific problem and make a stand-alone test case. Unlike other programs such as C compilers, making such test cases for sed is quite simple.

A stand-alone test case includes all the data necessary to perform the test, and the specific invocation of sed that causes the problem. The smaller a stand-alone test case is, the better. A test case should not involve something as far removed from sed as “try to configure frobme-1.3.4”. Yes, that is in principle enough information to look for the bug, but that is not a very practical prospect.

Here are a few commonly reported bugs that are not bugs.

N command on the last line

    Most versions of sed exit without printing anything when the N command is issued on the last line of a file. GNU sed prints pattern space before exiting unless of course the -n command switch has been specified. This choice is by design.

    Default behavior (gnu extension, non-POSIX conforming):

    $ seq 3 | sed N
    1
    2
    3

    To force POSIX-conforming behavior:

    $ seq 3 | sed --posix N
    1
    2

    For example, the behavior of

    sed N foo bar

    would depend on whether foo has an even or an odd number of lines12. Or, when writing a script to read the next few lines following a pattern match, traditional implementations of sed would force you to write something like

    /foo/{ $!N; $!N; $!N; $!N; $!N; $!N; $!N; $!N; $!N }

    instead of just

    /foo/{ N;N;N;N;N;N;N;N;N; }

    In any case, the simplest workaround is to use $d;N in scripts that rely on the traditional behavior, or to set the POSIXLY_CORRECT variable to a non-empty value.
Regex syntax clashes (problems with backslashes)

    sed uses the POSIX basic regular expression syntax. According to the standard, the meaning of some escape sequences is undefined in this syntax; notable in the case of sed are \|, \+, \?, \`, \', \<, \>, \b, \B, \w, and \W.

    As in all GNU programs that use POSIX basic regular expressions, sed interprets these escape sequences as special characters. So, x\+ matches one or more occurrences of ‘x’. abc\|def matches either ‘abc’ or ‘def’.

    This syntax may cause problems when running scripts written for other seds. Some sed programs have been written with the assumption that \| and \+ match the literal characters | and +. Such scripts must be modified by removing the spurious backslashes if they are to be used with modern implementations of sed, like GNU sed.

    On the other hand, some scripts use s|abc\|def||g to remove occurrences of either abc or def. While this worked until sed 4.0.x, newer versions interpret this as removing the string abc|def. This is again undefined behavior according to POSIX, and this interpretation is arguably more robust: older seds, for example, required that the regex matcher parsed \/ as / in the common case of escaping a slash, which is again undefined behavior; the new behavior avoids this, and this is good because the regex matcher is only partially under our control.

    In addition, this version of sed supports several escape characters (some of which are multi-character) to insert non-printable characters in scripts (\a, \c, \d, \o, \r, \t, \v, \x). These can cause similar problems with scripts written for other seds.
-i clobbers read-only files

    In short, ‘sed -i’ will let you delete the contents of a read-only file, and in general the -i option (see Invocation) lets you clobber protected files. This is not a bug, but rather a consequence of how the Unix file system works.

    The permissions on a file say what can happen to the data in that file, while the permissions on a directory say what can happen to the list of files in that directory. ‘sed -i’ will not ever open for writing a file that is already on disk. Rather, it will work on a temporary file that is finally renamed to the original name: if you rename or delete files, you’re actually modifying the contents of the directory, so the operation depends on the permissions of the directory, not of the file. For this same reason, sed does not let you use -i on a writable file in a read-only directory, and will break hard or symbolic links when -i is used on such a file.
0a does not work (gives an error)

    There is no line 0. 0 is a special address that is only used to treat addresses like 0,/RE/ as active when the script starts: if you write 1,/abc/d and the first line includes the word ‘abc’, then that match would be ignored because address ranges must span at least two lines (barring the end of the file); but what you probably wanted is to delete every line up to the first one including ‘abc’, and this is obtained with 0,/abc/d.
[a-z] is case insensitive

    You are encountering problems with locales. POSIX mandates that [a-z] uses the current locale’s collation order – in C parlance, that means using strcoll(3) instead of strcmp(3). Some locales have a case-insensitive collation order, others don’t.

    Another problem is that [a-z] tries to use collation symbols. This only happens if you are on the GNU system, using GNU libc’s regular expression matcher instead of compiling the one supplied with GNU sed. In a Danish locale, for example, the regular expression ^[a-z]$ matches the string ‘aa’, because this is a single collating symbol that comes after ‘a’ and before ‘b’; ‘ll’ behaves similarly in Spanish locales, or ‘ij’ in Dutch locales.

    To work around these problems, which may cause bugs in shell scripts, set the LC_COLLATE and LC_CTYPE environment variables to ‘C’.
s/.*// does not clear pattern space

    This happens if your input stream includes invalid multibyte sequences. POSIX mandates that such sequences are not matched by ‘.’, so that ‘s/.*//’ will not clear pattern space as you would expect. In fact, there is no way to clear sed’s buffers in the middle of the script in most multibyte locales (including UTF-8 locales). For this reason, GNU sed provides a ‘z’ command (for ‘zap’) as an extension.

    To work around these problems, which may cause bugs in shell scripts, set the LC_COLLATE and LC_CTYPE environment variables to ‘C’. 

Next: Concept Index, Previous: Reporting Bugs, Up: Top   [Contents][Index]
Appendix A GNU Free Documentation License
Version 1.3, 3 November 2008

Copyright © 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
https://fsf.org/

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.

    PREAMBLE

    The purpose of this License is to make a manual, textbook, or other functional and useful document free in the sense of freedom: to assure everyone the effective freedom to copy and redistribute it, with or without modifying it, either commercially or noncommercially. Secondarily, this License preserves for the author and publisher a way to get credit for their work, while not being considered responsible for modifications made by others.

    This License is a kind of “copyleft”, which means that derivative works of the document must themselves be free in the same sense. It complements the GNU General Public License, which is a copyleft license designed for free software.

    We have designed this License in order to use it for manuals for free software, because free software needs free documentation: a free program should come with manuals providing the same freedoms that the software does. But this License is not limited to software manuals; it can be used for any textual work, regardless of subject matter or whether it is published as a printed book. We recommend this License principally for works whose purpose is instruction or reference.
    APPLICABILITY AND DEFINITIONS

    This License applies to any manual or other work, in any medium, that contains a notice placed by the copyright holder saying it can be distributed under the terms of this License. Such a notice grants a world-wide, royalty-free license, unlimited in duration, to use that work under the conditions stated herein. The “Document”, below, refers to any such manual or work. Any member of the public is a licensee, and is addressed as “you”. You accept the license if you copy, modify or distribute the work in a way requiring permission under copyright law.

    A “Modified Version” of the Document means any work containing the Document or a portion of it, either copied verbatim, or with modifications and/or translated into another language.

    A “Secondary Section” is a named appendix or a front-matter section of the Document that deals exclusively with the relationship of the publishers or authors of the Document to the Document’s overall subject (or to related matters) and contains nothing that could fall directly within that overall subject. (Thus, if the Document is in part a textbook of mathematics, a Secondary Section may not explain any mathematics.) The relationship could be a matter of historical connection with the subject or with related matters, or of legal, commercial, philosophical, ethical or political position regarding them.

    The “Invariant Sections” are certain Secondary Sections whose titles are designated, as being those of Invariant Sections, in the notice that says that the Document is released under this License. If a section does not fit the above definition of Secondary then it is not allowed to be designated as Invariant. The Document may contain zero Invariant Sections. If the Document does not identify any Invariant Sections then there are none.

    The “Cover Texts” are certain short passages of text that are listed, as Front-Cover Texts or Back-Cover Texts, in the notice that says that the Document is released under this License. A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at most 25 words.

    A “Transparent” copy of the Document means a machine-readable copy, represented in a format whose specification is available to the general public, that is suitable for revising the document straightforwardly with generic text editors or (for images composed of pixels) generic paint programs or (for drawings) some widely available drawing editor, and that is suitable for input to text formatters or for automatic translation to a variety of formats suitable for input to text formatters. A copy made in an otherwise Transparent file format whose markup, or absence of markup, has been arranged to thwart or discourage subsequent modification by readers is not Transparent. An image format is not Transparent if used for any substantial amount of text. A copy that is not “Transparent” is called “Opaque”.

    Examples of suitable formats for Transparent copies include plain ASCII without markup, Texinfo input format, LaTeX input format, SGML or XML using a publicly available DTD, and standard-conforming simple HTML, PostScript or PDF designed for human modification. Examples of transparent image formats include PNG, XCF and JPG. Opaque formats include proprietary formats that can be read and edited only by proprietary word processors, SGML or XML for which the DTD and/or processing tools are not generally available, and the machine-generated HTML, PostScript or PDF produced by some word processors for output purposes only.

    The “Title Page” means, for a printed book, the title page itself, plus such following pages as are needed to hold, legibly, the material this License requires to appear in the title page. For works in formats which do not have any title page as such, “Title Page” means the text near the most prominent appearance of the work’s title, preceding the beginning of the body of the text.

    The “publisher” means any person or entity that distributes copies of the Document to the public.

    A section “Entitled XYZ” means a named subunit of the Document whose title either is precisely XYZ or contains XYZ in parentheses following text that translates XYZ in another language. (Here XYZ stands for a specific section name mentioned below, such as “Acknowledgements”, “Dedications”, “Endorsements”, or “History”.) To “Preserve the Title” of such a section when you modify the Document means that it remains a section “Entitled XYZ” according to this definition.

    The Document may include Warranty Disclaimers next to the notice which states that this License applies to the Document. These Warranty Disclaimers are considered to be included by reference in this License, but only as regards disclaiming warranties: any other implication that these Warranty Disclaimers may have is void and has no effect on the meaning of this License.
    VERBATIM COPYING

    You may copy and distribute the Document in any medium, either commercially or noncommercially, provided that this License, the copyright notices, and the license notice saying this License applies to the Document are reproduced in all copies, and that you add no other conditions whatsoever to those of this License. You may not use technical measures to obstruct or control the reading or further copying of the copies you make or distribute. However, you may accept compensation in exchange for copies. If you distribute a large enough number of copies you must also follow the conditions in section 3.

    You may also lend copies, under the same conditions stated above, and you may publicly display copies.
    COPYING IN QUANTITY

    If you publish printed copies (or copies in media that commonly have printed covers) of the Document, numbering more than 100, and the Document’s license notice requires Cover Texts, you must enclose the copies in covers that carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on the back cover. Both covers must also clearly and legibly identify you as the publisher of these copies. The front cover must present the full title with all words of the title equally prominent and visible. You may add other material on the covers in addition. Copying with changes limited to the covers, as long as they preserve the title of the Document and satisfy these conditions, can be treated as verbatim copying in other respects.

    If the required texts for either cover are too voluminous to fit legibly, you should put the first ones listed (as many as fit reasonably) on the actual cover, and continue the rest onto adjacent pages.

    If you publish or distribute Opaque copies of the Document numbering more than 100, you must either include a machine-readable Transparent copy along with each Opaque copy, or state in or with each Opaque copy a computer-network location from which the general network-using public has access to download using public-standard network protocols a complete Transparent copy of the Document, free of added material. If you use the latter option, you must take reasonably prudent steps, when you begin distribution of Opaque copies in quantity, to ensure that this Transparent copy will remain thus accessible at the stated location until at least one year after the last time you distribute an Opaque copy (directly or through your agents or retailers) of that edition to the public.

    It is requested, but not required, that you contact the authors of the Document well before redistributing any large number of copies, to give them a chance to provide you with an updated version of the Document.
    MODIFICATIONS

    You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3 above, provided that you release the Modified Version under precisely this License, with the Modified Version filling the role of the Document, thus licensing distribution and modification of the Modified Version to whoever possesses a copy of it. In addition, you must do these things in the Modified Version:
        Use in the Title Page (and on the covers, if any) a title distinct from that of the Document, and from those of previous versions (which should, if there were any, be listed in the History section of the Document). You may use the same title as a previous version if the original publisher of that version gives permission.
        List on the Title Page, as authors, one or more persons or entities responsible for authorship of the modifications in the Modified Version, together with at least five of the principal authors of the Document (all of its principal authors, if it has fewer than five), unless they release you from this requirement.
        State on the Title page the name of the publisher of the Modified Version, as the publisher.
        Preserve all the copyright notices of the Document.
        Add an appropriate copyright notice for your modifications adjacent to the other copyright notices.
        Include, immediately after the copyright notices, a license notice giving the public permission to use the Modified Version under the terms of this License, in the form shown in the Addendum below.
        Preserve in that license notice the full lists of Invariant Sections and required Cover Texts given in the Document’s license notice.
        Include an unaltered copy of this License.
        Preserve the section Entitled “History”, Preserve its Title, and add to it an item stating at least the title, year, new authors, and publisher of the Modified Version as given on the Title Page. If there is no section Entitled “History” in the Document, create one stating the title, year, authors, and publisher of the Document as given on its Title Page, then add an item describing the Modified Version as stated in the previous sentence.
        Preserve the network location, if any, given in the Document for public access to a Transparent copy of the Document, and likewise the network locations given in the Document for previous versions it was based on. These may be placed in the “History” section. You may omit a network location for a work that was published at least four years before the Document itself, or if the original publisher of the version it refers to gives permission.
        For any section Entitled “Acknowledgements” or “Dedications”, Preserve the Title of the section, and preserve in the section all the substance and tone of each of the contributor acknowledgements and/or dedications given therein.
        Preserve all the Invariant Sections of the Document, unaltered in their text and in their titles. Section numbers or the equivalent are not considered part of the section titles.
        Delete any section Entitled “Endorsements”. Such a section may not be included in the Modified Version.
        Do not retitle any existing section to be Entitled “Endorsements” or to conflict in title with any Invariant Section.
        Preserve any Warranty Disclaimers. 

    If the Modified Version includes new front-matter sections or appendices that qualify as Secondary Sections and contain no material copied from the Document, you may at your option designate some or all of these sections as invariant. To do this, add their titles to the list of Invariant Sections in the Modified Version’s license notice. These titles must be distinct from any other section titles.

    You may add a section Entitled “Endorsements”, provided it contains nothing but endorsements of your Modified Version by various parties—for example, statements of peer review or that the text has been approved by an organization as the authoritative definition of a standard.

    You may add a passage of up to five words as a Front-Cover Text, and a passage of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modified Version. Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or through arrangements made by) any one entity. If the Document already includes a cover text for the same cover, previously added by you or by arrangement made by the same entity you are acting on behalf of, you may not add another; but you may replace the old one, on explicit permission from the previous publisher that added the old one.

    The author(s) and publisher(s) of the Document do not by this License give permission to use their names for publicity for or to assert or imply endorsement of any Modified Version.
    COMBINING DOCUMENTS

    You may combine the Document with other documents released under this License, under the terms defined in section 4 above for modified versions, provided that you include in the combination all of the Invariant Sections of all of the original documents, unmodified, and list them all as Invariant Sections of your combined work in its license notice, and that you preserve all their Warranty Disclaimers.

    The combined work need only contain one copy of this License, and multiple identical Invariant Sections may be replaced with a single copy. If there are multiple Invariant Sections with the same name but different contents, make the title of each such section unique by adding at the end of it, in parentheses, the name of the original author or publisher of that section if known, or else a unique number. Make the same adjustment to the section titles in the list of Invariant Sections in the license notice of the combined work.

    In the combination, you must combine any sections Entitled “History” in the various original documents, forming one section Entitled “History”; likewise combine any sections Entitled “Acknowledgements”, and any sections Entitled “Dedications”. You must delete all sections Entitled “Endorsements.”
    COLLECTIONS OF DOCUMENTS

    You may make a collection consisting of the Document and other documents released under this License, and replace the individual copies of this License in the various documents with a single copy that is included in the collection, provided that you follow the rules of this License for verbatim copying of each of the documents in all other respects.

    You may extract a single document from such a collection, and distribute it individually under this License, provided you insert a copy of this License into the extracted document, and follow this License in all other respects regarding verbatim copying of that document.
    AGGREGATION WITH INDEPENDENT WORKS

    A compilation of the Document or its derivatives with other separate and independent documents or works, in or on a volume of a storage or distribution medium, is called an “aggregate” if the copyright resulting from the compilation is not used to limit the legal rights of the compilation’s users beyond what the individual works permit. When the Document is included in an aggregate, this License does not apply to the other works in the aggregate which are not themselves derivative works of the Document.

    If the Cover Text requirement of section 3 is applicable to these copies of the Document, then if the Document is less than one half of the entire aggregate, the Document’s Cover Texts may be placed on covers that bracket the Document within the aggregate, or the electronic equivalent of covers if the Document is in electronic form. Otherwise they must appear on printed covers that bracket the whole aggregate.
    TRANSLATION

    Translation is considered a kind of modification, so you may distribute translations of the Document under the terms of section 4. Replacing Invariant Sections with translations requires special permission from their copyright holders, but you may include translations of some or all Invariant Sections in addition to the original versions of these Invariant Sections. You may include a translation of this License, and all the license notices in the Document, and any Warranty Disclaimers, provided that you also include the original English version of this License and the original versions of those notices and disclaimers. In case of a disagreement between the translation and the original version of this License or a notice or disclaimer, the original version will prevail.

    If a section in the Document is Entitled “Acknowledgements”, “Dedications”, or “History”, the requirement (section 4) to Preserve its Title (section 1) will typically require changing the actual title.
    TERMINATION

    You may not copy, modify, sublicense, or distribute the Document except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense, or distribute it is void, and will automatically terminate your rights under this License.

    However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation.

    Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice.

    Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, receipt of a copy of some or all of the same material does not give you any rights to use it.
    FUTURE REVISIONS OF THIS LICENSE

    The Free Software Foundation may publish new, revised versions of the GNU Free Documentation License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. See https://www.gnu.org/copyleft/.

    Each version of the License is given a distinguishing version number. If the Document specifies that a particular numbered version of this License “or any later version” applies to it, you have the option of following the terms and conditions either of that specified version or of any later version that has been published (not as a draft) by the Free Software Foundation. If the Document does not specify a version number of this License, you may choose any version ever published (not as a draft) by the Free Software Foundation. If the Document specifies that a proxy can decide which future versions of this License can be used, that proxy’s public statement of acceptance of a version permanently authorizes you to choose that version for the Document.
    RELICENSING

    “Massive Multiauthor Collaboration Site” (or “MMC Site”) means any World Wide Web server that publishes copyrightable works and also provides prominent facilities for anybody to edit those works. A public wiki that anybody can edit is an example of such a server. A “Massive Multiauthor Collaboration” (or “MMC”) contained in the site means any set of copyrightable works thus published on the MMC site.

    “CC-BY-SA” means the Creative Commons Attribution-Share Alike 3.0 license published by Creative Commons Corporation, a not-for-profit corporation with a principal place of business in San Francisco, California, as well as future copyleft versions of that license published by that same organization.

    “Incorporate” means to publish or republish a Document, in whole or in part, as part of another Document.

    An MMC is “eligible for relicensing” if it is licensed under this License, and if all works that were first published under this License somewhere other than this MMC, and subsequently incorporated in whole or in part into the MMC, (1) had no cover texts or invariant sections, and (2) were thus incorporated prior to November 1, 2008.

    The operator of an MMC Site may republish an MMC contained in the site under CC-BY-SA on the same site at any time before August 1, 2009, provided the MMC is eligible for relicensing.

ADDENDUM: How to use this License for your documents

To use this License in a document you have written, include a copy of the License in the document and put the following copyright and license notices just after the title page:

  Copyright (C)  year  your name.
  Permission is granted to copy, distribute and/or modify this document
  under the terms of the GNU Free Documentation License, Version 1.3
  or any later version published by the Free Software Foundation;
  with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
  Texts.  A copy of the license is included in the section entitled ``GNU
  Free Documentation License''.

If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts, replace the “with…Texts.” line with this:

    with the Invariant Sections being list their titles, with
    the Front-Cover Texts being list, and with the Back-Cover Texts
    being list.

If you have Invariant Sections without Cover Texts, or some other combination of the three, merge those two alternatives to suit the situation.

If your document contains nontrivial examples of program code, we recommend releasing these examples in parallel under your choice of free software license, such as the GNU General Public License, to permit their use in free software.

Next: Command and Option Index, Previous: GNU Free Documentation License, Up: Top   [Contents][Index]
Concept Index

This is a general index of all issues discussed in this manual, with the exception of the sed commands and command-line options.
Jump to:   	-   0   ;  
A   B   C   D   E   F   G   H   I   J   L   M   N   O   P   Q   R   S   T   U   V   W   X   Z  
	Index Entry	 	Section
-		
	-e, example:	 	Overview
	-e, example:	 	sed script overview
	–expression, example:	 	Overview
	-f, example:	 	Overview
	-f, example:	 	sed script overview
	–file, example:	 	Overview
	-i, example:	 	Overview
	-n, example:	 	Overview
	-s, example:	 	Overview
0		
	0 address:	 	Reporting Bugs
;		
	;, command separator:	 	sed script overview
A		
	a, and semicolons:	 	sed script overview
	Additional reading about sed:	 	Other Resources
	addr1,+N:	 	Range Addresses
	addr1,~N:	 	Range Addresses
	address range, example:	 	sed script overview
	Address, as a regular expression:	 	Regexp Addresses
	Address, last line:	 	Numeric Addresses
	Address, numeric:	 	Numeric Addresses
	addresses, excluding:	 	Addresses overview
	Addresses, in sed scripts:	 	Numeric Addresses
	addresses, negating:	 	Addresses overview
	addresses, numeric:	 	Addresses overview
	addresses, range:	 	Addresses overview
	addresses, regular expression:	 	Addresses overview
	addresses, syntax:	 	sed script overview
	alphabetic characters:	 	Character Classes and Bracket Expressions
	alphanumeric characters:	 	Character Classes and Bracket Expressions
	Append hold space to pattern space:	 	Other Commands
	Append next input line to pattern space:	 	Other Commands
	Append pattern space to hold space:	 	Other Commands
	Appending text after a line:	 	Other Commands
B		
	b, joining lines with:	 	Branching and flow control
	b, versus t:	 	Branching and flow control
	back-reference:	 	Back-references and Subexpressions
	Backreferences, in regular expressions:	 	The "s" Command
	blank characters:	 	Character Classes and Bracket Expressions
	bracket expression:	 	Character Classes and Bracket Expressions
	Branch to a label, if s/// failed:	 	Extended Commands
	Branch to a label, if s/// succeeded:	 	Programming Commands
	Branch to a label, unconditionally:	 	Programming Commands
	branching and n, N:	 	Branching and flow control
	branching, infinite loop:	 	Branching and flow control
	branching, joining lines:	 	Branching and flow control
	Buffer spaces, pattern and hold:	 	Execution Cycle
	Bugs, reporting:	 	Reporting Bugs
C		
	c, and semicolons:	 	sed script overview
	case insensitive, regular expression:	 	Regexp Addresses
	Case-insensitive matching:	 	The "s" Command
	Caveat — #n on first line:	 	Common Commands
	character class:	 	Character Classes and Bracket Expressions
	character classes:	 	Character Classes and Bracket Expressions
	classes of characters:	 	Character Classes and Bracket Expressions
	Command groups:	 	Common Commands
	Comments, in scripts:	 	Common Commands
	Conditional branch:	 	Programming Commands
	Conditional branch:	 	Extended Commands
	control characters:	 	Character Classes and Bracket Expressions
	Copy hold space into pattern space:	 	Other Commands
	Copy pattern space into hold space:	 	Other Commands
	cycle, restarting:	 	Branching and flow control
D		
	d, example:	 	sed script overview
	Delete first line from pattern space:	 	Other Commands
	digit characters:	 	Character Classes and Bracket Expressions
	Disabling autoprint, from command line:	 	Command-Line Options
E		
	empty regular expression:	 	Regexp Addresses
	Emptying pattern space:	 	Extended Commands
	Emptying pattern space:	 	Reporting Bugs
	Evaluate Bourne-shell commands:	 	Extended Commands
	Evaluate Bourne-shell commands, after substitution:	 	The "s" Command
	example, address range:	 	sed script overview
	example, regular expression:	 	sed script overview
	Exchange hold space with pattern space:	 	Other Commands
	Excluding lines:	 	Addresses overview
	exit status:	 	Exit status
	exit status, example:	 	Exit status
	Extended regular expressions, choosing:	 	Command-Line Options
	Extended regular expressions, syntax:	 	ERE syntax
F		
	File name, printing:	 	Extended Commands
	Files to be processed as input:	 	Command-Line Options
	Flow of control in scripts:	 	Programming Commands
G		
	Global substitution:	 	The "s" Command
	GNU extensions, /dev/stderr file:	 	The "s" Command
	GNU extensions, /dev/stderr file:	 	Other Commands
	GNU extensions, /dev/stdin file:	 	Other Commands
	GNU extensions, /dev/stdin file:	 	Extended Commands
	GNU extensions, /dev/stdout file:	 	Command-Line Options
	GNU extensions, /dev/stdout file:	 	The "s" Command
	GNU extensions, /dev/stdout file:	 	Other Commands
	GNU extensions, 0 address:	 	Range Addresses
	GNU extensions, 0 address:	 	Reporting Bugs
	GNU extensions, 0,addr2 addressing:	 	Range Addresses
	GNU extensions, addr1,+N addressing:	 	Range Addresses
	GNU extensions, addr1,~N addressing:	 	Range Addresses
	GNU extensions, branch if s/// failed:	 	Extended Commands
	GNU extensions, case modifiers in s commands:	 	The "s" Command
	GNU extensions, checking for their presence:	 	Extended Commands
	GNU extensions, debug:	 	Command-Line Options
	GNU extensions, disabling:	 	Command-Line Options
	GNU extensions, emptying pattern space:	 	Extended Commands
	GNU extensions, emptying pattern space:	 	Reporting Bugs
	GNU extensions, evaluating Bourne-shell commands:	 	The "s" Command
	GNU extensions, evaluating Bourne-shell commands:	 	Extended Commands
	GNU extensions, extended regular expressions:	 	Command-Line Options
	GNU extensions, g and number modifier:	 	The "s" Command
	GNU extensions, I modifier:	 	The "s" Command
	GNU extensions, I modifier:	 	Regexp Addresses
	GNU extensions, in-place editing:	 	Command-Line Options
	GNU extensions, in-place editing:	 	Reporting Bugs
	GNU extensions, M modifier:	 	The "s" Command
	GNU extensions, M modifier:	 	Regexp Addresses
	GNU extensions, modifiers and the empty regular expression:	 	Regexp Addresses
	GNU extensions, ‘n~m’ addresses:	 	Numeric Addresses
	GNU extensions, quitting silently:	 	Extended Commands
	GNU extensions, R command:	 	Extended Commands
	GNU extensions, reading a file a line at a time:	 	Extended Commands
	GNU extensions, returning an exit code:	 	Common Commands
	GNU extensions, returning an exit code:	 	Extended Commands
	GNU extensions, setting line length:	 	Other Commands
	GNU extensions, special escapes:	 	Escapes
	GNU extensions, special escapes:	 	Reporting Bugs
	GNU extensions, special two-address forms:	 	Range Addresses
	GNU extensions, subprocesses:	 	The "s" Command
	GNU extensions, subprocesses:	 	Extended Commands
	GNU extensions, to basic regular expressions:	 	BRE syntax
	GNU extensions, to basic regular expressions:	 	BRE syntax
	GNU extensions, to basic regular expressions:	 	BRE syntax
	GNU extensions, to basic regular expressions:	 	BRE syntax
	GNU extensions, to basic regular expressions:	 	BRE syntax
	GNU extensions, to basic regular expressions:	 	Reporting Bugs
	GNU extensions, two addresses supported by most commands:	 	Other Commands
	GNU extensions, two addresses supported by most commands:	 	Other Commands
	GNU extensions, two addresses supported by most commands:	 	Other Commands
	GNU extensions, two addresses supported by most commands:	 	Other Commands
	GNU extensions, unlimited line length:	 	Limitations
	GNU extensions, writing first line to a file:	 	Extended Commands
	Goto, in scripts:	 	Programming Commands
	graphic characters:	 	Character Classes and Bracket Expressions
	Greedy regular expression matching:	 	BRE syntax
	Grouping commands:	 	Common Commands
H		
	hexadecimal digits:	 	Character Classes and Bracket Expressions
	Hold space, appending from pattern space:	 	Other Commands
	Hold space, appending to pattern space:	 	Other Commands
	Hold space, copy into pattern space:	 	Other Commands
	Hold space, copying pattern space into:	 	Other Commands
	Hold space, definition:	 	Execution Cycle
	Hold space, exchange with pattern space:	 	Other Commands
I		
	i, and semicolons:	 	sed script overview
	In-place editing:	 	Reporting Bugs
	In-place editing, activating:	 	Command-Line Options
	In-place editing, Perl-style backup file names:	 	Command-Line Options
	infinite loop, branching:	 	Branching and flow control
	Inserting text before a line:	 	Other Commands
J		
	joining lines with branching:	 	Branching and flow control
	joining quoted-printable lines:	 	Branching and flow control
L		
	labels:	 	Branching and flow control
	Labels, in scripts:	 	Programming Commands
	Last line, selecting:	 	Numeric Addresses
	Line length, setting:	 	Command-Line Options
	Line length, setting:	 	Other Commands
	Line number, printing:	 	Other Commands
	Line selection:	 	Numeric Addresses
	Line, selecting by number:	 	Numeric Addresses
	Line, selecting by regular expression match:	 	Regexp Addresses
	Line, selecting last:	 	Numeric Addresses
	List pattern space:	 	Other Commands
	lower-case letters:	 	Character Classes and Bracket Expressions
M		
	Mixing g and number modifiers in the s command:	 	The "s" Command
	multiple files:	 	Overview
	multiple sed commands:	 	sed script overview
N		
	n, and branching:	 	Branching and flow control
	N, and branching:	 	Branching and flow control
	named character classes:	 	Character Classes and Bracket Expressions
	newline, command separator:	 	sed script overview
	Next input line, append to pattern space:	 	Other Commands
	Next input line, replace pattern space with:	 	Common Commands
	Non-bugs, 0 address:	 	Reporting Bugs
	Non-bugs, in-place editing:	 	Reporting Bugs
	Non-bugs, localization-related:	 	Reporting Bugs
	Non-bugs, localization-related:	 	Reporting Bugs
	Non-bugs, N command on the last line:	 	Reporting Bugs
	Non-bugs, regex syntax clashes:	 	Reporting Bugs
	numeric addresses:	 	Addresses overview
	numeric characters:	 	Character Classes and Bracket Expressions
O		
	omitting labels:	 	Branching and flow control
	output:	 	Overview
	output, suppressing:	 	Overview
P		
	p, example:	 	Overview
	paragraphs, processing:	 	Multiline techniques
	parameters, script:	 	Overview
	Parenthesized substrings:	 	The "s" Command
	Pattern space, definition:	 	Execution Cycle
	Portability, comments:	 	Common Commands
	Portability, line length limitations:	 	Limitations
	Portability, N command on the last line:	 	Reporting Bugs
	POSIXLY_CORRECT behavior, bracket expressions:	 	Character Classes and Bracket Expressions
	POSIXLY_CORRECT behavior, enabling:	 	Command-Line Options
	POSIXLY_CORRECT behavior, escapes:	 	Escapes
	POSIXLY_CORRECT behavior, N command:	 	Reporting Bugs
	Print first line from pattern space:	 	Other Commands
	printable characters:	 	Character Classes and Bracket Expressions
	Printing file name:	 	Extended Commands
	Printing line number:	 	Other Commands
	Printing text unambiguously:	 	Other Commands
	processing paragraphs:	 	Multiline techniques
	punctuation characters:	 	Character Classes and Bracket Expressions
Q		
	Q, example:	 	Exit status
	q, example:	 	sed script overview
	Quitting:	 	Common Commands
	Quitting:	 	Extended Commands
	quoted-printable lines, joining:	 	Branching and flow control
R		
	range addresses:	 	Addresses overview
	range expression:	 	Character Classes and Bracket Expressions
	Range of lines:	 	Range Addresses
	Range with start address of zero:	 	Range Addresses
	Read next input line:	 	Common Commands
	Read text from a file:	 	Other Commands
	Read text from a file:	 	Extended Commands
	regex addresses and input lines:	 	Regexp Addresses
	regex addresses and pattern space:	 	Regexp Addresses
	regular expression addresses:	 	Addresses overview
	regular expression, example:	 	sed script overview
	Replace hold space with copy of pattern space:	 	Other Commands
	Replace pattern space with copy of hold space:	 	Other Commands
	Replacing all text matching regexp in a line:	 	The "s" Command
	Replacing only nth match of regexp in a line:	 	The "s" Command
	Replacing selected lines with other text:	 	Other Commands
	Requiring GNU sed:	 	Extended Commands
	restarting a cycle:	 	Branching and flow control
S		
	Sandbox mode:	 	Command-Line Options
	script parameter:	 	Overview
	Script structure:	 	sed script overview
	Script, from a file:	 	Command-Line Options
	Script, from command line:	 	Command-Line Options
	sed commands syntax:	 	sed script overview
	sed commands, multiple:	 	sed script overview
	sed script structure:	 	sed script overview
	Selecting lines to process:	 	Numeric Addresses
	Selecting non-matching lines:	 	Addresses overview
	semicolons, command separator:	 	sed script overview
	Several lines, selecting:	 	Range Addresses
	Slash character, in regular expressions:	 	Regexp Addresses
	space characters:	 	Character Classes and Bracket Expressions
	Spaces, pattern and hold:	 	Execution Cycle
	Special addressing forms:	 	Range Addresses
	standard input:	 	Overview
	Standard input, processing as input:	 	Command-Line Options
	standard output:	 	Overview
	stdin:	 	Overview
	stdout:	 	Overview
	Stream editor:	 	Introduction
	subexpression:	 	Back-references and Subexpressions
	Subprocesses:	 	The "s" Command
	Subprocesses:	 	Extended Commands
	Substitution of text, options:	 	The "s" Command
	suppressing output:	 	Overview
	syntax, addresses:	 	sed script overview
	syntax, sed commands:	 	sed script overview
T		
	t, joining lines with:	 	Branching and flow control
	t, versus b:	 	Branching and flow control
	Text, appending:	 	Other Commands
	Text, deleting:	 	Common Commands
	Text, insertion:	 	Other Commands
	Text, printing:	 	Common Commands
	Text, printing after substitution:	 	The "s" Command
	Text, writing to a file after substitution:	 	The "s" Command
	Transliteration:	 	Other Commands
U		
	Unbuffered I/O, choosing:	 	Command-Line Options
	upper-case letters:	 	Character Classes and Bracket Expressions
	Usage summary, printing:	 	Command-Line Options
V		
	Version, printing:	 	Command-Line Options
W		
	whitespace characters:	 	Character Classes and Bracket Expressions
	Working on separate files:	 	Command-Line Options
	Write first line to a file:	 	Extended Commands
	Write to a file:	 	Other Commands
X		
	xdigit class:	 	Character Classes and Bracket Expressions
Z		
	Zero, as range start address:	 	Range Addresses
Jump to:   	-   0   ;  
A   B   C   D   E   F   G   H   I   J   L   M   N   O   P   Q   R   S   T   U   V   W   X   Z  

Previous: Concept Index, Up: Top   [Contents][Index]
Command and Option Index

This is an alphabetical list of all sed commands and command-line options.
Jump to:   	#   -   :   =   {  
A   B   C   D   E   F   G   H   I   L   N   P   Q   R   S   T   U   V   W   X   Y   Z  
	Index Entry	 	Section
#		
	# (comments):	 	Common Commands
-		
	--binary:	 	Command-Line Options
	--debug:	 	Command-Line Options
	--expression:	 	Command-Line Options
	--file:	 	Command-Line Options
	--follow-symlinks:	 	Command-Line Options
	--help:	 	Command-Line Options
	--in-place:	 	Command-Line Options
	--line-length:	 	Command-Line Options
	--null-data:	 	Command-Line Options
	--posix:	 	Command-Line Options
	--quiet:	 	Command-Line Options
	--regexp-extended:	 	Command-Line Options
	--sandbox:	 	Command-Line Options
	--separate:	 	Command-Line Options
	--silent:	 	Command-Line Options
	--unbuffered:	 	Command-Line Options
	--version:	 	Command-Line Options
	--zero-terminated:	 	Command-Line Options
	-b:	 	Command-Line Options
	-e:	 	Command-Line Options
	-E:	 	Command-Line Options
	-f:	 	Command-Line Options
	-i:	 	Command-Line Options
	-l:	 	Command-Line Options
	-n:	 	Command-Line Options
	-n, forcing from within a script:	 	Common Commands
	-r:	 	Command-Line Options
	-s:	 	Command-Line Options
	-u:	 	Command-Line Options
	-z:	 	Command-Line Options
:		
	: (label) command:	 	Programming Commands
=		
	= (print line number) command:	 	Other Commands
{		
	{} command grouping:	 	Common Commands
A		
	a (append text lines) command:	 	Other Commands
	alnum character class:	 	Character Classes and Bracket Expressions
	alpha character class:	 	Character Classes and Bracket Expressions
B		
	b (branch) command:	 	Programming Commands
	blank character class:	 	Character Classes and Bracket Expressions
C		
	c (change to text lines) command:	 	Other Commands
	cntrl character class:	 	Character Classes and Bracket Expressions
D		
	D (delete first line) command:	 	Other Commands
	d (delete) command:	 	Common Commands
	digit character class:	 	Character Classes and Bracket Expressions
E		
	e (evaluate) command:	 	Extended Commands
F		
	F (File name) command:	 	Extended Commands
G		
	G (appending Get) command:	 	Other Commands
	g (get) command:	 	Other Commands
	graph character class:	 	Character Classes and Bracket Expressions
H		
	H (append Hold) command:	 	Other Commands
	h (hold) command:	 	Other Commands
I		
	i (insert text lines) command:	 	Other Commands
L		
	l (list unambiguously) command:	 	Other Commands
	lower character class:	 	Character Classes and Bracket Expressions
N		
	N (append Next line) command:	 	Other Commands
	n (next-line) command:	 	Common Commands
P		
	P (print first line) command:	 	Other Commands
	p (print) command:	 	Common Commands
	print character class:	 	Character Classes and Bracket Expressions
	punct character class:	 	Character Classes and Bracket Expressions
Q		
	q (quit) command:	 	Common Commands
	Q (silent Quit) command:	 	Extended Commands
R		
	r (read file) command:	 	Other Commands
	R (read line) command:	 	Extended Commands
S		
	s command, option flags:	 	The "s" Command
	space character class:	 	Character Classes and Bracket Expressions
T		
	T (test and branch if failed) command:	 	Extended Commands
	t (test and branch if successful) command:	 	Programming Commands
U		
	upper character class:	 	Character Classes and Bracket Expressions
V		
	v (version) command:	 	Extended Commands
W		
	w (write file) command:	 	Other Commands
	W (write first line) command:	 	Extended Commands
X		
	x (eXchange) command:	 	Other Commands
	xdigit character class:	 	Character Classes and Bracket Expressions
Y		
	y (transliterate) command:	 	Other Commands
Z		
	z (Zap) command:	 	Extended Commands
Jump to:   	#   -   :   =   {  
A   B   C   D   E   F   G   H   I   L   N   P   Q   R   S   T   U   V   W   X   Y   Z  
Table of Contents

    1 Introduction
    2 Running sed
        2.1 Overview
        2.2 Command-Line Options
        2.3 Exit status
    3 sed scripts
        3.1 sed script overview
        3.2 sed commands summary
        3.3 The s Command
        3.4 Often-Used Commands
        3.5 Less Frequently-Used Commands
        3.6 Commands for sed gurus
        3.7 Commands Specific to GNU sed
        3.8 Multiple commands syntax
            3.8.1 Commands Requiring a newline
    4 Addresses: selecting lines
        4.1 Addresses overview
        4.2 Selecting lines by numbers
        4.3 selecting lines by text matching
        4.4 Range Addresses
    5 Regular Expressions: selecting text
        5.1 Overview of regular expression in sed
        5.2 Basic (BRE) and extended (ERE) regular expression
        5.3 Overview of basic regular expression syntax
        5.4 Overview of extended regular expression syntax
        5.5 Character Classes and Bracket Expressions
        5.6 regular expression extensions
        5.7 Back-references and Subexpressions
        5.8 Escape Sequences - specifying special characters
            5.8.1 Escaping Precedence
        5.9 Multibyte characters and Locale Considerations
            5.9.1 Invalid multibyte characters
            5.9.2 Upper/Lower case conversion
            5.9.3 Multibyte regexp character classes
    6 Advanced sed: cycles and buffers
        6.1 How sed Works
        6.2 Hold and Pattern Buffers
        6.3 Multiline techniques - using D,G,H,N,P to process multiple lines
        6.4 Branching and Flow Control
            6.4.1 Branching and Cycles
            6.4.2 Branching example: joining lines
    7 Some Sample Scripts
        7.1 Joining lines
        7.2 Centering Lines
        7.3 Increment a Number
        7.4 Rename Files to Lower Case
        7.5 Print bash Environment
        7.6 Reverse Characters of Lines
        7.7 Text search across multiple lines
        7.8 Line length adjustment
        7.9 Reverse Lines of Files
        7.10 Numbering Lines
        7.11 Numbering Non-blank Lines
        7.12 Counting Characters
        7.13 Counting Words
        7.14 Counting Lines
        7.15 Printing the First Lines
        7.16 Printing the Last Lines
        7.17 Make Duplicate Lines Unique
        7.18 Print Duplicated Lines of Input
        7.19 Remove All Duplicated Lines
        7.20 Squeezing Blank Lines
    8 GNU sed’s Limitations and Non-limitations
    9 Other Resources for Learning About sed
    10 Reporting Bugs
    Appendix A GNU Free Documentation License
    Concept Index
    Command and Option Index

Footnotes
(1)

This applies to commands such as =, a, c, i, l, p. You can still write to the standard output by using the w or W commands together with the /dev/stdout special file
(2)

Note that GNU sed creates the backup file whether or not any output is actually changed.
(3)

This is equivalent to p unless the -i option is being used.
(4)

This is equivalent to p unless the -i option is being used.
(5)

There are of course many other ways to do the same, e.g.

grep 'bash$' /etc/passwd
awk -F: '$7 == "/bin/bash"' /etc/passwd

(6)

All the escapes introduced here are GNU extensions, with the exception of \n. In basic regular expression mode, setting POSIXLY_CORRECT disables them inside bracket expressions.
(7)

Some regexp edge-cases depends on the operating system and libc implementation. The examples shown are known to work as-expected on GNU/Linux systems using glibc.
(8)

Actually, if sed prints a line without the terminating newline, it will nevertheless print the missing newline as soon as more text is sent to the same output stream, which gives the “least expected surprise” even though it does not make commands like ‘sed -n p’ exactly identical to cat.
(9)

sed guru Greg Ubben wrote an implementation of the dc RPN calculator! It is distributed together with sed.
(10)

This requires another script to pad the output of banner; for example

#! /bin/sh

banner -w $1 $2 $3 $4 |
  sed -e :a -e '/^.\{0,'$1'\}$/ { s/$/ /; ba; }' |
  ~/sedscripts/reverseline.sed

(11)

Some implementations have a limit of 199 commands per script
(12)

which is the actual “bug” that prompted the change in behavior



SA+Vegditto lockscreen kbdin pis0853polsiren



Tech News
Deals
Awards

Follow Us

    Home
    Linux

These 10 Sed Examples Will Make You a Linux Power User
By
Deepesh Sharma
Published Apr 12, 2021

Want to become a Linux power user? Getting to grips with sed will help. Learn from these 10 sed examples.
linux sed command

Editing text files and terminal output is an everyday job for those who administer Linux machines. Command-line utilities like sed allow a user to modify and change the content of a text file right from the terminal window.

In this article, we will discuss the sed command in detail, along with some essential examples that demonstrate the power of the sed utility in Linux.
What Is the sed Command?

The sed command, which is an acronym for Stream Editor, is a command-line tool that allows Linux users to perform text-based operations on files and terminal outputs. Using sed, users can find and replace specific words in a text, display a certain section of the output, and edit text files without opening them.

The three basic operations supported by the sed command are:

    Insertion
    Deletion
    Substitution (Find and replace)

Advanced users can also implement regular expressions with the sed command to edit text streams more efficiently.

The basic syntax of the command is:

sed [options] [pattern] [filepath]

...where options are the various functionalities of the command, pattern is the regular expression or the script that you want to match, and filepath is the path to the text file that contains the text.
10 Examples of the Linux sed Command

If you plan to become a regular Linux user, knowing how to edit files, search and replace specific words, and filter the terminal output might be useful to you. This section covers some examples of the sed command that will definitely turn you into a Linux power user.

We will be using the following text file for demonstration in the post.

This is a demo text file.
It is an amazing file that will help us all.
The sed command is also great for stream editing.
Want to learn how to use the command?
This is another line in the file.
This is the third general line in the file.
This file is named as textfile.
This is a apple.
This is a orange.

1. View a Range of Lines

Linux commands such as head and tail output the first or the last ten lines of a text file. But what if you want to get the content between two specific lines in a file? In such situations, the sed command might come in handy.

To output the content between lines 3 and 5 of the file textfile.txt:

sed -n '3,5p' textfile.txt

The -n flag prevents sed from displaying the pattern space at the end of each cycle. You can also use the --quiet and --silent options instead of -n. The p argument stands for print and is used to display the matched lines to the user.

Executing the aforementioned command on the example file produces the following output.

The sed command is also great for stream editing.
Want to learn how to use the command?
This is another line in the file.

To output the entire file content except for the specified range, use the d flag instead of p in the command:

sed '3,5d' textfile.txt

The d flag deletes the matched strings from the output and displays the rest of the content.

This is a demo text file.
It is an amazing file that will help us all.
This is the third general line in the file.
This file is named as textfile.
This is a apple.
This is a orange.

2. Display Non-Consecutive Lines

To print non-consecutive lines between multiple range in the file:

sed -n -e '1,2p' -e '5,6p' textfile.txt

Output:

This is a demo text file.
It is an amazing file that will help us all.
This is another line in the file.
This is the third general line in the file.

The -e flag helps in executing multiple actions using a single command.
3. Insert Space Between Lines

If for any reason you want to insert empty lines between each line in a text file, use the G argument with the default sed command.

sed G textfile.txt

To insert multiple empty lines in the output, pass multiple G arguments separated by the semi-colon (;) character.

sed 'G;G' textfile.txt

4. Replace a Word in a Text File

If you want to replace each occurrence of a specific word with some other word, use the s and g arguments with the command. The basic syntax for substituting words using the sed command is:

sed s/originalword/replaceword/g filename

Using the above-mentioned syntax, you can replace the word amazing with super in the file textfile.txt:

sed s/amazing/super/g textfile.txt

The s argument denotes substitution and the g command is used to replace the matched content with the specified replacement content.

To replace the second occurrence of the word with sed, pass a number to the g argument. In this case:

sed s/amazing/super/g2 textfile.txt

If you want to ignore character cases while substituting words, use gi instead of g, where i stands for ignore case.

sed s/Amazing/super/gi textfile.txt

Related:
Using Vi? Here's How to Open a File Then Save and Quit
5. Substitute Words Inside a Range

You can also substitute words inside a specific range.

sed '2,5s/amazing/super/g' textfile.txt

6. Perform Multiple Substitutions at Once

If you want to perform two or more substitutions at once, just separate the commands with the semi-colon (;) character.

sed 's/amazing/super/g;s/command/utility/gi' textfile.txt

The system will display the following output.

This is a demo text file.
It is an super file that will help us all.
The sed utility is also great for stream editing.
Want to learn how to use the utility?
This is another line in the file.
This is the third general line in the file.
This file is named as textfile.
This is a apple.
This is a orange.

7. Replace Words Only If a Match Is Found

You can also use the sed command to replace a word only if a given match is found in the line. For example, to replace the word a with an if the word orange is present in the line:

sed -e '/orange/ s/a/an/g' textfile.txt

Issuing the above-mentioned command will output:

This is a demo text file.
It is an super file that will help us all.
The sed utility is also great for stream editing.
Want to learn how to use the utility?
This is another line in the file.
This is the third general line in the file.
This file is named as textfile.
This is a apple.
This is an orange.

Note that the word a in the line This is a apple wasn't replaced as the system didn't find the word orange in it.
8. Substitute Words Using Regular Expressions

For those who know how to use regular expressions, performing operations on strings using the sed command becomes a lot easier. You can implement regular expressions to enhance the power of the command.

To replace all occurrences of the word Amazing or amazing with super:

sed -e 's/[Aa]mazing/super/g' textfile.txt

Similarly, you can also use advanced regular expressions to execute specific operations using the sed command.
9. Pipe sed With Other Commands

You can chain sed with other Linux commands as well. For example, you can pipe the lspci command with sed to add empty spaces between lines in the output.

lspci | sed G

To replace specific words in the output of the ip route show command:

ip route show | sed s/src/source/g

The aforementioned command substitutes the word source in place of the original word src.

Related:
How to Use the Find Command to Search for Files in Linux
10. Edit and Backup the Original File

When you are working with system files, backing up the original file while making changes is important. This will help you in reverting the changes in case something breaks.

To back up the original file using sed, use the -i flag in the command.

sed -i'.backup' 's/amazing/super/g' textfile.txt

A new file will be created with the name textfile.txt.backup. You can check that the two files are different using the diff command.

diff textfile.txt textfile.txt.backup

back up original file with sed command
Editing Strings in Linux With sed

Sometimes, while you're working with text files on the terminal, formatting and editing the output for better readability becomes a must. Sed and awk are command-line utilities in Linux that allow a user to work efficiently with text files by dividing the data into separate lines.

Many users have a hard time memorizing the arguments and flags of the sed command since there are a lot of them that are available to use. Knowing how to get command-line manuals for any Linux command will help you in getting out of such situations easily.
feature image of person taking notes and learning
7 Ways to Get Command Line Help on Linux
Read Next
Share
Tweet
Share
Email
Related Topics

    Linux
    Text Editor
    Terminal
    Command Prompt

About The Author
Deepesh Sharma (130 Articles Published)

Deepesh is the Section Editor for Linux at MUO. He has a degree in Computer Applications and has been writing about technology for over five years. When not penning down informational guides on Linux, Windows, or Gaming, you can find him secluded in a corner reading books, playing FPS games, or searching for new hobbies to take up, only to quit and find a new one again.
More From Deepesh Sharma
Subscribe to our newsletter

Join our newsletter for tech tips, reviews, free ebooks, and exclusive deals!
Click here to subscribe
On The Wire
multiple-os-usb-stick
How to Install Multiple Bootable Operating Systems on a USB Stick
Animal Crossing game cartridges and themed switch
How to Back Up Your Animal Crossing: New Horizons Saved Data
Camera on desk next to MacBook and iPhone
How to Change the Camera or Microphone for FaceTime on a Mac
whatsapp-tricks
15 Hidden WhatsApp Tricks You Need to Try Right Now
Man holding phone and focusing on laptop
How to Use Focus Mode on Android to Bring Distracting Apps Under Control
manjaro vs endeavour os compared
Manjaro vs. EndeavourOS: Comparing the Two Major Arch-Based Distros
trending now
windows-diagnostics
15 Windows Diagnostics Tools to Check Your PC's Health
Photograph of Character Map as Seen From a Monitor
The Ultimate List of Helpful Windows Alt Codes to Insert Special Characters
Photo of the Reddit logo on a screen
How to Delete Your Reddit Account
Read Next
Gloved hand pulling weed with unnecessary software icons from a garden
12 Unnecessary Windows Programs and Apps You Should Uninstall
signal and shield symbols next to person on laptop
RDP vs. VPNs: What's the Difference?
install VLC on Linux
How to Fix VLC Media Player When It's Not Playing Videos on Windows 11
can you use messenger without fb
How to Use Messenger Without Facebook
Person wearing an Apple Watch
How to Ping Your Apple Watch With Your iPhone
Windows 10 Can't Communicate Error
What Does the "Windows Resource Protection Found Corrupt Files" Error Mean, and How Do You Fix It?
man wearing gaming headphones in front of screen
How to Fix Your Speakers Playing Audio When Headphones Are Plugged In on Windows
split screen on windows
How to Split Your Screen on Windows 11

    Write For Us
    Home
    Contact Us
    Terms
    Privacy
    Copyright
    About Us
    Fact Checking Policy
    Corrections Policy
    Ethics Policy
    Ownership Policy
    Partnership Disclaimer

Copyright © 2022 www.makeuseof.com


Sa+VEgdiTto lockscreen kbdin pis0854polsiren



This is Section 1 of the sed FAQ.
Go forward to Section 2.
Go up to the index.

1. GENERAL INFORMATION
1.1. Introduction - How this FAQ is organized

This FAQ is organized to answer common (and some uncommon) questions about sed, quickly. If you see a term or abbreviation in the examples that seems unclear, see if the term is defined in section 1.5. If not, send your comment to pemente[at]northpark.edu.
1.2. Latest version of the sed FAQ

The newest version of the sed FAQ is usually here:

       http://sed.sourceforge.net/sedfaq.html (HTML version)
       http://sed.sourceforge.net/sedfaq.txt  (plain text)
       http://www.student.northpark.edu/pemente/sed/sedfaq.html
       http://www.student.northpark.edu/pemente/sed/sedfaq.txt
       http://www.faqs.org/faqs/editor-faq/sed
       ftp://rtfm.mit.edu/pub/faqs/editor-faq/sed

Another FAQ file on sed by a different author can be found here:

       http://www.dreamwvr.com/sed-info/sed-faq.html

1.3. FAQ revision information

In the plaintext version, changes are shown by a vertical bar (|) placed in column 78 of the affected lines. To remove the vertical bars (use double quotes for MS-DOS):

     sed 's/  *|$//' sedfaq.txt > sedfaq2.txt

In the HTML version, vertical bars do not appear. New or altered portions of the FAQ are indicated by printing in dark blue type.

In the text version, words needing emphasis may be surrounded by the underscore '_' or the asterisk '*'. In the HTML version, these are changed to italics and boldface, respectively.
1.4. How do I add a question/answer to the sed FAQ?

Word your question briefly and send it to pemente[at]northpark.edu, indicating your proposed change. We'll post it on the sed-users mailing list (see section 2.3.2) and discuss it there. If it's good, your contribution will be added to the next edition.
1.5. FAQ abbreviations

       files = one or more filenames, separated by whitespace
       gsed  = GNU sed
       ssed  = super-sed
       RE    = Regular Expressions supported by sed
       LHS   = the left-hand side ("find" part) of "s/find/repl/" command
       RHS   = the right-hand side ("replace" part) of "s/find/repl/" cmd
       nn+   = version nn or higher (e.g., "15+" = version 1.5 and above)

files: "files" stands for one or more filenames entered on the command line. The names may include any wildcards your shell understands (such as ``zork*'' or ``Aug[4-9].let''). Sed will process each filename passed to it by the shell.

RE: For details on regular expressions, see section 3.1.1., below.
1.6. Credits and acknowledgements

Many of the ideas for this FAQ were taken from the Awk FAQ:

       http://www.faqs.org/faqs/computer-lang/awk/faq/
       ftp://rtfm.mit.edu/pub/usenet/comp.lang.awk/faq

and from the old Perl FAQ:

       http://www.perl.com/doc/FAQs/FAQ/oldfaq-html/index.html

The following individuals have contributed significantly to this document, and have provided input and wording suggestions for questions, answers, and script examples. Credit goes to these contributors (in alphabetical order by last name):

Al Aab, Yiorgos Adamopoulos, Paolo Bonzini, Walter Briscoe, Jim Dennis, Carlos Duarte, Otavio Exel, Sven Guckes, Aurelio Jargas, Mark Katz, Toby Kelsey, Eric Pement, Greg Pfeiffer, Ken Pizzini, Niall Smart, Simon Taylor, Peter Tillier, Greg Ubben, Laurent Vogel.
1.7. Standard disclaimers

While a serious attempt has been made to ensure the accuracy of the information presented herein, the contributors and maintainers of this document do not claim the absence of errors and make no warranties on the information provided. If you notice any mistakes, please let us know so we can fix it.

This is the end of Section 1 of the sed FAQ.
Go forward to Section 2.
Go up to the index.

SaV+EgdITto lockscreen kbdin pis0854polsiren



This is Section 2 of the sed FAQ.
Go back to Section 1, or forward to Section 3.
Go up to the index.

2. BASIC SED
2.1. What is sed?

"sed" stands for Stream EDitor. Sed is a non-interactive editor, written by the late Lee E. McMahon in 1973 or 1974. A brief history of sed's origins may be found in an early history of the Unix tools, at <http://www.columbia.edu/~rh120/ch106.x09>.

Instead of altering a file interactively by moving the cursor on the screen (as with a word processor), the user sends a script of editing instructions to sed, plus the name of the file to edit (or the text to be edited may come as output from a pipe). In this sense, sed works like a filter -- deleting, inserting and changing characters, words, and lines of text. Its range of activity goes from small, simple changes to very complex ones.

Sed reads its input from stdin (Unix shorthand for "standard input," i.e., the console) or from files (or both), and sends the results to stdout ("standard output," normally the console or screen). Most people use sed first for its substitution features. Sed is often used as a find-and-replace tool.

     sed 's/Glenn/Harold/g' oldfile >newfile

will replace every occurrence of "Glenn" with the word "Harold", wherever it occurs in the file. The "find" portion is a regular expression ("RE"), which can be a simple word or may contain special characters to allow greater flexibility (for example, to prevent "Glenn" from also matching "Glennon").

My very first use of sed was to add 8 spaces to the left side of a file, so when I printed it, the printing wouldn't begin at the absolute left edge of a piece of paper.

     sed 's/^/        /' myfile >newfile   # my first sed script
     sed 's/^/        /' myfile | lp       # my next sed script

Then I learned that sed could display only one paragraph of a file, beginning at the phrase "and where it came" and ending at the phrase "for all people". My script looked like this:

     sed -n '/and where it came/,/for all people/p' myfile

Sed's normal behavior is to print (i.e., display or show on screen) the entire file, including the parts that haven't been altered, unless you use the -n switch. The "-n" stands for "no output". This switch is almost always used in conjunction with a 'p' command somewhere, which says to print only the sections of the file that have been specified. The -n switch with the 'p' command allow for parts of a file to be printed (i.e., sent to the console).

Next, I found that sed could show me only (say) lines 12-18 of a file and not show me the rest. This was very handy when I needed to review only part of a long file and I didn't want to alter it.

     # the 'p' stands for print
     sed -n 12,18p myfile

Likewise, sed could show me everything else BUT those particular lines, without physically changing the file on the disk:

     # the 'd' stands for delete
     sed 12,18d myfile

Sed could also double-space my single-spaced file when it came time to print it:

     sed G myfile >newfile

If you have many editing commands (for deleting, adding, substituting, etc.) which might take up several lines, those commands can be put into a separate file and all of the commands in the file applied to file being edited:

     #  'script.sed' is the file of commands
     # 'myfile' is the file being changed
     sed -f script.sed myfile  # 'script.sed' is the file of commands

It is not our intention to convert this FAQ file into a full-blown sed tutorial (for good tutorials, see section 2.3). Rather, we hope this gives the complete novice a few ideas of how sed can be used.
2.2. What versions of sed are there, and where can I get them?
2.2.1. Free versions

Note: "Free" does not mean "public domain" nor does it necessarily mean you will never be charged for it. All versions of sed in this section except the CP/M versions are based on the GNU general public license and are "free software" by that standard (for details, see http://www.gnu.org/philosophy/free-sw.html). This means you can get the source code and develop it further.

At the URLs listed in this category, sed binaries or source code can be downloaded and used without fees or license payments.
2.2.1.1. Unix platforms
ssed v3.60

ssed is the version recommended by the FAQ maintainers, since it shares the same codebase with GNU sed, has the most options, and is free software (you can get the source). Though there were earlier version of ssed distributed, sites for these are not being listed.

       http://sed.sourceforge.net/grabbag/ssed
       http://freshmeat.net/project/sed/

GNU sed v4.0.5

This is the latest official version of GNU sed. It offers in-place text replacement as an option switch.

       ftp://ftp.gnu.org/pub/gnu/sed/sed-4.0.5.tar.gz
       http://freshmeat.net/project/sed

BSD multi-byte sed (Japanese)

Based on the latest version of GNU sed, which supports multi-byte characters.

       ftp://ftp1.freebsd.org/pub/FreeBSD/FreeBSD-stable/packages/Latest/ja-sed.tgz

GNU sed v3.02.80

An alpha test release which was the base for the development of ssed and GNU sed v4.0.

       ftp://alpha.gnu.org/pub/gnu/sed/sed-3.02.80.tar.gz

GNU sed v3.02a

Interim version with most features of GNU sed v3.02.80.
GNU sed v3.02

       ftp://ftp.gnu.org/pub/gnu/sed/sed-3.02.tar.gz

Precompiled versions:
GNU sed v3.02-8

source code and binaries for Debian GNU/Linux

       http://www.debian.org/Packages/stable/base/sed.html

For some time, the GNU project <http://www.gnu.org> used Eric S. Raymond's version of sed (ESR sed v1.1), but eventually dropped it because it had too many built-in limits. In 1991 Howard Helman modified the GNU/ESR sed and produced a flexible version of sed v1.5 available at several sites (Helman's version permitted things like \<...\> to delimit word boundaries, \xHH to enter hex code and \n to indicate newlines in the replace string). This version did not catch on with the GNU project and their version of sed has moved in a similar but different direction.
sed v1.3, by Eric Steven Raymond (released 4 June 1998)

       http://catb.org/~esr/sed-1.3.tar.gz

Eric Raymond <esr@snark.thyrsus.com> wrote one of the earliest versions of sed. On his website <http://www.catb.org/~esr/> which also distributes many freeware utilities he has written or worked on, he describes sed v1.1 this way:

"This is the fast, small sed originally distributed in the GNU toolkit and still distributed with Minix. The GNU people ditched it when they built their own sed around an enhanced regex package -- but it's still better for some uses (in particular, faster and less memory-intensive)." (Version 1.3 fixes an unidentified bug and adds the L command to hexdump the current pattern space.)
2.2.1.2. OS/2
GNU sed v3.02.80

       http://www2s.biglobe.ne.jp/~vtgf3mpr/gnu/sed.htm

GNU sed v3.02

       http://hobbes.nmsu.edu/pub/os2/util/file/sed-3_02-r2-bin.zip # binaries
       http://hobbes.nmsu.edu/pub/os2/util/file/sed-3_02-r2.zip     # source

2.2.1.3. Microsoft Windows (Win3x, Win9x, WinNT, Win2K)
GNU sed v4.0.5

32-bit binaries and docs. Precompiled versions not available (yet).
GNU sed v3.02.80

32-bit binaries and docs, using DJGPP compiler. For details on new features, see Unix section, above.

       http://www.student.northpark.edu/pemente/sed/sed3028a.zip # DOS binaries
       ftp://alpha.gnu.org/pub/gnu/sed/sed-3.02.80.tar.gz        # source
       ftp://ftp.simtel.net/pub/simtelnet/gnu/djgpp/v2gnu/sed3028b.zip # binaries
       ftp://ftp.simtel.net/pub/simtelnet/gnu/djgpp/v2gnu/sed3028d.zip # docs
       ftp://ftp.simtel.net/pub/simtelnet/gnu/djgpp/v2gnu/sed3028s.zip # source

GNU sed v2.05

32-bit binaries, no docs. Requires 80386 DX (SX will not run) and must be run in a DOS window or in a full screen DOS session under Microsoft Windows. Will not run in MS-DOS mode (outside Win/Win95). We recommend using the latest version of GNU sed.

       http://www.simtel.net/pub/win95/prog/gsed205b.zip
       ftp://ftp.cdrom.com/pub/simtelnet/win95/prog/gsed205b.zip

GNU sed v1.03

modified by Frank Whaley.

This version was part of the "Virtually UN*X" toolset, hosted by itribe.net; that website is now closed. Gsed v1.03 supported Win9x long filenames, as well as hex, decimal, binary, and octal character representations.
The Cygwin toolkit:

       http://www.cygwin.com

Formerly know as "GNU-Win32 tools." According to their home page, "The Cygwin tools are Win32 ports of the popular GNU development tools for Windows NT, 95 and 98. They function through the use of the Cygwin library which provides a UNIX-like API on top of the Win32 API." The version of sed used is GNU sed v3.02.
Minimalist GNU for Windows (MinGW):

       http://www.mingw.org
       http://mingw.sourceforge.net

According to their home page, "MinGW ('Minimalist GNU for Windows') refers to a set of runtime headers, used in building a compiler system based on the GNU GCC and binutils projects. It compiles and links code to be run on Win32 platforms ... MinGW uses Microsoft runtime libraries, distributed with the Windows operating system." The version of sed used is GNU sed v3.02.
sed v1.5 (a/k/a HHsed), by Howard Helman

Compiled with Mingw32 for 32-bit environments described above. This version should support Win95 long filenames.

       http://www.dbnet.ece.ntua.gr/~george/sed/OLD/sed15.exe
       http://www.student.northpark.edu/pemente/sed/sed15exe.zip

2.2.1.4. MS-DOS
sed v1.6 (from HHsed), by Walter Briscoe

This is a forthcoming version, now in beta testing, but with many new features. It corrects all the bugs in sed v1.5, and adds the best features of sedmod v1.0 (below). It is available in 16-bit and 32-bit compiled versions for MS-DOS. Sorry, no URLs available yet.
sed v1.5 (a/k/a HHsed), by Howard Helman

uncompiled source code (Turbo C)

       ftp://ftp.simtel.net/pub/simtelnet/msdos/txtutl/sed15.zip
       ftp://ftp.cdrom.com/pub/simtelnet/msdos/txtutl/sed15.zip

DOS executable and documentation

       ftp://ftp.simtel.net/pub/simtelnet/msdos/txtutl/sed15x.zip
       ftp://ftp.cdrom.com/pub/simtelnet/msdos/txtutl/sed15x.zip

sedmod v1.0, by Hern Chen

       http://www.ptug.org/sed/SEDMOD10.ZIP
       http://www.student.northpark.edu/pemente/sed/sedmod10.zip
       ftp://garbo.uwasa.fi/pc/unix/sedmod10.zip

GNU sed v3.02.80

See section 2.2.1.3 ("Microsoft Windows"), above.
GNU sed v2.05

Does not run under MS-DOS.
GNU sed v1.18

32-bit binaries and source, using DJGPP compiler. Requires 80386 SX or better. Also requires 3 CWS*.EXE extenders on the path. See section 5.5 ("What is CSDPMI*B.ZIP and why do I need it?"), below. We recommend using a newer version of GNU sed.

       http://www.simtel.net/pub/simtelnet/gnu/djgpp/v2gnu/sed118b.zip
       ftp://ftp.cdrom.com/pub/simtelnet/gnu/djgpp/v2gnu/sed118b.zip
       http://www.simtel.net/pub/simtelnet/gnu/djgpp/v2gnu/sed118s.zip
       ftp://ftp.cdrom.com/pub/simtelnet/gnu/djgpp/v2gnu/sed118s.zip

GNU sed v1.06

16-bit binaries and source. Should run under any MS-DOS system.

       http://www.simtel.net/pub/gnu/gnuish/sed106.zip
       ftp://ftp.cdrom.com/pub/simtelnet/gnu/gnuish/sed106.zip

2.2.1.5. CP/M
ssed v2.2, by Chuck A. Forsberg

Written for CP/M, ssed (for "small/stupid stream editor) supports only the a(ppend), c(hange), d(elete) and i(nsert) options, and apparently doesn't support regular expressions. A -u switch will "unsqueeze" compressed files and was used mainly in conjunction with DIF.COM for source code maintenance. (file: ssed22.lbr)
change, by Michael M. Rubenstein

Rubenstein released a version of sed called CHANGE.COM (the TTOOLS.LBR archive member CHANGE.CZM is a "crunched" file). CHANGE.COM supports full RE's except grouping and backreferences, and its only function is global substitution. (file: ttools.lbr)
2.2.1.6. Macintosh v8 or v9

Since sed is a command-line utility, it is not customary to think of sed being used on a Mac. Nonetheless, the following instructions from Aurelio Jargas describe the process for running sed on MacOS version version 8 or 9.

(1) Download and install the Apple DiskCopy application

       ftp://ftp.apple.com/developer/Development_Kits

(2) Download and install Apple MPW

       ftp://ftp.apple.com/developer/Tool_Chest/Core_Mac_OS_Tools/MPW_etc./

(3) Download and expand Matthias Neeracher's GNU sed for MPW. (They seem to have misnumbered the sed filename.)

       ftp://sunsite.cnlab-switch.ch/software/platform/macos/src/mpw_c/sed-2.03.sit.bin

(4) Enter the sed-3.02 directory and doubleclick the 'sed' file

(5) MPW Shell will open up. It will be a command window instead of a command line, but sed should work as expected. For example:

       echo aa | sed 's/a/Z/g'<ENTER>

Note that ENTER is different from RETURN on an iMac. Apple also has its own version of sed on MPW, called "StreamEdit", with a syntax fairly similar to that of normal sed.
2.2.2. Shareware and Commercial versions
2.2.2.1. Unix platforms

       [ Additional information needed. ]

2.2.2.2. OS/2
Hamilton Labs:

       http://www.hamiltonlabs.com/cshell.htm

A sizable set of Unix/C shell utilities designed for OS/2. Price is $350 in the US, $395 elsewhere, with FedEx shipping, unconditional guarantee, unlimited support and free updates. A demo version of the suite can be downloaded from this site, but a stand-alone copy of sed is not available.
2.2.2.3. Windows 95/98, Windows NT, Windows 2000
Hamilton Labs:

       http://www.hamiltonlabs.com/cshell.htm

A sizable set of Unix/C shell utilities designed for Win9x, WinNT, and Win2K. Price is $350 in the US, $395 elsewhere, with FedEx shipping, unconditional guarantee, unlimited support and free updates. A demo version of the suite can be downloaded from this site, but a stand-alone copy of sed is not available.
Interix:

       http://www.interix.com

Interix (formerly known as OpenNT) is advertised as "a complete UNIX system environment running natively on Microsoft Windows NT", and is licensed and supported by Softway Systems. It offers over 200 Unix utilities, and supports Unix shells, sockets, networking, and more. A single-user edition runs about $200. A free demo or evaluation copy will run for 31 days and then quit; to continue using it, you must purchase the commercial version.
MKS NuTCRACKER Professional

       http://www.datafocus.com/products/nutc/

A different, yet related product line offered by MKS (Mortice Kern Systems, below); the awkward spelling "NuTCRACKER" is intentional. Various packages offer hundreds of Unix utilities for Win32 environments. Sed is not available as a separate product.
UnixDos:

       http://www.unixdos.com

UnixDos is a suite of 82 Unix utilities ported over to the Windows environments. There are 16-bit versions for Win3.x and 32-bit versions for WinNT/Win95. It is distributed as uncrippled shareware for the first 30 days. After the test period, the utilities will not run and you must pay the registration fee of $50.

Their version of sed supports "\n" in the RHS of expressions, and increases the length of input lines to 10,000 characters. By special arrangement with the owners, persons who want a licensed version of sed only (without the other utilities) may pay a license fee of $10.
U/WIN:

       http://www.research.att.com/sw/tools/uwin/

U/WIN is a suite of Unix utilities created for WinNT and Win95 systems. It is owned by AT&T, created by David Korn (author of the Unix korn shell), and is freely distributed only to educational institutions, AT&T employees, or certain researchers; all others must pay a fee after a 90-day evaluation period expires. U/WIN operates best with the NTFS (WinNT file system) but will run in degraded mode with the FAT file system and in further degraded mode under Win95. A minimal installation takes about 25 to 30 megs of disk space. Sed is not available as a separate file for download, but comes with the suite.
2.2.2.4. MS-DOS
Mix C/Utilities Toolchest

       http://www.mixsoftware.com/product/utility.htm

According to their web page, "The C/Utilities Toolchest adds over 40 powerful UNIX utilities to your MS-DOS operating system. The result is an environment very similar to UNIX operating systems, yet 100% compatible with MS-DOS programs and commands." The toolchest costs $19.95, with source code available for an additional fee. Mix C's version of sed is not available separately.
MKS (Mortice Kern Systems) Toolkit

       http://www.mks.com

Sed comes bundled with the MKS Toolkit, which is distributed only as commercial software; it is not available separately.
Thompson Automation Software

       http://www.tasoft.com

The Thompson Toolkit contains over 100 familiar Unix utilities, including a version of the Unix Korn shell. It runs under MS-DOS, OS/2, Win3.x, Win9x, and WinNT. Sed is one of the utilities, though Thompson is better known for its version of awk for DOS, TAWK. The toolkit runs about $150; sed is not available separately.
2.3. Where can I learn to use sed?
2.3.1. Books

       Sed & Awk, 2d edition, by Dale Dougherty & Arnold Robbins
       (Sebastopol, Calif: O'Reilly and Associates, 1997)
       ISBN 1-56592-225-5
       http://www.oreilly.com/catalog/sed2/noframes.html

About 40 percent of this book is devoted to sed, and maybe 50 percent is devoted to awk. The other 10 percent covers regexes and concepts common to both tools. If you prefer hard copy, this is definitely the best single place to learn to use sed, including its advanced features.

The first edition is also very useful. Several typos crept into the first printing of the first edition (though if you follow the tutorials closely, you'll recognize them right away). A list of errors from the first printing of sed & awk is available at <http://www.cs.colostate.edu/~dzubera/sedawk.txt>, and errors in the 2nd are at <http://www.cs.colostate.edu/~dzubera/sedawk2.txt>, though most of these were corrected in later printings. The second edition tells how POSIX standards have affected these tools and covers the popular GNU versions of sed and awk. Price is about (US) $30.00

-----

       Mastering Regular Expressions, 2d ed., by Jeffrey E. F. Friedl
       (Sebastopol, Calif: O'Reilly and Associates, 2002)
       ISBN 0-596-00289-0
       http://regex.info
       http://www.oreilly.com/catalog/regex2/
       http://public.yahoo.com/~jfriedl/regex/ (for the first edition)

Knowing how to use "regular expressions" is essential to effective use of most Unix tools. This book focuses on how regular expressions can be best implemented in utilities such as perl, vi, emacs, and awk, but also touches on sed as well. Friedl's home page (above) gives links to other sites which help students learn to master regular expressions. His site also gives a Perl script for determining a syntactically valid e-mail address, using regexes:

       http://public.yahoo.com/~jfriedl/regex/code.html

-----

       Awk und Sed, by Helmut Herold.
       (Bonn: Addison-Wesley, 1994; 288 pages)
       2nd edition to be released in March 2003
       ISBN 3-8273-2094-1
       http://www.addison-wesley.de/main/main.asp?page=home/bookdetails&ProductID=37214

2.3.2. Mailing list

If you are interested in learning more about sed (its syntax, using regular expressions, etc.) you are welcome to subscribe to a sed-oriented mailing list. In fact, there are two mailing lists about sed: one in English named "sed-users", moderated by Sven Guckes; and one in Portuguese named "sed-BR" (for sed-Brazil), moderated by Aurelio Marinho Jargas. The average volume of mail for "sed-users" is about 35 messages a week; the average volume of mail for "sed-BR" is about 15 messages a week.

       sed-BR mailing list:    http://br.groups.yahoo.com/group/sed-br/
       sed-users mailing list: http://groups.yahoo.com/group/sed-users/

To subscribe to sed-users, send a blank message to:

       sed-users-subscribe@yahoogroups.com

To unsubscribe from sed-users, send a blank message to:

       sed-users-unsubscribe@yahoogroups.com

2.3.3. Tutorials, electronic text

The original users manual for sed, by Lee E. McMahon, from the 7th edition UNIX Manual (1978), with the classic "Kubla Khan" example and tutorial, in formatted text format:

       http://sed.sourceforge.net/grabbag/tutorials/sed_mcmahon.txt

The source code to the preceding manual. Use "troff -ms sed" to print this file properly:

       http://plan9.bell-labs.com/7thEdMan/vol2/sed
       http://cm.bell-labs.com/7thEdMan/vol2/sed

"Do It With Sed", by Carlos Duarte

       http://www.dbnet.ece.ntua.gr/~george/sed/OLD/sedtut_1.html

"Sed: How to use sed, a special editor for modifying files automatically", by Bruce Barnett and General Electric Company

       http://www.grymoire.com/Unix/Sed.html

U-SEDIT2.ZIP, by Mike Arst (16 June 1990)

       ftp://ftp.cs.umu.se/pub/pc/u-sedit2.zip
       ftp://ftp.uni-stuttgart.de/pub/systems/msdos/util/unixlike/u-sedit2.zip
       ftp://sunsite.icm.edu.pl/vol/wojsyl/garbo/pc/editor/u-sedit2.zip
       ftp://ftp.sogang.ac.kr/pub/msdos/garbo_pc/editor/u-sedit2.zip

U-SEDIT3.ZIP, by Mike Arst (24 Jan. 1992)

       http://www.student.northpark.edu/pemente/sed/u-sedit3.zip
       CompuServe DTPFORUM, "PC DTP Utilities" library, file SEDDOC.ZIP

Another sed FAQ

       http://www.dreamwvr.com/sed-info/sed-faq.html

sed-tutorial, by Felix von Leitner

       http://www.math.fu-berlin.de/~leitner/sed/tutorial.html

"Manipulating text with sed," chapter 14 of the SCO OpenServer "Operating System Users Guide"

       http://ou800doc.caldera.com/SHL_automate/CTOC-Manipulating_text_with_sed.html

"Combining the Bourne-shell, sed and awk in the UNIX environment for language analysis," by Lothar Schmitt and Kiel Christianson. This basic tutorial on the Bourne shell, sed and awk downloads as a 71-page PostScript file (compressed to 290K with gzip). You may need to navigate down from the root to get the file.

       ftp://ftp.u-aizu.ac.jp/u-aizu/doc/Tech-Report/1997/97-2-007.tar.gz
       available upon request from Lothar Schmitt <lothar@u-aizu.ac.jp>

2.3.4. General web and ftp sites

       http://sed.sourceforge.net/grabbag             # Collected scripts
       http://main.rtfiber.com.tw/~changyj/sed/       # Yao-Jen Chang
       http://www.math.fu-berlin.de/~guckes/sed/      # Sven Guckes
       http://www.math.fu-berlin.de/~leitner/sed/     # Felix von Leitner
       http://www.dbnet.ece.ntua.gr/~george/sed/      # Yiorgos Adamopoulos
       http://www.student.northpark.edu/pemente/sed/  # Eric Pement

       http://spacsun.rice.edu/FAQ/sed.html
       ftp://algos.inesc.pt/pub/users/cdua/scripts.tar.gz (sed and shell scripts)

"Handy One-Liners For Sed", compiled by Eric Pement. A large list of 1-line sed commands which can be executed from the command line.

       http://sed.sourceforge.net/sed1line.txt
       http://www.student.northpark.edu/pemente/sed/sed1line.txt

"Handy One-Liners For Sed", translated to Portuguese

       http://wmaker.lrv.ufsc.br/sed_ptBR.html

The Single UNIX Specification, Version 3 (technical man page)

       http://www.opengroup.org/onlinepubs/007904975/utilities/sed.html

Getting started with sed

       http://www.cs.hmc.edu/tech_docs/qref/sed.html

masm to gas converter

       http://www.delorie.com/djgpp/faq/converting/asm2s-sed.html

mail2html.zip

       http://www.crispen.org/src/#mail2html

sample uses of sed in batch files and scripts (Benny Pederson)

       http://users.cybercity.dk/~bse26236/batutil/help/SED.HTM

dc.sed - the most complex and impressive sed script ever written. This sed script by Greg Ubben emulates the Unix dc (desk calculator), including base conversion, exponentiation, square roots, and much more.

       http://sed.sourceforge.net/grabbag/scripts/dc_overview.htm

If you should find other tutorials or scripts that should be added to this document, please forward the URLs to the FAQ maintainer.

This is the end of Section 2 of the sed FAQ.
Go back to Section 1, or forward to Section 3.
Go up to the index.


AV+EdgItto lockscreen kbdin pis0854po
lsiren


This is Section 3 of the sed FAQ.
Go back to Section 2, or forward to Section 4.
Go up to the index.

3. TECHNICAL
3.1. More detailed explanation of basic sed

Sed takes a script of editing commands and applies each command, in order, to each line of input. After all the commands have been applied to the first line of input, that line is output. A second input line is taken for processing, and the cycle repeats. Sed scripts can address a single line by line number or by matching a /RE pattern/ on the line. An exclamation mark '!' after a regex ('/RE/!') or line number will select all lines that do NOT match that address. Sed can also address a range of lines in the same manner, using a comma to separate the 2 addresses.

     $d               # delete the last line of the file
     /[0-9]\{3\}/p    # print lines with 3 consecutive digits
     5!s/ham/cheese/  # except on line 5, replace 'ham' with 'cheese'
     /awk/!s/aaa/bb/  # unless 'awk' is found, replace 'aaa' with 'bb'
     17,/foo/d        # delete all lines from line 17 up to 'foo'

Following an address or address range, sed accepts curly braces '{...}' so several commands may be applied to that line or to the lines matched by the address range. On the command line, semicolons ';' separate each instruction and must precede the closing brace.

     sed '/Owner:/{s/yours/mine/g;s/your/my/g;s/you/me/g;}' file

Range addresses operate differently depending on which version of sed is used (see section 3.4, below). For further information on using sed, consult the references in section 2.3, above.
3.1.1. Regular expressions on the left side of "s///"

All versions of sed support Basic Regular Expressions (BREs). For the syntax of BREs, enter "man ed" at a Unix shell prompt. A technical description of BREs from IEEE POSIX 1003.1-2001 and the Single UNIX Specification Version 3 is available online at: http://www.opengroup.org/onlinepubs/007904975/basedefs/xbd_chap09.html#tag_09_03

Sed normally supports BREs plus '\n' to match a newline in the pattern space, plus '\xREx' as equivalent to '/RE/', where 'x' is any character other than a newline or another backslash.

Some versions of sed support supersets of BREs, or "extended regular expressions", which offer additional metacharacters for increased flexibility. For additional information on extended REs in GNU sed, see sections 3.7 ("GNU/POSIX extensions to regular expressions") and 6.7.3 ("Special syntax in REs"), below.

Though not required by BREs, some versions of sed support \t to represent a TAB, \r for carriage return, \xHH for direct entry of hex codes, and so forth. Other versions of sed do not.

ssed (super-sed) introduced many new features for LHS pattern matching, too many to give here. The complete list is found in section 6.7.3.H ("ssed"), below.
3.1.2. Escape characters on the right side of "s///"

The right-hand side (the replacement part) in "s/find/replace/" is almost always a string literal, with no interpolation of these metacharacters:

       .   ^   $   [   ]   {   }   (   )  ?   +   *

Three things are interpolated: ampersand (&), backreferences, and options for special seds. An ampersand on the RHS is replaced by the entire expression matched on the LHS. There is never any reason to use grouping like this:

       s/\(some-complex-regex\)/one two \1 three/

since you can do this instead:

       s/some-complex-regex/one two & three/

To enter a literal ampersand on the RHS, type '\&'.

Grouping and backreferences: All versions of sed support grouping and backreferences on the LHS and backreferences only on the RHS. Grouping allows a series of characters to be collected in a set, indicating the boundaries of the set with \( and \). Then the set can be designated to be repeated a certain number of times

       \(like this\)*   or   \(like this\)\{5,7\}.

Groups can also be nested "\(like \(this\) is here\)" and may contain any valid RE. Backreferences repeat the contents of a particular group, using a backslash and a digit (1-9) for each corresponding group. In other words, "/\(pom\)\1/" is another way of writing "/pompom/". If groups are nested, backreference numbers are counted by matching \( in strict left to right order. Thus, /..\(the \(word\)\) \("foo"\)../ is matched by the backreference \3. Backreferences can be used in the LHS, the RHS, and in normal RE addressing (see section 3.3). Thus,

       /\(.\)\1\(.\)\2\(.\)\3/;      # matches "bookkeeper"
       /^\(.\)\(.\)\(.\)\3\2\1$/;    # finds 6-letter palindromes

Seds differ in how they treat invalid backreferences where no corresponding group occurs. To insert a literal ampersand or backslash into the RHS, prefix it with a backslash: \& or \\.

ssed, sed16, and sedmod permit additional options on the RHS. They all support changing part of the replacement string to upper case (\u or \U), lower case (\l or \L), or to end case conversion (\E). Both sed16 and sedmod support awk-style word references ($1, $2, $3, ...) and $0 to insert the entire line before conversion.

     echo ab ghi | sed16 "s/.*/$0 - \U$2/"   # prints "ab ghi - GHI"

*Note:* This feature of sed16 and sedmod will break sed scripts which put a dollar sign and digit into the RHS. Though this is an unlikely combination, it's worth remembering if you use other people's scripts.
3.1.3. Substitution switches

Standard versions of sed support 4 main flags or switches which may be added to the end of an "s///" command. They are:

       N      - Replace the Nth match of the pattern on the LHS, where
                N is an integer between 1 and 512. If N is omitted,
                the default is to replace the first match only.
       g      - Global replace of all matches to the pattern.
       p      - Print the results to stdout, even if -n switch is used.
       w file - Write the pattern space to 'file' if a replacement was
                done. If the file already exists when the script is
                executed, it is overwritten. During script execution,
                w appends to the file for each match.

GNU sed 3.02 and ssed also offer the /I switch for doing a case-insensitive match. For example,

     echo ONE TWO | gsed "s/one/unos/I"      # prints "unos TWO"

GNU sed 4.x and ssed add the /M switch, to simplify working with multi-line patterns: when it is used, ^ or $ will match BOL or EOL. \` and \' remain available to match the start and end of pattern space, respectively.

ssed supports two more switches, /S and /X, when its Perl mode is used. They are described in detail in section 6.7.3.H, below.
3.1.4. Command-line switches

All versions of sed support two switches, -e and -n. Though sed usually separates multiple commands with semicolons (e.g., "H;d;"), certain commands could not accept a semicolon command separator. These include :labels, 't', and 'b'. These commands had to occur last in a script, separated by -e option switches. For example:

     # The 'ta' means jump to label :a if last s/// returns true
     sed -e :a -e '$!N;s/\n=/ /;ta' -e 'P;D' file

The -n switch turns off sed's default behavior of printing every line. With -n, lines are printed only if explicitly told to. In addition, for certain versions of sed, if an external script begins with "#n" as its first two characters, the output is suppressed (exactly as if -n had been entered on the command line). A list of which versions appears in section 6.7.2., below.

GNU sed 4.x and ssed support additional switches. -l (lowercase L), followed by a number, lets you adjust the default length of the 'l' and 'L' commands (note that these implementations of sed also support an argument to these commands, to tailor the length separately of each occurrence of the command).

-i activates in-place editing (see section 4.41.1, below). -s treats each file as a separate stream: sed by default joins all the files, so $ represents the last line of the last file; 15 means the 15th line in the joined stream; and /abc/,/def/ might match across files.

When -s is used, however all addresses refer to single files. For example, $ represents the last line of each input file; 15 means the 15th line of each input file; and /abc/,/def/ will be "reset" (in other words, sed will not execute the commands and start looking for /abc/ again) if a file ends before /def/ has been matched. Note that -i automatically activates this interpretation of addresses.
3.2. Common one-line sed scripts

A separate document of over 70 handy "one-line" sed commands is available at

       http://sed.sourceforge.net/sed1line.txt

Here are several common sed commands for one-line use. MS-DOS users should replace single quotes ('...') with double quotes ("...") in these examples. A specific filename usually follows the script, though the input may also come via piping or redirection.

   # Double space a file
   sed G file

   # Triple space a file
   sed 'G;G' file

   # Under UNIX: convert DOS newlines (CR/LF) to Unix format
   sed 's/.$//' file    # assumes that all lines end with CR/LF
   sed 's/^M$// file    # in bash/tcsh, press Ctrl-V then Ctrl-M

   # Under DOS: convert Unix newlines (LF) to DOS format
   sed 's/$//' file                     # method 1
   sed -n p file                        # method 2

   # Delete leading whitespace (spaces/tabs) from front of each line
   # (this aligns all text flush left). '^t' represents a true tab
   # character. Under bash or tcsh, press Ctrl-V then Ctrl-I.
   sed 's/^[ ^t]*//' file

   # Delete trailing whitespace (spaces/tabs) from end of each line
   sed 's/[ ^t]*$//' file               # see note on '^t', above

   # Delete BOTH leading and trailing whitespace from each line
   sed 's/^[ ^t]*//;s/[ ^]*$//' file    # see note on '^t', above

   # Substitute "foo" with "bar" on each line
   sed 's/foo/bar/' file        # replaces only 1st instance in a line
   sed 's/foo/bar/4' file       # replaces only 4th instance in a line
   sed 's/foo/bar/g' file       # replaces ALL instances within a line

   # Substitute "foo" with "bar" ONLY for lines which contain "baz"
   sed '/baz/s/foo/bar/g' file

   # Delete all CONSECUTIVE blank lines from file except the first.
   # This method also deletes all blank lines from top and end of file.
   # (emulates "cat -s")
   sed '/./,/^$/!d' file       # this allows 0 blanks at top, 1 at EOF
   sed '/^$/N;/\n$/D' file     # this allows 1 blank at top, 0 at EOF

   # Delete all leading blank lines at top of file (only).
   sed '/./,$!d' file

   # Delete all trailing blank lines at end of file (only).
   sed -e :a -e '/^\n*$/{$d;N;};/\n$/ba' file

   # If a line ends with a backslash, join the next line to it.
   sed -e :a -e '/\\$/N; s/\\\n//; ta' file

   # If a line begins with an equal sign, append it to the previous
   # line (and replace the "=" with a single space).
   sed -e :a -e '$!N;s/\n=/ /;ta' -e 'P;D' file

3.3. Addressing and address ranges

Sed commands may have an optional "address" or "address range" prefix. If there is no address or address range given, then the command is applied to all the lines of the input file or text stream. Three commands cannot take an address prefix:

    labels, used to branch or jump within the script
    the close brace, '}', which ends the '{' "command"
    the '#' comment character, also technically a "command"

An address can be a line number (such as 1, 5, 37, etc.), a regular expression (written in the form /RE/ or \xREx where 'x' is any character other than '\' and RE is the regular expression), or the dollar sign ($), representing the last line of the file. An exclamation mark (!) after an address or address range will apply the command to every line EXCEPT the ones named by the address. A null regex ("//") will be replaced by the last regex which was used. Also, some seds do not support \xREx as regex delimiters.

     5d               # delete line 5 only
     5!d              # delete every line except line 5
     /RE/s/LHS/RHS/g  # substitute only if RE occurs on the line
     /^$/b label      # if the line is blank, branch to ':label'
     /./!b label      # ... another way to write the same command
     \%.%!b label     # ... yet another way to write this command
     $!N              # on all lines but the last, get the Next line

Note that an embedded newline can be represented in an address by the symbol \n, but this syntax is needed only if the script puts 2 or more lines into the pattern space via the N, G, or other commands. The \n symbol does not match the newline at an end-of-line because when sed reads each line into the pattern space for processing, it strips off the trailing newline, processes the line, and adds a newline back when printing the line to standard output. To match the end-of-line, use the '$' metacharacter, as follows:

     /tape$/       # matches the word 'tape' at the end of a line
     /tape$deck/   # matches the word 'tape$deck' with a literal '$'
     /tape\ndeck/  # matches 'tape' and 'deck' with a newline between

The following sed commands usually accept only a single address. All other commands (except labels, '}', and '#') accept both single addresses and address ranges.

     =       print to stdout the line number of the current line
     a       after printing the current line, append "text" to stdout
     i       before printing the current line, insert "text" to stdout
     q       quit after the current line is matched
     r file  prints contents of "file" to stdout after line is matched

Note that we said "usually." If you need to apply the '=', 'a', 'i', or 'r' commands to each and every line within an address range, this behavior can be coerced by the use of braces. Thus, "1,9=" is an invalid command, but "1,9{=;}" will print each line number followed by its line for the first 9 lines (and then print the rest of the rest of the file normally).

Address ranges occur in the form

       <address1>,<address2>    or    <address1>,<address2>!

where the address can be a line number or a standard /regex/. <address2> can also be a dollar sign, indicating the end of file. Under GNU sed 3.02+, ssed, and sed15+, <address2> may also be a notation of the form +num, indicating the next num lines after <address1> is matched.

Address ranges are:

(1) Inclusive. The range "/From here/,/eternity/" matches all the lines containing "From here" up to and including the line containing "eternity". It will not stop on the line just prior to "eternity". (If you don't like this, see section 4.24.)

(2) Plenary. They always match full lines, not just parts of lines. In other words, a command to change or delete an address range will change or delete whole lines; it won't stop in the middle of a line.

(3) Multi-linear. Address ranges normally match 2 lines or more. The second address will never match the same line the first address did; therefore a valid address range always spans at least two lines, with these exceptions which match only one line:

    if the first address matches the last line of the file
    if using the syntax "/RE/,3" and /RE/ occurs only once in the file at line 3 or below
    if using HHsed v1.5. See section 3.4.

(4) Minimalist. In address ranges with /regex/ as <address2>, the range "/foo/,/bar/" will stop at the first "bar" it finds, provided that "bar" occurs on a line below "foo". If the word "bar" occurs on several lines below the word "foo", the range will match all the lines from the first "foo" up to the first "bar". It will not continue hopping ahead to find more "bar"s. In other words, address ranges are not "greedy," like regular expressions.

(5) Repeating. An address range will try to match more than one block of lines in a file. However, the blocks cannot nest. In addition, a second match will not "take" the last line of the previous block. For example, given the following text,

       start
       stop  start
       stop

the sed command '/start/,/stop/d' will only delete the first two lines. It will not delete all 3 lines.

(6) Relentless. If the address range finds a "start" match but doesn't find a "stop", it will match every line from "start" to the end of the file. Thus, beware of the following behaviors:

     /RE1/,/RE2/  # If /RE2/ is not found, matches from /RE1/ to the
                  # end-of-file.

     20,/RE/      # If /RE/ is not found, matches from line 20 to the
                  # end-of-file.

     /RE/,30      # If /RE/ occurs any time after line 30, each
                  # occurrence will be matched in sed15+, sedmod, and
                  # GNU sed v3.02+. GNU sed v2.05 and 1.18 will match
                  # from the 2nd occurrence of /RE/ to the end-of-file.

If these behaviors seem strange, remember that they occur because sed does not look "ahead" in the file. Doing so would stop sed from being a stream editor and have adverse effects on its efficiency. If these behaviors are undesirable, they can be circumvented or corrected by the use of nested testing within braces. The following scripts work under GNU sed 3.02:

     # Execute your_commands on range "/RE1/,/RE2/", but if /RE2/ is
     # not found, do nothing.
     /RE1/{:a;N;/RE2/!ba;your_commands;}

     # Execute your_commands on range "20,/RE/", but if /RE/ is not
     # found, do nothing.
     20{:a;N;/RE/!ba;your_commands;}

As a side note, once we've used N to "slurp" lines together to test for the ending expression, the pattern space will have gathered many lines (possibly thousands) together and concatenated them as a single expression, with the \n sequence marking line breaks. The REs within the pattern space may have to be modified (e.g., you must write '/\nStart/' instead of '/^Start/' and '/[^\n]*/' instead of '/.*/') and other standard sed commands will be unavailable or difficult to use.

     # Execute your_commands on range "/RE/,30", but if /RE/ occurs
     # on line 31 or later, do not match it.
     1,30{/RE/,$ your_commands;}

For related suggestions on using address ranges, see sections 4.2, 4.15, and 4.19 of this FAQ. Also, note the following section.
3.4. Address ranges in GNU sed and HHsed

(1) GNU sed 3.02+, ssed, and sed15+ all support address ranges like:

       /regex/,+5

which match /regex/ plus the next 5 lines (or EOF, whichever comes first).

(2) GNU sed v3.02.80 (and above) and ssed support address ranges of:

       0,/regex/

as a special case to permit matching /regex/ if it occurs on the first line. This syntax permits a range expression that matches every line from the top of the file to the first instance of /regex/, even if /regex/ is on the first line.

(3) HHsed (sed15) has an exceptional way of implementing

       /regex1/,/regex2/

If /RE1/ and /RE2/ both occur on the same line, HHsed will match that single line. In other words, an address range block can consist of just one line. HHsed will then look for the next occurrence of /regex1/ to begin the block again.

Every other version of sed (including sed16) requires 2 lines to match an address range, and thus /regex1/ and /regex2/ cannot successfully match just one line. See also the comments at section 7.9.4, below.

(4) BEGIN~STEP selection: ssed and GNU sed (v2.05 and above) offer a form of addressing called "BEGIN~STEP selection". This is not a range address, which selects an inclusive block of consecutive lines from /start/ to /finish/. But I think it seems to belong here.

Given an expression of the form "M~N", where M and N are integers, GNU sed and ssed will select every Nth line, beginning at line M. (With gsed v2.05, M had to be less than N, but this restriction is no longer necessary). Both M and N may equal 0 ("0~0" selects every line). These examples illustrate the syntax:

     sed '1~3d' file      # delete every 3d line, starting with line 1
                          # deletes lines 1, 4, 7, 10, 13, 16, ...

     sed '0~3d' file      # deletes lines 3, 6, 9, 12, 15, 18, ...

     sed -n '2~5p' file   # print every 5th line, starting with line 2
                          # prints lines 2, 7, 12, 17, 22, 27, ...

(5) Finally, GNU sed v2.05 has a bug in range addressing (see section 7.5), which was fixed in the higher versions.
3.5. Debugging sed scripts

The following two debuggers should make it easier to understand how sed scripts operate. They can save hours of grief when trying to determine the problems with a sed script.

(1) sd (sed debugger), by Brian Hiles

This debugger runs under a Unix shell, is powerful, and is easy to use. sd has conditional breakpoints and spypoints of the pattern space and hold space, on any scope defined by regex match and/or script line number. It can be semi-automated, can save diagnostic reports, and shows potential problems with a sed script before it tries to execute it. The script is robust and requires the Unix shell utilities plus the Bourne shell or Korn shell to execute.

       http://sed.sourceforge.net/grabbag/scripts/sd.ksh.txt (2003)
       http://sed.sourceforge.net/grabbag/scripts/sd.sh.txt  (1998)

(2) sedsed, by Aurelio Jargas

This debugger requires Python to run it, and it uses your own version of sed, whatever that may be. It displays the current input line, the pattern space, and the hold space, before and after each sed command is executed.

       http://sedsed.sourceforge.net

3.6. Notes about s2p, the sed-to-perl translator

s2p (sed to perl) is a Perl program to convert sed scripts into the Perl programming language; it is included with many versions of Perl. These problems have been found when using s2p:

(1) Doesn't recognize the semicolon properly after s/// commands.

       s/foo/bar/g;

(2) Doesn't trim trailing whitespace after s/// commands. Even lone trailing spaces, without comments, produce an error.

(3) Doesn't handle multiple commands within braces. E.g.,

       1,4{=;G;}

will produce perl code with missing braces, and miss the second "G" command as well. In fact, any commands after the first one are missed in the perl output script, and the output perl script will also contain mismatched braces.
3.7. GNU/POSIX extensions to regular expressions

GNU sed supports "character classes" in addition to regular character sets, such as [0-9A-F]. Like regular character sets, character classes represent any single character within a set.

"Character classes are a new feature introduced in the POSIX standard. A character class is a special notation for describing lists of characters that have a specific attribute, but where the actual characters themselves can vary from country to country and/or from character set to character set. For example, the notion of what is an alphabetic character differs in the USA and in France." [quoted from the docs for GNU awk v3.1.0.]

Though character classes don't generally conserve space on the line, they help make scripts portable for international use. The equivalent character sets for U.S. users follows:

     [[:alnum:]]  - [A-Za-z0-9]     Alphanumeric characters
     [[:alpha:]]  - [A-Za-z]        Alphabetic characters
     [[:blank:]]  - [ \x09]         Space or tab characters only
     [[:cntrl:]]  - [\x00-\x19\x7F] Control characters
     [[:digit:]]  - [0-9]           Numeric characters
     [[:graph:]]  - [!-~]           Printable and visible characters
     [[:lower:]]  - [a-z]           Lower-case alphabetic characters
     [[:print:]]  - [ -~]           Printable (non-Control) characters
     [[:punct:]]  - [!-/:-@[-`{-~]  Punctuation characters
     [[:space:]]  - [ \t\v\f]       All whitespace chars
     [[:upper:]]  - [A-Z]           Upper-case alphabetic characters
     [[:xdigit:]] - [0-9a-fA-F]     Hexadecimal digit characters

Note that [[:graph:]] does not match the space " ", but [[:print:]] does. Some character classes may (or may not) match characters in the high ASCII range (ASCII 128-255 or 0x80-0xFF), depending on which C library was used to compile sed. For non-English languages, [[:alpha:]] and other classes may also match high ASCII characters.

This is the end of Section 3 of the sed FAQ.
Go back to Section 2, or forward to Section 4.
Go up to the index.


Sa+VEgdItto lockscreen kbdin pis0854polsiren


This is Section 4 of the sed FAQ.
Go back to Section 3, or forward to Section 5.
Go up to the index.

4. EXAMPLES
ONE-CHARACTER QUESTIONS
4.1. How do I insert a newline into the RHS of a substitution?

Several versions of sed permit '\n' to be typed directly into the RHS, which is then converted to a newline on output: ssed, gsed302a+, gsed103 (with the -x switch), sed15+, sedmod, and UnixDOS sed. The easiest solution is to use one of these versions.

For other versions of sed, try one of the following:

(a) If typing the sed script from a Bourne shell, use one backslash "\" if the script uses 'single quotes' or two backslashes "\\" if the script requires "double quotes". In the example below, note that the leading '>' on the 2nd line is generated by the shell to prompt the user for more input. The user types in slash, single-quote, and then ENTER to terminate the command:

     [sh-prompt]$ echo twolines | sed 's/two/& new\
     >/'
     two new
     lines
     [bash-prompt]$

(b) Use a script file with one backslash '\' in the script, immediately followed by a newline. This will embed a newline into the "replace" portion. Example:

     sed -f newline.sed files

     # newline.sed
     s/twolines/two new\
     lines/g

Some versions of sed may not need the trailing backslash. If so, remove it.

(c) Insert an unused character and pipe the output through tr:

     echo twolines | sed 's/two/& new=/' | tr "=" "\n"   # produces
     two new
     lines

(d) Use the "G" command:

G appends a newline, plus the contents of the hold space to the end of the pattern space. If the hold space is empty, a newline is appended anyway. The newline is stored in the pattern space as "\n" where it can be addressed by grouping "\(...\)" and moved in the RHS. Thus, to change the "twolines" example used earlier, the following script will work:

     sed '/twolines/{G;s/\(two\)\(lines\)\(\n\)/\1\3\2/;}'

(e) Inserting full lines, not breaking lines up:

If one is not changing lines but only inserting complete lines before or after a pattern, the procedure is much easier. Use the "i" (insert) or "a" (append) command, making the alterations by an external script. To insert "This line is new" BEFORE each line matching a regex:

     /RE/i This line is new               # HHsed, sedmod, gsed 3.02a
     /RE/{x;s/$/This line is new/;G;}     # other seds

The two examples above are intended as "one-line" commands entered from the console. If using a sed script, "i\" immediately followed by a literal newline will work on all versions of sed. Furthermore, the command "s/$/This line is new/" will only work if the hold space is already empty (which it is by default).

To append "This line is new" AFTER each line matching a regex:

     /RE/a This line is new               # HHsed, sedmod, gsed 3.02a
     /RE/{G;s/$/This line is new/;}       # other seds

To append 2 blank lines after each line matching a regex:

     /RE/{G;G;}                    # assumes the hold space is empty

To replace each line matching a regex with 5 blank lines:

     /RE/{s/.*//;G;G;G;G;}         # assumes the hold space is empty

(f) Use the "y///" command if possible:

On some Unix versions of sed (not GNU sed!), though the s/// command won't accept '\n' in the RHS, the y/// command does. If your Unix sed supports it, a newline after "aaa" can be inserted this way (which is not portable to GNU sed or other seds):

     s/aaa/&~/; y/~/\n/;    # assuming no other '~' is on the line!

4.2. How do I represent control-codes or nonprintable characters?

Several versions of sed support the notation \xHH, where "HH" are two hex digits, 00-FF: ssed, GNU sed v3.02.80 and above, GNU sed v1.03, sed16 and sed15 (HHsed). Try to use one of those versions.

Sed is not intended to process binary or object code, and files which contain nulls (0x00) will usually generate errors in most versions of sed. The latest versions of GNU sed and ssed are an exception; they permit nulls in the input files and also in regexes.

On Unix platforms, the 'echo' command may allow insertion of octal or hex values, e.g., `echo "\0nnn"` or `echo -n "\0nnn"`. The echo command may also support syntax like '\\b' or '\\t' for backspace or tab characters. Check the man pages to see what syntax your version of echo supports. Some versions support the following:

     # replace 0x1A (32 octal) with ASCII letters
     sed 's/'`echo "\032"`'/Ctrl-Z/g'

     # note the 3 backslashes in the command below
     sed "s/.`echo \\\b`//g"

4.3. How do I convert files with toggle characters, like +this+, to look like [i]this[/i]?

Input files, especially message-oriented text files, often contain toggle characters for emphasis, like ~this~, this, or =this=. Sed can make the same input pattern produce alternating output each time it is encountered. Typical needs might be to generate HMTL codes or print codes for boldface, italic, or underscore. This script accomodates multiple occurrences of the toggle pattern on the same line, as well as cases where the pattern starts on one line and finishes several lines later, even at the end of the file:

     # sed script to convert +this+ to [i]this[/i]
     :a
     /+/{ x;        # If "+" is found, switch hold and pattern space
       /^ON/{       # If "ON" is in the (former) hold space, then ..
         s///;      # .. delete it
         x;         # .. switch hold space and pattern space back
         s|+|[/i]|; # .. turn the next "+" into "[/i]"
         ba;        # .. jump back to label :a and start over
       }
     s/^/ON/;       # Else, "ON" was not in the hold space; create it
     x;             # Switch hold space and pattern space
     s|+|[i]|;      # Turn the first "+" into "[i]"
     ba;            # Branch to label :a to find another pattern
     }
     #---end of script---

This script uses the hold space to create a "flag" to indicate whether the toggle is ON or not. We have added remarks to illustrate the script logic, but in most versions of sed remarks are not permitted after 'b'ranch commands or labels.

If you are sure that the +toggle+ characters never cross line boundaries (i.e., never begin on one line and end on another), this script can be reduced to one line:

     s|+\([^+][^+]*\)+|[i]\1[/i]|g

If your toggle pattern contains regex metacharacters (such as '*' or perhaps '+' or '?'), remember to quote them with backslashes.
CHANGING STRINGS
4.10. How do I perform a case-insensitive search?

Several versions of sed support case-insensitive matching: ssed and GNU sed v3.02+ (with I flag after s/// or /regex/); sedmod with the -i switch; and sed16 (which supports both types of switches).

With other versions of sed, case-insensitive searching is awkward, so people may use awk or perl instead, since these programs have options for case-insensitive searches. In gawk/mawk, use "BEGIN {IGNORECASE=1}" and in perl, "/regex/i". For other seds, here are three solutions:

Solution 1: convert everything to upper case and search normally

     # sed script, solution 1
     h;          # copy the original line to the hold space
                 # convert the pattern space to solid caps
     y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/
                 # now we can search for the word "CARLOS"
     /CARLOS/ {
          # add or insert lines. Note: "s/.../.../" will not work
          # here because we are searching a modified pattern
          # space and are not printing the pattern space.
     }
     x;          # get back the original pattern space
                 # the original pattern space will be printed
     #---end of sed script---

Solution 2: search for both cases

Often, proper names will either start with all lower-case ("unix"), with an initial capital letter ("Unix") or occur in solid caps ("UNIX"). There may be no need to search for every possibility.

     /UNIX/b match
     /[Uu]nix/b match

Solution 3: search for all possible cases

     # If you must, search for any possible combination
     /[Ca][Aa][Rr][Ll][Oo][Ss]/ { ... }

Bear in mind that as the pattern length increases, this solution becomes an order of magnitude slower than the one of Solution 1, at least with some implementations of sed.
4.11. How do I match only the first occurrence of a pattern?

(1) The general solution is to use GNU sed or ssed, with one of these range expressions. The first script ("print only the first match") works with any version of sed:

     sed -n '/RE/{p;q;}' file       # print only the first match
     sed '0,/RE/{//d;}' file        # delete only the first match
     sed '0,/RE/s//to_that/' file   # change only the first match

(2) If you cannot use GNU sed and if you know the pattern will not occur on the first line, this will work:

     sed '1,/RE/{//d;}' file        # delete only the first match
     sed '1,/RE/s//to_that/' file   # change only the first match

(3) If you cannot use GNU sed and the pattern might occur on the first line, use one of the following commands (credit for short GNU script goes to Donald Bruce Stewart):

     sed '/RE/{x;/Y/!{s/^/Y/;h;d;};x;}' file       # delete (one way)
     sed -e '/RE/{d;:a' -e '$!N;$ba' -e '}' file   # delete (another way)
     sed '/RE/{d;:a;N;$ba;}' file                  # same script, GNU sed
     sed -e '/RE/{s//to_that/;:a' -e '$!N;$!ba' -e '}' file  # change

Still another solution, using a flag in the hold space. This is portable to all seds and works if the pattern is on the first line:

     # sed script to change "foo" to "bar" only on the first occurrence
     1{x;s/^/first/;x;}
     1,/foo/{x;/first/s///;x;s/foo/bar/;}
     #---end of script---

4.12. How do I parse a comma-delimited (CSV) data file?

Comma-delimited data files can come in several forms, requiring increasing levels of complexity in parsing and handling. They are often referred to as CSV files (for "comma separated values") and occasionally as SDF files (for "standard data format"). Note that some vendors use "SDF" to refer to variable-length records with comma-separated fields which are "double-quoted" if they contain character values, while other vendors use "SDF" to designate fixed-length records with fixed-length, nonquoted fields! (For help with fixed-length fields, see question 4.23)

The term "CSV" became a de-facto standard when Microsoft Excel used it as an optional output file format.

Here are 4 different forms you may encounter in comma-delimited data:

(a) No quotes, no internal commas

       1001,John Smith,PO Box 123,Chicago,IL,60699
       1002,Mary Jones,320 Main,Denver,CO,84100,

(b) Like (a), with quotes around each field

       "1003","John Smith","PO Box 123","Chicago","IL","60699"
       "1004","Mary Jones","320 Main","Denver","CO","84100"

(c) Like (b), with embedded commas

       "1005","Tom Hall, Jr.","61 Ash Ct.","Niles","OH","44446"
       "1006","Bob Davis","429 Pine, Apt. 5","Boston","MA","02128"

(d) Like (c), with embedded commas and quotes

       "1007","Sue "Red" Smith","19 Main","Troy","MI","48055"
       "1008","Joe "Hey, guy!" Hall","POB 44","Reno","NV","89504"

In each example above, we have 7 fields and 6 commas which function as field separators. Case (c) is a very typical form of these data files, with double quotes used to enclose each field and to protect internal commas (such as "Tom Hall, Jr.") from interpretation as field separators. However, many times the data may include both embedded quotation marks as well as embedded commas, as seen by case (d), above.

Case (d) is the closest to Microsoft CSV format. However, the Microsoft CSV format allows embedded newlines within a double-quoted field. If embedded newlines within fields are a possibility for your data, you should consider using something other than sed to work with the data file.

Before handling a comma-delimited data file, make sure that you fully understand its format and check the integrity of the data. Does each line contain the same number of fields? Should certain fields be composed only of numbers or of two-letter state abbreviations in all caps? Sed (or awk or perl) should be used to validate the integrity of the data file before you attempt to alter it or extract particular fields from the file.

After ensuring that each line has a valid number of fields, use sed to locate and modify individual fields, using the \(...\) grouping command where needed.

In case (a):

     sed 's/^[^,]*,[^,]*,[^,]*,[^,]*,/.../'
             ^     ^     ^
             |     |     |_ 3rd field
             |     |_______ 2nd field
             |_____________ 1st field

     # Unix script to delete the second field for case (a)
     sed 's/^\([^,]*\),[^,]*,/\1,,/' file

     # Unix script to change field 1 to 9999 for case (a)
     sed 's/^[^,]*,/9999,/' file

In cases (b) and (c):

     sed 's/^"[^"]*","[^"]*","[^"]*","[^"]*",/.../'
              1st--   2nd--   3rd--   4th--

     # Unix script to delete the second field for case (c)
     sed 's/^\("[^"]*"\),"[^"]*",/\1,"",/' file

     # Unix script to change field 1 to 9999 for case (c)
     sed 's/^"[^"]*",/"9999",/' file

In case (d):

One way to parse such files is to replace the 3-character field separator "," with an unused character like the tab or vertical bar. (Technically, the field separator is only the comma while the fields are surrounded by "double quotes", but the net effect is that fields are separated by quote-comma-quote, with quote characters added to the beginning and end of each record.) Search your datafile first to make sure that your character appears nowhere in it!

     sed -n '/|/p' file        # search for any instance of '|'
     # if it's not found, we can use the '|' to separate fields

Then replace the 3-character field separator and parse as before:

     # sed script to delete the second field for case (d)
     s/","/|/g;                  # global change of "," to bar
     s/^\([^|]*\)|[^|]|/\1||/;   # delete 2nd field
     s/|/","/g;                  # global change of bar back to ","
     #---end of script---

     # sed script to change field 1 to 9999 for case (d)
     # Remember to accommodate leading and trailing quote marks
     s/","/|/g;
     s/^[^|]*|/"9999|/;
     s/|/","/g;
     #---end of script---

Note that this technique works only if each and every field is surrounded with double quotes, including empty fields.

The following solution is for more complex examples of (d), such as: not all fields contain "double-quote" marks, or the presence of embedded "double-quote" marks within fields, or extraneous whitespace around field delimiters. (Thanks to Greg Ubben for this script!)

     # sed script to convert case (d) to bar-delimited records
     s/^ *\(.*[^ ]\) *$/|\1|/;
     s/" *, */"|/g;
     : loop
     s/| *\([^",|][^,|]*\) *, */|\1|/g;
     s/| *, */|\1|/g;
     t loop
     s/  *|/|/g;
     s/|  */|/g;
     s/^|\(.*\)|$/\1/;
     #---end of script---

For example, it turns this (which is badly-formed but legal):

   first,"",unquoted ,""this" is, quoted " ,, sub "quote" inside, f", lone  " empty:

into this:

   first|""|unquoted|""this" is, quoted "||sub "quote" inside|f"|lone  "   empty:

Note that the script preserves the "double-quote" marks, but changes only the commas where they are used as field separators. I have used the vertical bar "|" because it's easier to read, but you may change this to another field separator if you wish.

If your CSV datafile is more complex, it would probably not be worth the effort to write it in sed. For such a case, you should use Perl with a dedicated CSV module (there are at least two recent CSV parsers available from CPAN).
4.13. How do I handle fixed-length, columnar data?

Sed handles fixed-length fields via \(grouping\) and backreferences (\1, \2, \3 ...). If we have 3 fields of 10, 25, and 9 characters per field, our sed script might look like so:

     s/^\(.\{10\}\)\(.\{25\}\)\(.\{9\}\)/\3\2\1/;  # Change the fields
        ^^^^^^^^^^^~~~~~~~~~~~==========           #   from 1,2,3 to 3,2,1
         field #1   field #2   field #3

This is a bit hard to read. By using GNU sed or ssed with the -r switch active, it can look like this:

     s/^(.{10})(.{25})(.{9})/\3\2\1/;          # Using the -r switch

To delete a field in sed, use grouping and omit the backreference from the field to be deleted. If the data is long or difficult to work with, use ssed with the -R switch and the /x flag after an s/// command, to insert comments and remarks about the fields.

For records with many fields, use GNU awk with the FIELDWIDTHS variable set in the top of the script. For example:

     awk 'BEGIN{FIELDWIDTHS = "10 25 9"}; {print $3 $2 $1}' file

This is much easier to read than a similar sed script, especially if there are more than 5 or 6 fields to manipulate.
4.14. How do I commify a string of numbers?

Use the simplest script necessary to accomplish your task. As variations of the line increase, the sed script must become more complex to handle additional conditions. Whole numbers are simplest, followed by decimal formats, followed by embedded words.

Case 1: simple strings of whole numbers separated by spaces or commas, with an optional negative sign. To convert this:

       4381, -1222333, and 70000: - 44555666 1234567890 words
       56890  -234567, and 89222  -999777  345888777666 chars

to this:

       4,381, -1,222,333, and 70,000: - 44,555,666 1,234,567,890 words
       56,890  -234,567, and 89,222  -999,777  345,888,777,666 chars

use one of these one-liners:

     sed ':a;s/\B[0-9]\{3\}\>/,&/;ta'                      # GNU sed
     sed -e :a -e 's/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/;ta'  # other seds

Case 2: strings of numbers which may have an embedded decimal point, separated by spaces or commas, with an optional negative sign. To change this:

       4381,  -6555.1212 and 70000,  7.18281828  44906982.071902
       56890   -2345.7778 and 8.0000:  -49000000 -1234567.89012

to this:

       4,381,  -6,555.1212 and 70,000,  7.18281828  44,906,982.071902
       56,890   -2,345.7778 and 8.0000:  -49,000,000 -1,234,567.89012

use the following command for GNU sed:

     sed ':a;s/\(^\|[^0-9.]\)\([0-9]\+\)\([0-9]\{3\}\)/\1\2,\3/g;ta'

and for other versions of sed:

     sed -f case2.sed files

     # case2.sed
     s/^/ /;                 # add space to start of line
     :a
     s/\( [-0-9]\{1,\}\)\([0-9]\{3\}\)/\1,\2/g
     ta
     s/ //;                  # remove space from start of line
     #---end of script---

4.15. How do I prevent regex expansion on substitutions?

Sometimes you want to match regular expression metacharacters as literals (e.g., you want to match "[0-9]" or "\n"), to be replaced with something else. The ordinary way to prevent expanding metacharacters is to prefix them with a backslash. Thus, if "\n" matches a newline, "\\n" will match the two-character string of 'backslash' followed by 'n'.

But doing this repeatedly can become tedious if there are many regexes. The following script will replace alternating strings of literals, where no character is interpreted as a regex metacharacter:

     # filename: sub_quote.sed
     #   author: Paolo Bonzini
     # sed script to add backslash to find/replace metacharacters
     N;                  # add even numbered line to pattern space
     s,[]/\\$*[],\\&,g;  # quote all of [, ], /, \, $, or *
     s,^,s/,;            # prepend "s/" to front of pattern space
     s,$,/,;             # append "/" to end of pattern space
     s,\n,/,;            # change "\n" to "/", making s/from/to/
     #---end of script---

Here's a sample of how sub_quote.sed might be used. This example converts typical sed regexes to perl-style regexes. The input file consists of 10 lines:

       [0-9]
       \d
       [^0-9]
       \D
       \+
       +
       \?
       ?
       \|
       |

Run the command "sed -f sub_quote.sed input", to transform the input file (above) to 5 lines of output:

       s/\[0-9\]/\\d/
       s/\[^0-9\]/\\D/
       s/\\+/+/
       s/\\?/?/
       s/\\|/|/

The above file is itself a sed script, which can then be used to modify other files.
4.16. How do I convert a string to all lowercase or capital letters?

The easiest method is to use a new version of GNU sed, ssed, sedmod or sed16 and employ the \U, \L, or other switches on the right side of an s/// command. For example, to convert any word which begins with "reg" or "exp" into solid capital letters:

       sed -r "s/\<(reg|exp)[a-z]+/\U&/g"              # gsed4.+ or ssed
       sed "s/\<reg[a-z]+/\U&/g; s/\<exp[a-z]+/\U&/g"  # sed16 and sedmod

As you can see, sedmod and sed16 do not support alternation (|), but they do support case conversion. If none of these versions of sed are available to you, some sample scripts for this task are available from the Seder's Grab Bag:

       http://sed.sourceforge.net/grabbag/scripts

Note that some case conversion scripts are listed under "Filename manipulation" and others are under "Text formatting."
CHANGING BLOCKS (consecutive lines)
4.20. How do I change only one section of a file?

You can match a range of lines by line number, by regexes (say, all lines between the words "from" and "until"), or by a combination of the two. For multiple substitutions on the same range, put the command(s) between braces {...}. For example:

     # replace only between lines 1 and 20
     1,20 s/Johnson/White/g

     # replace everywhere EXCEPT between lines 1 and 20
     1,20 !s/Johnson/White/g

     # replace only between words "from" and "until". Note the
     # use of \<....\> as word boundary markers in GNU sed.
     /from/,/until/ { s/\<red\>/magenta/g; s/\<blue\>/cyan/g; }

     # replace only from the words "ENDNOTES:" to the end of file
     /ENDNOTES:/,$ { s/Schaff/Herzog/g; s/Kraft/Ebbing/g; }

For technical details on using address ranges, see section 3.3 ("Addressing and Address ranges").
4.21. How do I delete or change a block of text if the block contains a certain regular expression?

The following deletes the block between 'start' and 'end' inclusively, if and only if the block contains the string 'regex'. Written by Russell Davies, with additional comments:

     # sed script to delete a block if /regex/ matches inside it
     :t
     /start/,/end/ {    # For each line between these block markers..
        /end/!{         #   If we are not at the /end/ marker
           $!{          #     nor the last line of the file,
              N;        #     add the Next line to the pattern space
              bt
           }            #   and branch (loop back) to the :t label.
        }               # This line matches the /end/ marker.
        /regex/d;       # If /regex/ matches, delete the block.
     }                  # Otherwise, the block will be printed.
     #---end of script---

Note: When the script above reaches /regex/, the entire multi-line block is in the pattern space. To replace items inside the block, use "s///". To change the entire block, use the 'c' (change) command:

     /regex/c\
     1: This will replace the entire block\
     2: with these two lines of text.

4.22. How do I locate a paragraph of text if the paragraph contains a certain regular expression?

Assume that paragraphs are separated by blank lines. For regexes that are single terms, use one of the following scripts:

     sed -e '/./{H;$!d;}' -e 'x;/regex/!d'      # most seds
     sed '/./{H;$!d;};x;/regex/!d'              # GNU sed

To print paragraphs only if they contain 3 specific regular expressions (RE1, RE2, and RE3), in any order in the paragraph:

     sed -e '/./{H;$!d;}' -e 'x;/RE1/!d;/RE2/!d;/RE3/!d'

With this solution and the preceding one, if the paragraphs are excessively long (more than 4k in length), you may overflow sed's internal buffers. If using HHsed, you must add a "G;" command immediately after the "x;" in the scripts above to defeat a bug in HHsed (see section 7.9(5), below, for a description).
4.23. How do I match a block of specific consecutive lines?

There are three ways to approach this problem:

       (1) Try to use a "/range/, /expression/"
       (2) Try to use a "/multi-line\nexpression/"
       (3) Try to use a block of "literal strings"

We describe each approach in the following sections.
4.23.1. Try to use a "/range/, /expression/"

If the block of lines are strings that never change their order and if the top line never occurs outside the block, like this:

       Abel
       Baker
       Charlie
       Delta

then these solutions will work for deleting the block:

     sed 's/^Abel$/{N;N;N;d;}' files    # for blocks with few lines
     sed '/^Abel$/, /^Zebra$/d' files   # for blocks with many lines
     sed '/^Abel$/,+25d' files          # HHsed, sedmod, ssed, gsed 3.02.80

To change the block, use the 'c' (change) command instead of 'd'. To print that block only, use the -n switch and 'p' (print) instead of 'd'. To change some things inside the block, try this:

     /^Abel$/,/^Delta$/ {
         :ack
         N;
         /\nDelta$/! b ack
         # At this point, all the lines in the block are collected
         s/ubstitute /somethin/g;
     }

4.23.2. Try to use a "multi-line\nexpression"

If the top line of the block sometimes appears alone or is sometimes followed by other lines, or if a partial block may occur somewhere in the file, a multi-line expression may be required.

In these examples, we give solutions for matching an N-line block. The expression "/^RE1\nRE2\nRE3...$/" represents a properly formed regular expression where \n indicates a newline between lines. Note that the 'N' followed by the 'P;D;' commands forms a "sliding window" technique. A window of N lines is formed. If the multi-line pattern matches, the block is handled. If not, the top line is printed and then deleted from the pattern space, and we try to match at the next line.

     # sed script to delete 2 consecutive lines: /^RE1\nRE2$/
     $b
     /^RE1$/ {
       $!N
       /^RE1\nRE2$/d
       P;D
     }
     #---end of script---

     # sed script to delete 3 consecutive lines. (This script
     # fails under GNU sed v2.05 and earlier because of the 't'
     # bug when s///n is used; see section 7.5(1) of the FAQ.)
     : more
     $!N
     s/\n/&/2;
     t enough
     $!b more
     : enough
     /^RE1\nRE2\nRE3$/d
     P;D
     #---end of script---

For example, to delete a block of 5 consecutive lines, the previous script must be altered in only two places:

(1) Change the 2 in "s/\n/&/2;" to a 4 (the trailing semicolon is needed to work around a bug in HHsed v1.5).

(2) Change the regex line to "/^RE1\nRE2\nRE3\nRE4\nRE5$/d", modifying the expression as needed.

Suppose we want to delete a block of two blank lines followed by the word "foo" followed by another blank line (4 lines in all). Other blank lines and other instances of "foo" should be left alone. After changing the '2' to a '3' (always one number less than the total number of lines), the regex line would look like this: "/^\n\nfoo\n$/d". (Thanks to Greg Ubben for this script.)

As an alternative to work around the 't' bug in older versions of GNU sed, the following script will delete 4 consecutive lines:

     # sed script to delete 4 consecutive lines. Use this if you
     # require GNU sed 2.05 and below.
     /^RE1$/!b
     $!N
     $!N
     :a
     $b
     N
     /^RE1\nRE2\nRE3\nRE4$/d
     P
     s/^.*\n\(.*\n.*\n.*\)$/\1/
     ba
     #---end of script---

Its drawback is that it must be modified in 3 places instead of 2 to adapt it for more lines, and as additional lines are added, the 's' command is forced to work harder to match the regexes. On the other hand, it avoids a bug with gsed-2.05 and illustrates another way to solve the problem of deleting consecutive lines.
4.23.3. Try to use a block of "literal strings"

If you need to match a static block of text (which may occur any number of times throughout a file), where the contents of the block are known in advance, then this script is easy to use. It requires an intermediate file, which we will call "findrep.txt" (below):

       A block of several consecutive lines to
       be matched literally should be placed on
       top. Regular expressions like .*  or [a-z]
       will lose their special meaning and be
       interpreted literally in this block.
       ----
       Four hyphens separate the two sections. Put
       the replacement text in the lower section.
       As above, sed symbols like &, \n, or \1 will
       lose their special meaning.

This is a 3-step process. A generic script called "blockrep.sed" will read "findrep.txt" (above) and generate a custom script, which is then used on the actual input file. In other words, "findrep.txt" is a simplified description of the editing that you want to do on the block, and "blockrep.sed" turns it into actual sed commands.

Use this process from a Unix shell or from a DOS prompt:

     sed -nf blockrep.sed findrep.txt >custom.sed
     sed -f custom.sed input.file >output.file
     erase custom.sed

The generic script "blockrep.sed" follows below. It's fairly long. Examining its output might help you understanding how to use the sliding window technique.

     # filename: blockrep.sed
     #   author: Paolo Bonzini
     # Requires:
     #    (1) blocks to find and replace, e.g., findrep.txt
     #    (2) an input file to be changed, input.file
     #
     # blockrep.sed creates a second sed script, custom.sed,
     # to find the lines above the row of 4 hyphens, globally
     # replacing them with the lower block of text. GNU sed
     # is recommended but not required for this script.
     #
     # Loop on the first part, accumulating the `from' text
     # into the hold space.
     :a
     /^----$/! {
        # Escape slashes, backslashes, the final newline and
        # regular expression metacharacters.
        s,[/\[.*],\\&,g
        s/$/\\/
        H
        #
        # Append N cmds needed to maintain the sliding window.
        x
        1 s,^.,s/,
        1! s/^/N\
     /
        x
        n
        ba
     }
     #
     # Change the final backslash to a slash to separate the
     # two sides of the s command.
     x
     s,\\$,/,
     x
     #
     # Until EOF, gather the substitution into hold space.
     :b
     n
     s,[/\],\\&,g
     $! s/$/\\/
     H
     $! bb
     #
     # Start the RHS of the s command without a leading
     # newline, add the P/D pair for the sliding window, and
     # print the script.
     g
     s,/\n,/,
     s,$,/\
     P\
     D,p
     #---end of script---

4.24. How do I address all the lines between RE1 and RE2, excluding the lines themselves?

Normally, to address the lines between two regular expressions, RE1 and RE2, one would do this: '/RE1/,/RE2/{commands;}'. Excluding those lines takes an extra step. To put 2 arrows before each line between RE1 and RE2, except for those lines:

     sed '1,/RE1/!{ /RE2/,/RE1/!s/^/>>/; }' input.fil

The preceding script, though short, may be difficult to follow. It also requires that /RE1/ cannot occur on the first line of the input file. The following script, though it's not a one-liner, is easier to read and it permits /RE1/ to appear on the first line:

     # sed script to replace all lines between /RE1/ and /RE2/,
     # without matching /RE1/ or /RE2/
     /RE1/,/RE2/{
       /RE1/b
       /RE2/b
       s/^/>>/
     }
     #---end of script---

   Contents of input.fil:         Output of sed script:
      aaa                           aaa
      bbb                           bbb
      RE1                           RE1
      aaa                           >>aaa
      bbb                           >>bbb
      ccc                           >>ccc
      RE2                           RE2
      end                           end

4.25. How do I join two lines if line #1 ends in a [certain string]?

This question appears in the section on one-line sed scripts, but it comes up so many times that it needs a place here also. Suppose a line ends with a particular string (often, a line ends with a backslash). How do you bring up the second line after it, even in cases where several consecutive lines all end in a backslash?

     sed -e :a -e '/\\$/N; s/\\\n//; ta' file   # all seds
     sed ':a; /\\$/N; s/\\\n//; ta' file        # GNU sed, ssed, HHsed

Note that this replaces the backslash-newline with nothing. You may want to replace the backslash-newline with a single space instead.
4.26. How do I join two lines if line #2 begins in a [certain string]?

The inverse situation is another FAQ. Suppose a line begins with a particular string. How do you bring that line up to follow the previous line? In this example, we want to match the string "<<=" at the beginning of one line, bring that line up to the end of the line before it, and replace the string with a single space:

     sed -e :a -e '$!N;s/\n<<=/ /;ta' -e 'P;D' file   # all seds
     sed ':a; $!N;s/\n<<=/ /;ta;P;D' file             # GNU, ssed, sed15+

4.27. How do I change all paragraphs to long lines?

A frequent request is how to convert DOS-style textfiles, in which each line ends with "paragraph marker", to Microsoft-style textfiles, in which the "paragraph" marker only appears at the end of real paragraphs. Sometimes this question is framed as, "How do I remove the hard returns at the end of each line in a paragraph?"

The problem occurs because newer word processors don't work the same way older text editors did. Older text editors used a newline (CR/LF in DOS; LF alone in Unix) to end each line on screen or on disk, and used two newlines to separate paragraphs. Certain word processors wanted to make paragraph reformatting and reflowing work easily, so they use one newline to end a paragraph and never allow newlines within a paragraph. This means that textfiles created with standard editors (Emacs, vi, Vedit, Boxer, etc.) appear to have "hard returns" at inappropriate places. The following sed script finds blocks of consecutive nonblank lines (i.e., paragraphs of text), and converts each block into one long line with one "hard return" at the end.

     # sed script to change all paragraphs to long lines
     /./{H; $!d;}             # Put each paragraph into hold space
     x;                       # Swap hold space and pattern space
     s/^\(\n\)\(..*\)$/\2\1/; # Move leading \n to end of PatSpace
     s/\n\(.\)/ \1/g;         # Replace all other \n with 1 space
     # Uncomment the following line to remove excess blank lines:
     # /./!d;
     #---end of sed script---

If the input files have formatting or indentation that conveys special meaning (like program source code), this script will remove it. But if the text still needs to be extended, try 'par' (paragraph reformatter) or the 'fmt' utility with the -t or -c switches and the width option (-w) set to a number like 9999.
SHELL AND ENVIRONMENT
4.30. How do I read environment variables with sed?
4.30.1. - on Unix platforms

In Unix, environment variables begin with a dollar sign, such as $TERM, $PATH, $var or $i. In sed, the dollar sign is used to indicate the last line of the input file, the end of a line (in the LHS), or a literal symbol (in the RHS). Sed cannot access variables directly, so one must pay attention to shell quoting requirements to expand the variables properly.

To ALLOW the Unix shell to interpret the dollar sign, put the script in double quotes:

     sed "s/_terminal-type_/$TERM/g" input.file >output.file

To PREVENT the Unix shell from interpreting the dollar sign as a shell variable, put the script in single quotes:

     sed 's/.$//' infile >outfile

To use BOTH Unix $environment_vars and sed /end-of-line$/ pattern matching, there are two solutions. (1) The easiest is to enclose the script in "double quotes" so the shell can see the $variables, and to prefix the sed metacharacter ($) with a backslash. Thus, in

     sed "s/$user\$/root/" file

the shell interpolates $user and sed interprets \$ as the symbol for end-of-line.

(2) Another method--somewhat less readable--is to concatenate the script with 'single quotes' where the $ should not be interpolated and "double quotes" where variable interpolation should occur. To demonstrate using the preceding script:

     sed "s/$user"'$/root/' file

Solution #1 seems easier to remember. In either case, we search for the user's name (stored in a variable called $user) when it occurs at the end of the line ($), and substitute the word "root" in all matches.

For longer shell scripts, it is sometimes useful to begin with single quote marks ('), close them upon encountering the variable, enclose the variable name in double quotes ("), and resume with single quotes, closing them at the end of the sed script. Example:

     #! /bin/sh
     # sed script to illustrate 'quote'"matching"'usage'
     FROM='abcdefgh'
     TO='ABCDEFGH'
     sed -e '
     y/'"$FROM"'/'"$TO"'/;    # note the quote pairing
     # some more commands go here . . .
     # last line is a single quote mark
     '

Thus, each variable named $FROM is replaced by $TO, and the single quotes are used to glue the multiple lines together in the script. (See also section 4.10, "How do I handle shell quoting in sed?")
4.30.2. - on MS-DOS and 4DOS platforms

Under 4DOS and MS-DOS version 7.0 (Win95) or 7.10 (Win95 OSR2), environment variables can be accessed from the command prompt. Under MS-DOS v6.22 and below, environment variables can only be accessed from within batch files. Environment variables should be enclosed between percent signs and are case-insensitive; i.e., %USER% or %user% will display the USER variable. To generate a true percent sign, just enter it twice.

DOS versions of sed require that sed scripts be enclosed by double quote marks "..." (not single quotes!) if the script contains embedded tabs, spaces, redirection arrows or the vertical bar. In fact, if the input for sed comes from piping, a sed script should not contain a vertical bar, even if it is protected by double quotes (this seems to be bug in the normal MS-DOS syntax). Thus,

       echo blurk | sed "s/^/ |foo /"     # will cause an error
       sed "s/^/ |foo /" blurk.txt        # will work as expected

Using DOS environment variables which contain DOS path statements (such as a TMP variable set to "C:\TEMP") within sed scripts is discouraged because sed will interpret the backslash '\' as a metacharacter to "quote" the next character, not as a normal symbol. Thus,

       sed "s/^/%TMP% /" somefile.txt

will not prefix each line with (say) "C:\TEMP ", but will prefix each line with "C:TEMP "; sed will discard the backslash, which is probably not what you want. Other variables such as %PATH% and %COMSPEC% will also lose the backslash within sed scripts.

Environment variables which do not use backslashes are usually workable. Thus, all the following should work without difficulty, if they are invoked from within DOS batch files:

       sed "s/=username=/%USER%/g" somefile.txt
       echo %FILENAME% | sed "s/\.TXT/.BAK/"
       grep -Ei "%string%" somefile.txt | sed "s/^/  /"

while from either the DOS prompt or from within a batch file,

       sed "s/%%/ percent/g" input.fil >output.fil

will replace each percent symbol in a file with " percent" (adding the leading space for readability).
4.31. How do I export or pass variables back into the environment?
4.31.1. - on Unix platforms

Suppose that line #1, word #2 of the file 'terminals' contains a value to be put in your TERM environment variable. Sed cannot export variables directly to the shell, but it can pass strings to shell commands. To set a variable in the Bourne shell:

       TERM=`sed 's/^[^ ][^ ]* \([^ ][^ ]*\).*/\1/;q' terminals`;
       export TERM

If the second word were "Wyse50", this would send the shell command "TERM=Wyse50".
4.31.2. - on MS-DOS or 4DOS platforms

Sed cannot directly manipulate the environment. Under DOS, only batch files (.BAT) can do this, using the SET instruction, since they are run directly by the command shell. Under 4DOS, special 4DOS commands (such as ESET) can also alter the environment.

Under DOS or 4DOS, sed can select a word and pass it to the SET command. Suppose you want the 1st word of the 2nd line of MY.DAT put into an environment variable named %PHONE%. You might do this:

       @echo off
       sed -n "2 s/^\([^ ][^ ]*\) .*/SET PHONE=\1/p;3q" MY.DAT > GO_.BAT
       call GO_.BAT
       echo The environment variable for PHONE is %PHONE%
       :: cleanup
       del GO_.BAT

The sed script assumes that the first character on the 2nd line is not a space and uses grouping \(...\) to save the first string of non-space characters as \1 for the RHS. In writing any batch files, make sure that output filenames such as GO_.BAT don't overwrite preexisting files of the same name.
4.32. How do I handle Unix shell quoting in sed?

To embed a literal single quote (') in a script, use (a) or (b):

(a) If possible, put the script in double quotes:

     sed "s/cannot/can't/g" file

(b) If the script must use single quotes, then close-single-quote the script just before the SPECIAL single quote, prefix the single quote with a backslash, and use a 2nd pair of single quotes to finish marking the script. Thus:

     sed 's/cannot$/can'\''t/g' file

Though this looks hard to read, it breaks down to 3 parts:

      's/cannot$/can'   \'   't/g'
      ---------------   --   -----

To embed a literal double quote (") in a script, use (a) or (b):

(a) If possible, put the script in single quotes. You don't need to prefix the double quotes with anything. Thus:

     sed 's/14"/fourteen inches/g' file

(b) If the script must use double quotes, then prefix the SPECIAL double quote with a backslash (\). Thus,

     sed "s/$length\"/$length inches/g" file

To embed a literal backslash (\) into a script, enter it twice:

     sed 's/C:\\DOS/D:\\DOS/g' config.sys

FILES, DIRECTORIES, AND PATHS
4.40. How do I read (insert/add) a file at the top of a textfile?

Normally, adding a "header" file to the top of a "body" file is done from the command prompt before passing the file on to sed. (MS-DOS below version 6.0 must use COPY and DEL instead of MOVE in the following example.)

       copy header.txt+body temp                  # MS-DOS command 1
       echo Y | move temp body                    # MS-DOS command 2
                                                    #
       cat header.txt body >temp; mv temp body    # Unix commands

However, if inserting the file must occur within sed, there is a way. The sed command "1 r header.txt" will not work; it will print line 1 and then insert "header.txt" between lines 1 and 2. The following script solves this problem; however, there must be at least 2 lines in the target file for the script to work properly.

     # sed script to insert "header.txt" above the first line
     1{h; r header.txt
       D; }
     2{x; G; }
     #---end of sed script---

4.41. How do I make substitutions in every file in a directory, or in a complete directory tree?
4.41.1. - ssed and Perl solution

The best solution for multiple files in a single directory is to use ssed or gsed v4.0 or higher:

     sed -i.BAK 's|foo|bar|g' files       # -i does in-place replacement

If you don't have ssed, there is a similar solution in Perl. (Yes, we know this is a FAQ file for sed, not perl, but perl is more common than ssed for many users.)

     perl -pi.bak -e 's|foo|bar|g' files                # or
     perl -pi.bak -e 's|foo|bar|g' `find /pathname -name "filespec"`

For each file in the filelist, sed (or Perl) renames the source file to "filename.bak"; the modified file gets the original filename. Remove '.bak' if you don't need backup copies. (Note the use of "s|||" instead of "s///" here, and in the scripts below. The vertical bars in the 's' command let you replace '/some/path' with '/another/path', accommodating slashes in the LHS and RHS.)

To recurse directories in Unix or GNU/Linux:

     # We use xargs to prevent passing too many filenames to sed, but
     # this command will fail if filenames contain spaces or newlines.
     find /my/path -name '*.ht' -print | xargs sed -i.BAK 's|foo|bar|g'

To recurse directories under Windows 2000 (CMD.EXE or COMMAND.COM):

     # This syntax isn't supported under Windows 9x COMMAND.COM
     for /R c:\my\path %f in (*.htm) do sed -i.BAK "s|foo|bar|g" %f

4.41.2. - Unix solution

For all files in a single directory, assuming they end with *.txt and you have no files named "[anything].txt.bak" already, use a shell script:

     #! /bin/sh
     # Source files are saved as "filename.txt.bak" in case of error
     # The '&&' after cp is an additional safety feature
     for file in *.txt
     do
        cp $file $file.bak &&
        sed 's|foo|bar|g' $file.bak >$file
     done

To do an entire directory tree, use the Unix utility find, like so (thanks to Jim Dennis <jadestar@rahul.net> for this script):

     #! /bin/sh
     # filename: replaceall
     # Backup files are NOT saved in this script.
     find . -type f -name '*.txt' -print | while read i
     do
        sed 's|foo|bar|g' $i > $i.tmp && mv $i.tmp $i
     done

This previous shell script recurses through the directory tree, finding only files in the directory (not symbolic links, which will be encountered by the shell command "for file in *.txt", above). To preserve file permissions and make backup copies, use the 2-line cp routine of the earlier script instead of "sed ... && mv ...". By replacing the sed command 's|foo|bar|g' with something like

     sed "s|$1|$2|g" ${i}.bak > $i

using double quotes instead of single quotes, the user can also employ positional parameters on the shell script command tail, thus reusing the script from time to time. For example,

       replaceall East West

would modify all your *.txt files in the current directory.
4.41.3. - DOS solution:

MS-DOS users should use two batch files like this:

      @echo off
      :: MS-DOS filename: REPLACE.BAT
      ::
      :: Create a destination directory to put the new files.
      :: Note: The next command will fail under Novel Netware
      :: below version 4.10 unless "SHOW DOTS=ON" is active.
      if not exist .\NEWFILES\NUL mkdir NEWFILES
      for %%f in (*.txt) do CALL REPL_2.BAT %%f
      echo Done!!
      :: ---End of first batch file---

      @echo off
      :: MS-DOS filename: REPL_2.BAT
      ::
      sed "s/foo/bar/g" %1 > NEWFILES\%1
      :: ---End of the second batch file---

When finished, the current directory contains all the original files, and the newly-created NEWFILES subdirectory contains the modified *.TXT files. Do not attempt a command like

       for %%f in (*.txt) do sed "s/foo/bar/g" %%f >NEWFILES\%%f

under any version of MS-DOS because the output filename will be created as a literal '%f' in the NEWFILES directory before the %%f is expanded to become each filename in (*.txt). This occurs because MS-DOS creates output filenames via redirection commands before it expands "for..in..do" variables.

To recurse through an entire directory tree in MS-DOS requires a batch file more complex than we have room to describe. Examine the file SWEEP.BAT in Timo Salmi's great archive of batch tricks, located at <ftp://garbo.uwasa.fi/pc/link/tsbat.zip> (this file is regularly updated). Another alternative is to get an external program designed for directory recursion. Here are some recommended programs for directory recursion. The first one, FORALL, runs under either OS/2 or DOS. Unfortunately, none of these supports Win9x long filenames.

       http://hobbes.nmsu.edu/pub/os2/util/disk/forall72.zip
       ftp://garbo.uwasa.fi/pc/filefind/target15.zip

4.42. How do I replace "/some/UNIX/path" in a substitution?

Technically, the normal meaning of the slash can be disabled by prefixing it with a backslash. Thus,

     sed 's/\/some\/UNIX\/path/\/a\/new\/path/g' files

But this is hard to read and write. There is a better solution. The s/// substitution command allows '/' to be replaced by any other character (including spaces or alphanumerics). Thus,

     sed 's|/some/UNIX/path|/a/new/path|g' files

and if you are using variable names in a Unix shell script,

     sed "s|$OLDPATH|$NEWPATH|g" oldfile >newfile

4.43. How do I replace "C:\SOME\DOS\PATH" in a substitution?

For MS-DOS users, every backslash must be doubled. Thus, to replace "C:\SOME\DOS\PATH" with "D:\MY\NEW\PATH":

     sed "s|C:\\SOME\\DOS\\PATH|D:\\MY\\NEW\\PATH|g" infile >outfile

Remember that DOS pathnames are not case sensitive and can appear in upper or lower case in the input file. If this concerns you, use a version of sed which can ignore case when matching (gsed, ssed, sedmod, sed16).

       @echo off
       :: sample MS-DOS batch file to alter path statements
       :: requires GNU sed with the /i flag for s///
       set old=C:\\SOME\\DOS\\PATH
       set new=D:\\MY\\NEW\\PATH
       gsed "s|%old%|%new%|gi" infile >outfile
       :: or
       ::     sedmod -i "s|%old%|%new%|g" infile >outfile
       set old=
       set new=

Also, remember that under Windows long filenames may be stored in two formats: e.g., as "C:\Program Files" or as "C:\PROGRA~1".
4.44. How do I emulate file-includes, using sed?

Given an input file with file-include statements, similar to C-style includes or "server-side includes" (SSI) of this format:

       This is the source file. It's short.
       Its name is simply 'source'. See the script below.
       <!--#include file="ashe.inc"-->
              And this is any amount of text between
       <!--#include file="jesse.inc"-->
       This is the last line of the file.

How do we direct sed to import/insert whichever files are at the point of the 'file="filename"' token? First, use this file:

     #n
     # filename: incl.sed
     # Comments supported by GNU sed or ssed. Leading '#n' should
     # be on line 1, columns 1-2 of the line.
     /<!--#include file="/ {  # For each "include file" command,
       =;                     #   print the line number
       s/^[^"]*"/{r /;        #   change pattern to 'r{ '
       s/".*//p;              #   delete rest to EOL, print
                              #   and a(ppend) a delete command
       a\
       d;}
     }
     #---end of sed script---

Second, use the following shell script or DOS batch file (if running a DOS batch file, use "double quotes" instead of 'single quotes', and use "del" instead of "rm" to remove the temp file):

     sed -nf incl.sed source | sed 'N;N;s/\n//' >temp.sed
     sed -f temp.sed source >target
     rm temp.sed

If you have GNU sed or ssed, you can reduce the script even further (thanks to Michael Carmack for the reminder):

     sed -nf incl.sed source | sed 'N;N;s/\n//' | sed -f - source >target

In brief, the script replaces each filename with a 'r filename' command to insert the file at that point, while omitting the extraneous material. Two important things to note with this script: (1) There should be only one '#include file' directive per line, and (2) each '#include file' directive must be the only thing on that line, because everything else on the line will be deleted.

Though the script uses GNU sed or ssed because of the great support for embedded script comments, it should run on any version of sed. If not, write me and let me know.

This is the end of Section 4 of the sed FAQ.
Go back to Section 3, or forward to Section 5.
Go up to the index.


Sa+VEgdiTto lockscreen kbdin pis0854polsiren


This is Section 5 of the sed FAQ.
Go back to Section 4, or forward to Section 6.
Go up to the index.

5. WHY ISN'T THIS WORKING?
5.1. Why don't my variables like $var get expanded in my sed script?

Because your sed script uses 'single quotes' instead of "double quotes." Unix shells never expand $variables in single quotes.

This is probably the most frequently-asked sed question. For more info on using variables, see section 4.30.
5.2. I'm using 'p' to print, but I have duplicate lines sometimes.

Sed prints the entire file by default, so the 'p' command might cause the duplicate lines. If you want the whole file printed, try removing the 'p' from commands like 's/foo/bar/p'. If you want part of the file printed, run your sed script with -n flag to suppress normal output, and rewrite the script to get all output from the 'p' comand.

If you're still getting duplicate lines, you are probably finding several matches for the same line. Suppose you want to print lines with the words "Peter" or "James" or "John", but not the same line twice. The following command will fail:

     sed -n '/Peter/p; /James/p; /John/p' files

Since all 3 commands of the script are executed for each line, you'll get extra lines. A better way is to use the 'd' (delete) or 'b' (branch) commands, like so (with GNU sed):

     sed '/Peter/b; /James/b; /John/b; d' files          # one way
     sed -n '/Peter/{p;d;};/James/{p;d;};/John/p' files  # a 2nd way
     sed -n '/Peter/{p;b;};/James/{p;b;};/John/p' files  # a 3rd way
     sed '/Peter\|James\|John/!d' files                  # shortest way

On standard seds, these must be broken down with -e commands:

     sed -e '/Peter/b' -e '/James/b' -e '/John/b' -e d files
     sed -n -e '/Peter/{p;d;}' -e '/James/{p;d;}' -e '/John/p' files

The 3rd line would require too many -e commands to fit on one line, since standard versions of sed require an -e command after each 'b' and also after each closing brace '}'.
5.3. Why does my DOS version of sed process a file part-way through and then quit?

First, look for errors in the script. Have you used the -n switch without telling sed to print anything to the console? Have you read the docs to your version of sed to see if it has a syntax you may have misused? (Look for an N or H command that gathers too much.)

Next, if you are sure your sed script is valid, a probable cause is an end-of-file marker embedded in the file. An EOF marker (SUB) is a Control-Z character, with the value of 1A hex (26 decimal). As soon as any DOS version of sed encounters a Ctrl-Z character, sed stops processing.

To locate the EOF character, use Vern Buerg's shareware file viewer LIST.COM <http://www.buerg.com/list.html>. In text mode, look for a right-arrow symbol; in hex mode (Alt-H), look for a 1A code. With Unix utilities ported to DOS, use 'od' (octal dump) to display hexcodes in your file, and then use sed to locate the offending character:

       od -txC badfile.txt | sed -n "/ 1a /p; / 1a$/p"

Then edit the input file to remove the offending character(s).

If you would rather NOT edit the input file, there is still a fix. It requires the DJGPP 32-bit port of 'tr', the Unix translate program (v1.22 or higher). GNU od and tr are currently at v2.0 (for DOS); they are packaged with the GNU text utilities, available at

       ftp://ftp.simtel.net/pub/simtelnet/gnu/djgpp/v2gnu/txt20b.zip
       http://www.simtel.net/gnudlpage.php?product=/gnu/djgpp/v2gnu/txt20b.zip&name=txt20b.zip

It is important to get the DJGPP version of 'tr' because other versions ported to DOS will stop processing when they encounter the EOF character. Use the -d (delete) command:

       tr -d \32 < badfile.txt | sed -f myscript.sed

5.4. My RE isn't matching/deleting what I want it to. (Or, "Greedy vs. stingy pattern matching")

The two most common causes for this problem are: (1) misusing the '.' metacharacter, and (2) misusing the '*' metacharacter. The RE '.*' is designed to be "greedy" (i.e., matching as many characters as possible). However, sometimes users need an expression which is "stingy," matching the shortest possible string.

(1) On single-line patterns, the '.' metacharacter matches any single character on the line. ('.' cannot match the newline at the end of the line because the newline is removed when the line is put into the pattern space; sed adds a newline automatically when the pattern space is printed.) On multi-line patterns obtained with the 'N' or 'G' commands, '.' will match a newline in the middle of the pattern space. If there are 3 lines in the pattern space, "s/.*//" will delete all 3 lines, not just the first one (leaving 1 blank line, since the trailing newline is added to the output).

Normal misuse of '.' occurs in trying to match a word or bounded field, and forgetting that '.' will also cross the field limits. Suppose you want to delete the first word in braces:

       echo {one} {two} {three} | sed 's/{.*}/{}/'       # fails
       echo {one} {two} {three} | sed 's/{[^}]*}/{}/'    # succeeds

's/{.*}/{}/' is not the solution, since the regex '.' will match any character, including the close braces. Replace the '.' with '[^}]', which signifies a negated character set '[^...]' containing anything other than a right brace. FWIW, we know that 's/{one}/{}/' would also solve our question, but we're trying to illustrate the use of the negated character set: [^anything-but-this].

A negated character set should be used for matching words between quote marks, for fields separated by commas, and so on. See also section 4.12 ("How do I parse a comma-delimited data file?").

(2) The '*' metacharacter represents zero or more instances of the previous expression. The '*' metacharacter looks for the leftmost possible match first and will match zero characters. Thus,

       echo foo | sed 's/o*/EEE/'

will generate 'EEEfoo', not 'fEEE' as one might expect. This is because /o*/ matches the null string at the beginning of the word.

After finding the leftmost possible match, the '*' is GREEDY; it always tries to match the longest possible string. When two or three instances of '.*' occur in the same RE, the leftmost instance will grab the most characters. Consider this example, which uses grouping '\(...\)' to save patterns:

       echo bar bat bay bet bit | sed 's/^.*\(b.*\)/\1/'

What will be displayed is 'bit', never anything longer, because the leftmost '.*' took the longest possible match. Remember this rule: "leftmost match, longest possible string, zero also matches."
5.5. What is CSDPMI*B.ZIP and why do I need it?

If you use MS-DOS outside of Windows and try to use GNU sed v1.18 or 3.02, you may encounter the following error message:

       no DPMI - Get csdpmi*b.zip

"DPMI" stands for DOS Protected Mode Interface; it's basically a means of running DOS in Protected Mode (as opposed to Real Mode), which allows programs to share resources in extended memory without conflicting with one another. Running HIMEM.SYS and EMM386.EXE is not enough. The "CSDPMI*B.ZIP" refers to files written by Charles Sandmann to provide DPMI services for 32-bit computers (i.e., 386SX, 386DX, 486SX, etc.). Download the binary file (the source code is also available):

       http://www.delorie.com/djgpp/dl/ofc/simtel/v2misc/csdpmi5b.zip  # binaries
       http://www.delorie.com/djgpp/dl/ofc/simtel/v2misc/csdpmi5s.zip  # source
       ftp://ftp.cdrom.com/pub/simtelnet/gnu/djgpp/v2misc/csdpmi5b.zip # binaries
       ftp://ftp.cdrom.com/pub/simtelnet/gnu/djgpp/v2misc/csdpmi5s.zip # source

and extract CWSDPMI.EXE, CWSDPR0.EXE and CWSPARAM.EXE from the ZIP file. Put all 3 CWS*.EXE files in the same directory as GSED.EXE and you're all set. There are DOC files enclosed, but they're nearly incomprehensible for the average computer user. (Another case of user-vicious documentation.)

If you're running Windows and you normally use a DOS session to run GNU sed (i.e., you get to a DOS prompt with a resizable window or you press Alt-Enter to switch to full-screen mode), you don't need the CWS*.EXE files at all, since Windows uses DPMI already.
5.6. Where are the man pages for GNU sed?

Prior to GNU sed v3.02, there weren't any. Until recently, man pages distributed with gsed were borrowed from old sources or from other compilations. None of them were "official." GNU sed v3.02 had the first real set of official man pages, and the documentation has greatly improved with GNU sed version 4.0, which now includes both man pages and textinfo pages.
5.7. How do I tell what version of sed I am using?

Try entering "sed" all by itself on the command line, followed by no arguments or parameters. Also, try "sed --version". In a pinch, you can also try this:

       strings sed | grep -i ver

Your version of 'strings' must be a version of the Unix utility of this name. It should not be the DOS utility STRINGS.COM by Douglas Boling.
5.8. Does sed issue an exit code?

Most versions of sed do not, but check the documentation that came with whichever version you are using. GNU sed issues an exit code of 0 if the program terminated normally, 1 if there were errors in the script, and 2 if there were errors during script execution.
5.9. The 'r' command isn't inserting the file into the text.

On most versions of sed (but not all), the 'r' (read) and 'w' (write) commands must be followed by exactly one space, then the filename, and then terminated by a newline. Any additional characters before or after the filename are interpreted as part of the filename. Thus

       /RE/r  insert.me

will would try to locate a file called ' insert.me' (note the leading space!). If the file was not found, most versions of sed say nothing, not even an error message.

When sed scripts are used on the command line, every 'r' and 'w' must be the last command in that part of the script. Thus,

       sed -e '/regex/{r insert.file;d;}' source         # will fail
       sed -e '/regex/{r insert.file' -e 'd;}' source    # will succeed

5.10. Why can't I match or delete a newline using the \n escape sequence? Why can't I match 2 or more lines using \n?

The \n will never match the newline at the end-of-line because the newline is always stripped off before the line is placed into the pattern space. To get 2 or more lines into the pattern space, use the 'N' command or something similar (such as 'H;...;g;').

Sed works like this: sed reads one line at a time, chops off the terminating newline, puts what is left into the pattern space where the sed script can address or change it, and when the pattern space is printed, appends a newline to stdout (or to a file). If the pattern space is entirely or partially deleted with 'd' or 'D', the newline is not added in such cases. Thus, scripts like

       sed 's/\n//' file       # to delete newlines from each line
       sed 's/\n/foo\n/' file  # to add a word to the end of each line

will never work, because the trailing newline is removed before the line is put into the pattern space. To perform the above tasks, use one of these scripts instead:

       tr -d '\n' < file              # use tr to delete newlines
       sed ':a;N;$!ba;s/\n//g' file   # GNU sed to delete newlines
       sed 's/$/ foo/' file           # add "foo" to end of each line

Since versions of sed other than GNU sed have limits to the size of the pattern buffer, the Unix 'tr' utility is to be preferred here. If the last line of the file contains a newline, GNU sed will add that newline to the output but delete all others, whereas tr will delete all newlines.

To match a block of two or more lines, there are 3 basic choices: (1) use the 'N' command to add the Next line to the pattern space; (2) use the 'H' command at least twice to append the current line to the Hold space, and then retrieve the lines from the hold space with x, g, or G; or (3) use address ranges (see section 3.3, above) to match lines between two specified addresses.

Choices (1) and (2) will put an \n into the pattern space, where it can be addressed as desired ('s/ABC\nXYZ/alphabet/g'). One example of using 'N' to delete a block of lines appears in section 4.13 ("How do I delete a block of specific consecutive lines?"). This example can be modified by changing the delete command to something else, like 'p' (print), 'i' (insert), 'c' (change), 'a' (append), or 's' (substitute).

Choice (3) will not put an \n into the pattern space, but it does match a block of consecutive lines, so it may be that you don't even need the \n to find what you're looking for. Since several versions of sed support this syntax:

       sed '/start/,+4d'  # to delete "start" plus the next 4 lines,

in addition to the traditional '/from here/,/to there/{...}' range addresses, it may be possible to avoid the use of \n entirely.
5.11. My script aborts with an error message, "event not found".

This error is generated by the csh or tcsh shells, not by sed. The exclamation mark (!) is special to csh/tcsh, and if you use it in command-line or shell scripts--even within single quotes--it must be preceded by a backslash. Thus, under the csh/tcsh shell:

       sed '/regex/!d'      # will fail
       sed '/regex/\!d'     # will succeed

The exclamation mark should not be prefixed with a backslash when the script is called from a file, as "-f script.file".

This is the end of Section 5 of the sed FAQ.
Go back to Section 4, or forward to Section 6.
Go up to the index.


SA+VgeDitto lockscreen kbdin pis0854pols
iren


This is Section 6 of the sed FAQ.
Go back to Section 5, or forward to Section 7.
Go up to the index.

6. OTHER ISSUES
6.1. I have a certain problem that stumps me. Where can I get help?

Post your question on the "sed-users" mailing list (section 2.3.2), where many sed users will be able to see your question. You will have to subscribe to have posting privileges.

Your other alternative is one of these newsgroups:

    alt.comp.editors.batch
    comp.editors
    comp.unix.questions
    comp.unix.shell

6.2. How does sed compare with awk, perl, and other utilities?

Awk is a much richer language with many features of a programming language, including variable names, math functions, arrays, system calls, etc. Its command structure is similar to sed:

      address { command(s) }

which means that for each line or range of lines that matches the address, execute the command(s). In both sed and awk, an address can be a line number or a RE somewhere on the line, or both.

In program size, awk is 3-10 times larger than sed. Awk has most of the functions of sed, but not all. Notably, sed supports backreferences (\1, \2, ...) to previous expressions, and awk does not have any comparable syntax. (One exception: GNU awk v3.0 introduced gensub(), which supports backreferences only on substitutions.)

Perl is a general-purpose programming language, with many features beyond text processing and interprocess communication, taking it well past awk or other scripting languages. Perl supports every feature sed does and has its own set of extended regular expressions, which give it extensive power in pattern matching and processing. (Note: the standard perl distribution comes with 's2p', a sed-to-perl conversion script. See section 3.6 for more info.) Like sed and awk, perl scripts do not need to be compiled into binary code. Like sed, perl can also run many useful "one-liners" from the command line, though with greater flexibility; see question 4.41 ("How do I make substitutions in every file in a directory, or in a complete directory tree?").

On the other hand, the current version of perl is from 8 to 35 times larger than sed in its executables alone (perl's library modules and allied files not included!). Further, for most simple tasks such as substitution, sed executes more quickly than either perl or awk. All these utilities serve to process input text, transforming it to meet our needs . . . or our arbitrary whims.
6.3. When should I use sed?

When you need a small, fast program to modify words, lines, or blocks of lines in a textfile.
6.4. When should I NOT use sed?

You should not use sed when you have "dedicated" tools which can do the job faster or with an easier syntax. Do not use sed when you only want to:

    print individual lines, based on patterns within the line itself. Instead, use "grep".
    print blocks of lines, with 1 or more lines of context above or below a specific regular expression. Instead, use the GNU version of grep as follows:

            grep -A{number} -B{number} "regex"

    remove individual lines, based on patterns within the line itself. Instead, use "grep -v".
    print line numbers. Instead, use "nl" or "cat -n".
    reformat lines or paragraphs. Instead, use "fold", "fmt" or "par". 

The tr utility is also more suited than sed to some simple tasks. For example, to:

    delete individual characters. Instead of "s/[a-d]//g", use

            tr -d "[a-d]"

    squeeze sequential characters. Instead of "s/ee*/e/g", use

            tr -s "{character-set}"

    change individual characters. Instead of "y/abcdef/ABCDEF/", use

            tr "[a-f]" "[A-F]"

Note, however, that tr does not support giving input files on the command line, so the syntax is:

     tr {options-and-patterns} < input-file

or, to process multiple files:

     cat input-file1 input-file2 | tr {options-and-patterns}

If you have multiple files, using tr instead of sed is often more of an exercise than a useful thing. Although sed can perfectly emulate certain functions of cat, grep, nl, rev, sort, tac, tail, tr, uniq, and other utilities, producing identical output, the native utilities are usually optimized to do the job more quickly than sed.
6.5. When should I ignore sed and use awk or Perl instead?

If you can write the same script in awk or Perl and do it in less time, then use Perl or awk. There's no reason to spend an hour writing and debugging a sed script if you can do it in Perl in 10 minutes (assuming that you know Perl already) and if the processing time or memory use is not a factor. Don't hunt pheasants with a .22 if you have a shotgun at your side . . . unless you simply enjoy the challenge!

Specifically, use awk or perl if you need to:

    count fields or words on a line. (awk)
    count lines in a block or objects in a file.
    check lengths of strings or do math operations.
    handle very long lines or need very large buffers. (or gsed)
    handle binary data (control characters). (perl: binmode)
    loop through an array or list.
    test for file existence, filesize, or fileage.
    treat each paragraph as a line. (well, not always)

6.6. Known limitations among sed versions

Limits on distributed versions, although source code for most versions of free sed allows for modification and recompilation. As used below, "no limit" means there is no "fixed" limit. Limits are actually determined by one's hardware, memory, operating system, and which C library is used to compile sed.
6.6.1. Maximum line length

      GNU sed:        no limit
      ssed:           no limit
      sedmod v1.0:    4096 bytes
      HHsed v1.5:     4000 bytes
      sed v1.6:       [pending]

6.6.2. Maximum size for all buffers (pattern space + hold space)

      GNU sed:        no limit
      ssed:           no limit
      sedmod v1.0:    4096 bytes
      HHsed v1.5:     4000 bytes
      sed v1.6:       [pending]

6.6.3. Maximum number of files that can be read with read command

      GNU sed v3+:    no limit
      ssed:           no limit
      GNU sed v2.05:  total no. of r and w commands may not exceed 32
      sedmod v1.0:    total no. of r and w commands may not exceed 20
      sed v1.6:       [pending]

6.6.4. Maximum number of files that can be written with 'w' command

      GNU sed v3+:    no limit (but typical Unix is 253)
      ssed:           no limit (but typical Unix is 253)
      GNU sed v2.05:  total no. of r and w commands may not exceed 32
      sedmod v1.0:    10
      HHsed v1.5:     10
      sed v1.6:       [pending]

6.6.5. Limits on length of label names

      GNU sed:        no limit
      ssed:           no limit
      HHsed v1.5:     no limit
      sed v1.6:       [pending]
      BSD sed:        8 characters

Note that GNU sed and ssed both consider a semicolon to terminate a label name.
6.6.6. Limits on length of write-file names

      GNU sed:        no limit
      ssed:           no limit
      HHsed v1.5:     no limit
      sed v1.6:       [pending]
      BSD sed:        40 characters

6.6.7. Limits on branch/jump commands

      GNU sed:        no limit
      ssed:           no limit
      HHsed v1.5:     50
      sed v1.6:       [pending]

As a practical consequence, this means that HHsed will not read more than 50 lines into the pattern space via an N command, even if the pattern space is only a few hundred bytes in size. HHsed exits with an error message, "infinite branch loop at line {nn}".
6.7. Known incompatibilities between sed versions
6.7.1. Issuing commands from the command line

Most versions of sed permit multiple commands to issued on the command line, separated by a semicolon (;). Thus,

       sed 'G;G' file

should triple-space a file. However, for non-GNU sed, some commands require separate expressions on the command line. These include:

    all labels (':a', ':more', etc.)
    all branching instructions ('b', 't')
    commands to read and write files ('r' and 'w')
    any closing brace, '}'

If these commands are used, they must be the LAST commands of an expression. Subsequent commands must use another expression (another -e switch plus arguments). E.g.,

     sed  -e :a -e 's/^.\{1,77\}$/ &/;ta' -e 's/\( *\)\1/\1/' files

GNU sed, ssed, sed15 and sed16 all permit these commands to be followed by a semicolon, so the previous script can be written:

     sed  ':a;s/^.\{1,77\}$/ &/;ta;s/\( *\)\1/\1/' files

Versions differ in implementing the 'a' (append), 'c' (change), and 'i' (insert) commands:

      sed "/foo/i New text here"              # HHsed/sedmod/gsed-30280
      gsed -e "/foo/i\\" -e "New text here"   # GNU sed
      sed1 -e "/foo/i" -e "New text here"     # one version of sed
      sed2 "/foo/i\ New text here"            # another version

6.7.2. Using comments (prefixed by the '#' sign)

Most versions of sed permit comments to appear in sed scripts only on the first line of the script. Comments on line 2 or thereafter are not recognized and will generate an error like "unrecognized command" or "command [bad-line-here] has trailing garbage".

GNU sed, HHsed, sedmod, and HP-UX sed permit comments to appear on any line of the script, except after labels and branching commands (b,t), provided that a semicolon (;) occurs after the command itself. This syntax makes sed similar to awk and perl, which use a similar commenting structure in their scripts. Thus,

      # GNU style sed script
      $!N;                        # except for last line, get next line
      s/^\([0-9]\{5\}\).*\n\1.*//;    # if first 5 digits of each line
                                      # match, delete BOTH lines.
      t skip
      P;                              # print 1st line only if no match
      :skip
      D;                    # delete 1st line of pattern space and loop
      #---end of script---

is a valid script for GNU-based versions of sed, but is unrecognized for most other versions of sed.

Finally, if the first two characters in a disk file script are "#n", the output is suppressed, exactly as if -n were entered on the command line. This is true for the following versions of sed:

    ssed v3.57 and above
    gsed
    HHsed v1.5
    sed v1.6

This syntax is not recognized by these versions of sed:

    ssed v3.45 to v3.50 (other versions untested)
    sedmod v1.0

6.7.3. Special syntax in REs
A. HHsed v1.5 (by Howard Helman)

The following expressions can be used for /RE/ addresses or in the LHS side of a substitution:

      +    - 1 or more occurrences of previous RE: same as \{1,\}
      \<   - boundary between nonword and word character
      \>   - boundary between word and nonword character

The following expressions can be used for /RE/ addresses or on either side of a substitution:

      \a   - bell         (ASCII 07, 0x07)
      \b   - backspace    (ASCII 08, 0x08)
      \e   - escape       (ASCII 27, 0x1B)
      \f   - formfeed     (ASCII 12, 0x0C)
      \n   - newline      (printed as 2 bytes, 0D 0A or ^M^J, in DOS)
      \r   - return       (ASCII 13, 0x0D)
      \t   - tab          (ASCII 09, 0x09)
      \v   - vertical tab (ASCII 11, 0x0B)
      \xHH - the ASCII character corresponding to 2 hex digits HH.

B. sed v1.6 (by Walter Briscoe)

sed v1.6 accepts every expression supported by sed v1.5 (above), plus the following elements, which can also used in the RHS of a substitution (in addition to those listed above):

      \\~  - insert replacement pattern defined in last s/// command
             (must be used alone in the RHS)
      \l   - change next element to lower case
      \L   - change remaining elements to lower case
      \u   - change next element to upper case
      \U   - change remaining elements to upper case
      \e   - end case conversion of next element
      \E   - end case conversion of remaining elements
      $0   - insert pattern space BEFORE the substitution
      $1-$9 - match Nth word on the pattern space

C. sedmod v1.0 (by Hern Chen)

The following expressions can be used for /RE/ addresses in the LHS of a substitution:

      +    - 1 or more occurrences of previous RE: same as \{1,\}
      \a   - any alphanumeric: same as [a-zA-Z0-9]
      \A   - 1 or more alphas: same as \a+
      \d   - any digit: same as [0-9]
      \D   - 1 or more digits: same as \d+
      \h   - any hex digit: same as [0-9a-fA-F]
      \H   - 1 or more hexdigits: same as \h+
      \l   - any letter: same as [A-Za-z]
      \L   - 1 or more letters: same as \l+
      \n   - newline      (read as 2 bytes, 0D 0A or ^M^J, in DOS)
      \s   - any whitespace character: space, tab, or vertical tab
      \S   - 1 or more whitespace chars: same as \s+
      \t   - tab          (ASCII 09, 0x09)
      \<   - boundary between nonword and word character
      \>   - boundary between word and nonword character

The following expressions can be used in the RHS of a substitution. "Elements" refer to \1 .. \9, &, $0, or $1 .. $9:

      &    - insert regexp defined on LHS
      \e   - end case conversion of next element
      \E   - end case conversion of remaining elements
      \l   - change next element to lower case
      \L   - change remaining elements to lower case
      \n   - newline      (printed as 2 bytes, 0D 0A or ^M^J, in DOS)
      \t   - tab          (ASCII 09, 0x09)
      \u   - change next element to upper case
      \U   - change remaining elements to upper case
      $0   - insert the original pattern space
      $1-$9 - match Nth word on the pattern space

D. UnixDos sed

The following expressions can be used in text, LHS, and RHS:

      \n   - newline      (printed as 2 bytes, 0D 0A or ^M^J, in DOS)

E. GNU sed v1.03 (by Frank Whaley)

When used with the -x (extended) switch on the command line, or when '#x' occurs as the first line of a script, Whaley's gsed103 supports the following expressions in both the LHS and RHS of a substitution:

      \|      matches the expression on either side
      ?       0 or 1 occurrences of previous RE: same as \{0,1\}
      +       1 or more occurrence of previous RE: same as \{1,\}
      \a      "alert" beep     (BEL, Ctrl-G, 0x07)
      \b      backspace        (BS, Ctrl-H, 0x08)
      \f      formfeed         (FF, Ctrl-L, 0x0C)
      \n      newline          (LF, Ctrl-J, 0x0A)
      \r      carriage-return  (CR, Ctrl-M, 0x0D)
      \t      horizontal tab   (HT, Ctrl-I, 0x09)
      \v      vertical tab     (VT, Ctrl-K, 0x0B)
      \bBBB   binary char, where BBB are 1-8 binary digits, [0-1]
      \dDDD   decimal char, where DDD are 1-3 decimal digits, [0-9]
      \oOOO   octal char, where OOO are 1-3 octal digits, [0-7]
      \xHH    hex char, where HH are 1-2 hex digits, [0-9A-F]

In normal mode, with or without the -x switch, the following escape sequences are also supported in regex addressing or in the LHS of a substitution:

      \`      matches beginning of pattern space: same as /^/
      \'      matches end of pattern space: same as /$/
      \B      boundary between 2 word or 2 nonword characters
      \w      any nonword character [*BUG!* should be a word char]
      \W      any nonword character: same as /[^A-Za-z0-9]/
      \<      boundary between nonword and word char
      \>      boundary between word and nonword char

F. GNU sed v2.05 and higher versions

The following expressions can be used for /RE/ addresses or in the LHS side of a substitution:

      \`  - matches the beginning of the pattern space (same as "^")
      \'  - matches the end of the pattern space (same as "$")
      \?  - 0 or 1 occurrence of previous character: same as \{0,1\}
      \+  - 1 or more occurrences of previous character: same as \{1,\}
      \|  - matches the string on either side, e.g., foo\|bar
      \b  - boundary between word and nonword chars (reversible)
      \B  - boundary between 2 word or between 2 nonword chars
      \n  - embedded newline (usable after N, G, or similar commands)
      \w  - any word character: [A-Za-z0-9_]
      \W  - any nonword char: [^A-Za-z0-9_]
      \<  - boundary between nonword and word character
      \>  - boundary between word and nonword character

On \b, \B, \<, and \>, see section 6.7.4 ("Word boundaries"), below.

Undocumented -r switch:

Beginning with version 3.02, GNU sed has an undocumented -r switch (undocumented till version 4.0), activating Extended Regular Expressions in the following manner:

       ?      -  0 or 1 occurrence of previous character
       +      -  1 or more occurrences of previous character
       |      -  matches the string on either side, e.g., foo|bar
       (...)  -  enable grouping without backslash
       {...}  -  enable interval expression without backslash

When the -r switch (mnemonic: "regular expression") is used, prefix these symbols with a backslash to disable the special meaning.

Escape sequences:

Beginning with version 3.02.80, the following escape sequences can now be used on both sides of a "s///" substitution:

      \a      "alert" beep     (BEL, Ctrl-G, 0x07)
      \f      formfeed         (FF, Ctrl-L, 0x0C)
      \n      newline          (LF, Ctrl-J, 0x0A)
      \r      carriage-return  (CR, Ctrl-M, 0x0D)
      \t      horizontal tab   (HT, Ctrl-I, 0x09)
      \v      vertical tab     (VT, Ctrl-K, 0x0B)
      \oNNN   a character with the octal value NNN
      \dNNN   a character with the decimal value NNN
      \xHH    a character with the hexadecimal value HH

Note that GNU sed also supports "character classes", a POSIX extension to regexes, described in section 3.7, above.
G. sed 4.0 and higher versions

The following expressions can be used in the RHS of a substitution.

      \e   - end case conversion
      \l   - change next character to lower case
      \L   - change remaining text to lower case
      \n   - newline      (printed as 2 bytes, 0D 0A or ^M^J, in DOS)
      \t   - tab          (ASCII 09, 0x09)
      \u   - change next character to upper case
      \U   - change remaining text to upper case

In addition, GNU sed 4.0 can modify the way ^ and $ are interpreted, so that ^ can also match an empty string after a newline character, and $ can also match an empty string before a newline character (to do this, add an "M" after the regular expression terminator, like /^>/M -- see section 3.1.1). Even if you use this feature, \` and \' still match the beginning and the end of the pattern space, respectively.
H. ssed

Everything that was said for GNU sed applies to ssed as well. In addition, in Perl-mode (-R switch), these become active or inactive:

      .     - no longer matches new-line characters
      \A    - matches beginning of pattern space
      \Z    - matches end of pattern space or last newline in the PS
      \z    - matches end of pattern space
      \d    - matches any digit: same as [0-9]
      \D    - matches any non-digit: same as [^0-9]
      \`    - no longer matches beginning of pattern space
      \'    - no longer matches end of pattern space
      \<    - no longer matches boundary between nonword & word char
      \>    - no longer matches boundary between word & nonword char
      \oNNN - no longer matches char with octal value NNN
      \dNNN - no longer matches char with decimal value NNN
      \NNN  - matches char with octal value NNN

Perl mode supports lookahead (?=match) and lookbehind (?<=match) pattern matching. The matched text is NOT captured in "&" for s/// replacements!

      foo(?=bar)   - match "foo" only if "bar" follows it
      foo(?!bar)   - match "foo" only if "bar" does NOT follow it
      (?<=foo)bar  - match "bar" only if "foo" precedes it
      (?<!foo)bar  - match "bar" only if "foo" does NOT precede it

      (?<!in|on|at)foo
                  - match "foo" only if NOT preceded by "in", "on" or "at"
      (?<=\d{3})(?<!999)foo
                  - match "foo" only if preceded by 3 digits other than "999"

In Perl mode, there are two new switches in /addressing/ or s/// commands. Switches may be lowercase in s/// commands, but must be uppercase in /addressing/:

       /S  - lets "." match a newline also
       /X  - extra whitespace is ignored. See below, for sample usage.

Here are some examples of Perl-style regular expressions. Use the -R switch.

     (?i)abc    - case-insensitive match of abc, ABC, aBc, ABc, etc.
     ab(?i)c    - same as above; the (?i) applies throughout the pattern
     (ab(?i)c)  - matches abc or abC; the outer parens make the difference!
     (?m)       - multi-line pattern space: same as "s/FIND/REPL/M"
     (?s)       - set "." to match newline also: same as "s/FIND/REPL/S"
     (?x)       - ignore whitespace and #comments; see section (9) below.

     (?:abc)foo    - match "abcfoo", but do not capture 'abc' in \1
     (?:ab|cd)ef   - match "abef" or "cdef"; only 'cd' is captured in \1
     (?#remark)xy  - match "xy"; remarks after "#" are ignored.

And here are some sample uses of /X switch to add comments to complex expressions. To embed literal spaces, precede with \ or put inside [brackets].

     # ssed script to change "(123) 456-7890" into "[ac123] 456-7890"
     #
     s/ # BACKSLASH IS NEEDED AT END OF EACH LINE!   \
     \(                   # literal left paren, (    \
     (\d{3})              # 3 digits                 \
     \)                   # literal right paren, )   \
     [ \t]*               # zero or more spaces or tabs  \
     (\d{3}-\d{4})        # 3 digits, hyphen, 4 digits   \
     /[ac\1] \2/gx;       # replace g(lobally), with e(x)tended spacing

6.7.4. Word boundaries

GNU sed, ssed, sed16, sed15 and sedmod use certain symbols to define the boundary between a "word character" and a nonword character. A word character fits the regex "[A-Za-z0-9_]". Note: a word character includes the underscore "_" but not the hyphen, probably because the underscore is permissible as a label in sed and in other scripting languages. (In gsed103, a word character did NOT include the underscore; it included alphanumerics only.)

These symbols include '\<' and '\>' (gsed, ssed, sed15, sed16, sedmod) and '\b' and '\B' (gsed only). Note that the boundary symbols do not represent a character, but a position on the line. Word boundaries are used with literal characters or character sets to let you match (and delete or alter) whole words without affecting the spaces or punctuation marks outside of those words. They can only be used in a "/pattern/" address or in the LHS of a 's/LHS/RHS/' command. The following table shows how these symbols may be used in HHsed and GNU sed. Sedmod matches the syntax of HHsed.

      Match position      Possible word boundaries   HHsed   GNU sed
      ---------------------------------------------------------------
      start of word    [nonword char]^[word char]      \<    \< or \b
      end of word         [word char]^[nonword char]   \>    \> or \b
      middle of word      [word char]^[word char]     none      \B
      outside of word  [nonword char]^[nonword char]  none      \B
      ---------------------------------------------------------------

In ssed, the symbols '\<' and '\>' lose their special meaning when the -R switch is used to invoke Perl-style expressions. However, the identical meaning of '\<' and '\>' can be obtained through these nonmatching, zero-width assertions:

       (?<!\w)(?=\w)  and   (?<=\w)(?!\w)

6.7.5. Commands which operate differently
A. GNU sed version 3.02 and 3.02.80

The N command no longer discards the contents of the pattern space upon reaching the end of file. This is not a bug, it's a feature. However, it breaks certain scripts which relied on the older behavior of N.

'N' adds the Next line to the pattern space, enabling multiple lines to be stored and acted upon. Upon reaching the last line of the file, if the N command was issued again, the contents of the pattern space would be silently deleted and the script would abort (this has been the traditional behavior). For this reason, sed users generally wrote:

       $!N;   # to add the Next line to every line but the last one.

However, certain sed scripts relied on this behavior, such as the script to delete trailing blank lines at the end of a file (see script #12 in section 3.2, "Common one-line sed scripts", above). Also, classic textbooks such as Dale Dougherty and Arnold Robbins' sed & awk documented the older behavior.

The GNU sed maintainer felt that despite the portability problems this would cause, changing the N command to print (rather than delete) the pattern space was more consistent with one's intuitions about how a command to "append the Next line" ought to behave. Another fact favoring the change was that "{N;command;}" will delete the last line if the file has an odd number of lines, but print the last line if the file has an even number of lines.

To convert scripts which used the former behavior of N (deleting the pattern space upon reaching the EOF) to scripts compatible with all versions of sed, change a lone "N;" to "$d;N;".

This is the end of Section 6 of the sed FAQ.
Go back to Section 5, or forward to Section 7.
Go up to the index.

SaVE+DgitTo lockscreen kbdin pis0854polsiren



This is Section 7 of the sed FAQ.
Go back to Section 6, or up to the index.

7. KNOWN BUGS AMONG SED VERSIONS

Most versions of GNU sed and ssed contain a "buglist" in the archive source code of known errors or reported behaviors that may be misconstrued as bugs. This portion of the sed FAQ does not attempt to fully reproduce those buglists files. However, we do seek to do some substantial reporting, particularly where certain programs have no "buglist" of their own or are not being actively maintained.

As a rule of thumb, if the bug "bites" someone on the sed-users mailing list, I tend to report it.
7.1. ssed v3.59 (by Paolo Bonzini)

(1) N does not discard the contents of the pattern space upon reaching the end of file; not a bug. See section 6.7.5.A, above.

(2) If \x26 is entered into the RHS of a substitution, it is interpreted as an ampersand metacharacter, and the entire pattern matched in the "find" portion is inserted at that point. A literal ampersand should be inserted instead.

(3) Under Windows 2000, the -i switch doesn't create backup files properly. When passed one or more files to process, the source file(s) are unchanged, and the output changed files are given filenames like sedDOSxyz with no way to correspond them with the names of the source files.
7.2. GNU sed v4.0 - v4.0.5

(1) N does not discard the contents of the pattern space upon reaching the end of file; not a bug. See section 6.7.5.A, above.

(2) If \x26 is entered into the RHS of a substitution, it is interpreted as an ampersand metacharacter, and the entire pattern matched in the "find" portion is inserted at that point. A literal ampersand should be inserted instead.
7.3. GNU sed v3.02.80

(1) N does not discard the contents of the pattern space upon reaching the end of file; not a bug. See section 6.7.5.A, above.

(2) Same as #2 for GNU sed v4.0, above.
7.4. GNU sed v3.02

(1) Affects only v3.02 binaries compiled with DJGPP for MS-DOS and MS-Windows: 'l' (list) command does not display a lone carriage return (0x0D, ^M) embedded in a line.

(2) The expression "\<" causes problems when attempting the following types of substitutions, which should print "+aaa +bbb":

       echo aaa bbb | sed 's/\</+/g'    # prints "+a+a+a +b+b+b"
       echo aaa bbb | sed 's/\<./+&/g'  # prints "+a+a+a +b+b+b"

(3) The N command no longer discards the contents of the pattern space upon reaching the end of file. This is not a bug, it's a feature. See section 6.7.5, "Commands which operate differently".
7.5. GNU sed v2.05

(1) If a number follows the substitute command (e.g., s/f/F/10) and the number exceeds the possible matches on the pattern space, the command 't label' always jumps to the specified label. 't' should jump only if the substitution was successful (or returned "true").

(2) 'l' (list) command does not convert the following characters to hex values, but passes them through unchanged: 0xF7, 0xFB, 0xFC, 0xFD, 0xFE.

(3) A range address like "/foo/,14" is supposed to match every line from the first occurrence of "foo" until line 14, inclusive, and then match only those lines containing "foo" thereafter. In gsed v2.05, if "foo" occurs later in the file, every line from there to the end of file will be matched (since gsed is looking for line 14 to occur again!).

(4) The regexes /\`/ and /\'/ are not interpreted as a backquote and apostrophe, as might be expected. Instead, they are used to represent the beginning-of-line and end-of-line (respectively), to conform with similar regexes in the GNU versions of Emacs and awk. As a consequence, there is no clear way to indicate an apostrophe, since a bare apostrophe (') has special meaning to the Unix shell and the quoted apostrophe (\') is interpreted as the EOL. A double-quote apostrophe (\\') was interpreted as a backslash to sed and a quote mark to the shell--again, not providing the expected results. This syntax changed in the next version of gsed.

(5) Multiple occurrences of the 'w' command fail, as shown here, given that both "aaa" and "bbb" occur within the file:

       gsed -e "/aaa/w FILE" -e "/bbb/w FILE" input.txt

(6) The expression "\<" causes problems when attempting the following type of substitution, which should print "+aaa +bbb":

       echo aaa bbb | sed 's/\</+/g'    # sed hangs up with no output

The syntax 's/\<./+&/g' issues the proper output.
7.6. GNU sed v1.18

(1) Same as #1 for GNU sed v2.05, above.

(2) The following command will lock the computer under Win95. Echos is an echo command that does not issue a trailing newline:

       echos any_word | gsed "s/[ ]*$//"

(3) Same as #3 for GNU sed v2.05, above.
7.7. GNU sed v1.03 (by Frank Whaley)

(1) The \w and \W escape sequences both match only nonword characters. \w is misdefined and should match word characters.

(2) The underscore is defined as a nonword character; it should be defined as a word character.

(3) same as #3 for GNU sed v2.05, above.
7.8. sed v1.6 (by Walter Briscoe) - still in beta version

(1) Duplicated subexpressions (still) do not match an empty set as they should. This problem was inherited from HHsed15.

       echo 123 | sed "s/\([a-z][a-z]\)*/=\1/"  # does not return '='

(2) If grouping is followed by a + operator, nothing is matched. This problem was inherited from HHsed; it fixed a bug with the * operator, but the problem with the + operator persists.

       echo aaa | sed "/\(a\)+/d"          # nothing is deleted.

(3) With the interval expressions \{1,\} and +, there is a bug related to the & replacement character. This affected the BETA release, and it's not known if it affects the final release.

       echo ab | sed "s/a[^a]*/&c/"        # returns 'abc'. Okay.
       echo ab | sed "s/a[^a]+/&c/"        # returns 'ab'. Bug!
       echo ab | sed "s/a[^a]\{1,\}/&c/"   # returns 'ab'. Bug!

7.9. HHsed v1.5 (by Howard Helman)

(1) If a number follows the substitute command (e.g., s/foo/bar/2), in a sed script entered from the command line, two semicolons must follow the number, or they must be separated by an -e switch. Normally, only 1 semicolon is needed to separate commands.

       echo bit bet | HHsed "s/b/n/2;;s/b/B/"          # solution 1
       echo bit bet | HHsed -e "s/b/n/2" -e "s/b/B"    # solution 2

(2) If the substitute command is followed by a number and a "p" flag, when the -n switch is used, the "p" flag must occur first.

       echo aaa | HHsed -n "s/./B/3p"    # bug! nothing prints
       echo aaa | HHsed -n "s/./B/p3"    # prints "aaB" as expected

(3) The following commands will cause HHsed to lock the computer under MS-DOS or Win95. Note that they occur because of malformed regular expressions which will match no characters.

       sed -n "p;s/\<//g;" file
       sed -n "p;s/[char-set]*//g;" file

(4) The range command '/RE1/,/RE2/' in HHsed will match one line if both regexes occur on the same line (see section 3.4(3), above). Though this could be construed as a feature, it should probably be considered a bug since its operation differs from every other version of sed. For example, '/----/,/----/{s/^/>>/;}' should put two angle brackets ">>" before every line which is sandwiched between a row of 4 or more hyphens. With HHsed, this command will only prefix the hyphens themselves with the angle brackets.

(5) If the hold space is empty, the H command copies the pattern space to the hold space but fails to prepend a leading newline. The H command is supposed to add a newline, followed by the contents of the pattern space, to the hold space at all times. A workaround is "{G;s/^\(.*\)\(\n\)$/\2\1/;H;s/\n$//;}", but it requires knowing that the hold space is empty and using the command only once. Another alternative is to use the G or the h command alone at key points in the script.

(6) If grouping is followed by an '*' or '+' operator, HHsed does not match the pattern, but issues no warning. See below:

       echo aaa | HHsed "/\(a\)*/d"      # nothing is deleted
       echo aaa | HHsed "/\(a\)+/d"      # nothing is deleted
       echo aaa | HHsed "s/\(a\)*/\1B/"  # nothing is changed
       echo aaa | HHsed "s/\(a\)+/\1B/"  # nothing is changed

(7) If grouping is followed by an interval expression, HHsed halts with the error message "garbled command", in all of the following examples:

       echo aaa | HHsed "/\(a\)\{3\}/d"
       echo aaa | HHsed "/\(a\)\{1,5\}/d"
       echo aaa | HHsed "s/\(a\)\{3\}/\1B/"

(8) In interval expressions, 0 is not supported. E.g., \{0,3\)
7.10. sedmod v1.0 (by Hern Chen)

Technically, the following are limits (or features?) of sedmod, not bugs, since the docs for sedmod do not claim to support these missing features.

(1) sedmod does not support standard interval expressions \{...\} present in nearly all versions of sed.

(2) If grouping is followed by an '*' or '+' operator, sedmod gives a "garbled command" message. However, if the grouped expressions are strings literals with no metacharacters, a partial workaround can be done like so:

       \(string\)\1*    # matches 1 or more instances of 'string'
       \(string\)\1+    # matches 2 or more instances of 'string'

(3) sedmod does not support a numeric argument after the s/// command, as in 's/a/b/3', present in nearly all versions of sed.

The following are bugs in sedmod v1.0:

(4) When the -i (ignore case) switch is used, the '/regex/d' command is not properly obeyed. Sedmod may miss one or more lines matching the expression, regardless of where they occur in the script. Workaround: use "/regex/{d;}" instead.
7.11. HP-UX sed

(1) Versions of HP-UX sed up to and including version 10.20 are buggy. According to the README file, which comes with the GNU cc at <ftp://ftp.ntua.gr/pub/gnu/sed/sed-2.05.bin.README>:

"When building gcc on a hppa*-*-hpux10 platform, the `fixincludes' step (which involves running a sed script) fails because of a bug in the vendor's implementation of sed. Currently the only known workaround is to install GNU sed before building gcc. The file sed-2.05.bin.hpux10 is a precompiled binary for that platform."
7.12. SunOS sed v4.1

(1) Bug occurs in RE pattern matching when a non-null '[char-set]*' is followed by a null '\NUM' pattern recall, illustrated here and reported by Greg Ubben:

       s/\(a\)\(b*\)cd\1[0-9]*\2foo/bar/  # between '[0-9]*' and '\2'
       s/\(a\{0,1\}\).\{0,1\}\1/bar/      # between '.\{0,1\}' and '\1'

Workaround: add a do-nothing 'X*' expression which will not match any characters on the line between the two components. E.g.,

       s/\(a\)\(b*\)cd\1[0-9]*X*\2foo/bar/
       s/\(a\{0,1\}\).\{0,1\}X*\1/bar/

7.13. SunOS sed v5.6

(1) If grouping is followed by an asterisk, SunOS sed does not match the null string, which it should do. The following command:

       echo foo | sed 's/f\(NO-MATCH\)*/g\1/'

should transform "foo" to "goo" under normal versions of sed.
7.14. Ultrix sed v4.3

(1) If grouping is followed by an asterisk, Ultrix sed replies with "command garbled", as shown in the following example:

       echo foo | sed 's/f\(NO-MATCH\)*/g\1/'

(2) If grouping is followed by a numeric operator such as \{0,9\}, Ultrix sed does not find the match.
7.15. Digital Unix sed

(1) The following comes from the man pages for sed distributed with new, 1998 versions of Digital Unix (reformatted to fit our margins):

[Digital] The h subcommand for sed does not work properly. When you use the h subcommand to place text into the hold area, only the last line of the specified text is saved. You can use the H subcommand to append text to the hold area. The H subcommand and all others dealing with the hold area work correctly.

(2) "$d" command issues an error message, "cannot parse". Reported by Carlos Duarte on 8 June 1998.
[end-of-file]

This is the end of Section 7 of the sed FAQ.
Go back to Section 6, or up to the index.




