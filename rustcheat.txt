Logo Programming-Idioms.org
< Cheatsheets
Idiom ID Imports Comments Links

    The snippets are under the CC-BY-SA license.
    Please consider keeping a bookmark
    (instead of printing)

		Rust
1 	
Print Hello World
Print a literal string on standard output
	

println!("Hello World");

	
2 	
Print Hello 10 times
Loop to execute some code a constant number of times
	

for _ in 0..10 { println!("Hello"); }

Alternative implementation:

print!("{}", "Hello\n".repeat(10));

	
3 	
Create a procedure
Like a function which doesn't return any value, thus has only side effects (e.g. Print to standard output)
	

fn finish(name : &str) {
    println!("My job here is done. Goodbye {}", name);
}

	
4 	
Create a function
Create a function which returns the square of an integer
	

fn square(x : u32) -> u32 { x * x }

	
5 	
Create a 2D Point data structure
Declare a container type for two floating-point numbers x and y
	

struct Point {
    x: f64,
    y: f64,
}

Alternative implementation:

struct Point(f64, f64);

	
6 	
Iterate over list values
Do something with each item x of an array-like collection items, regardless indexes.
	

for x in items {
	do_something(x);
}

Alternative implementation:

items.into_iter().for_each(|x| do_something(x));

	
7 	
Iterate over list indexes and values
Print each index i with its value x from an array-like collection items
	

for (i, x) in items.iter().enumerate() {
    println!("Item {} = {}", i, x);
}

Alternative implementation:

items.iter().enumerate().for_each(|(i, x)| {
    println!("Item {} = {}", i, x);
})

	
8 	
Initialize a new map (associative array)
Create a new map object x, and provide some (key, value) pairs as initial content.
	

let mut x = BTreeMap::new();
x.insert("one", 1);
x.insert("two", 2);

Alternative implementation:

let x: HashMap<&str, i32> = [
    ("one", 1),
    ("two", 2),
].into_iter().collect();

	
9 	
Create a Binary Tree data structure
The structure must be recursive because left child and right child are binary trees too. A node has access to children nodes, but not to its parent.
	

struct BinTree<T> {
    value: T,
    left: Option<Box<BinTree<T>>>,
    right: Option<Box<BinTree<T>>>,
}

	
10 	
Shuffle a list
Generate a random permutation of the elements of list x
	

let mut rng = StdRng::new().unwrap();
rng.shuffle(&mut x);

Alternative implementation:

let mut rng = thread_rng();
x.shuffle(&mut rng);

	
11 	
Pick a random element from a list
The list x must be non-empty.
	

x[rand::thread_rng().gen_range(0..x.len())]

Alternative implementation:

let mut rng = rand::thread_rng();
let choice = x.choose(&mut rng).unwrap();

	
12 	
Check if list contains a value
Check if the list contains the value x.
list is an iterable finite container.
	

list.contains(&x);

Alternative implementation:

list.iter().any(|v| v == &x)

Alternative implementation:

(&list).into_iter().any(|v| v == &x)

	
13 	
Iterate over map keys and values
Access each key k with its value x from an associative array mymap, and print them.
	

for (k, x) in &mymap {
    println!("Key={key}, Value={val}", key=k, val=x);
}

	
14 	
Pick uniformly a random floating point number in [a..b)
Pick a random number greater than or equals to a, strictly inferior to b. Precondition : a < b.
	

thread_rng().gen_range(a..b);

	
15 	
Pick uniformly a random integer in [a..b]
Pick a random integer greater than or equals to a, inferior or equals to b. Precondition : a < b.
	

fn pick(a: i32, b: i32) -> i32 {
    let between = Range::new(a, b);
    let mut rng = rand::thread_rng();
    between.ind_sample(&mut rng)
}

Alternative implementation:

Uniform::new_inclusive(a, b).sample(&mut rand::thread_rng())

	
16 	
Depth-first traversal of a binary tree
Call a function f on every node of binary tree bt, in depth-first infix order
	

fn depthFirstTraverse<T>(bt: &mut BiTree<T>, f: fn(&mut BiTree<T>)) {
    if let Some(left) = &mut bt.left {
        f(left);
    }
    
    f(bt);
    
    if let Some(right) = &mut bt.right {
        f(right);
    }
}

	
17 	
Create a Tree data structure
The structure must be recursive. A node may have zero or more children. A node has access to its children nodes, but not to its parent.
	

struct Node<T> {
  value: T,
  children: Vec<Node<T>>,
}

	
18 	
Depth-first traversal of a tree
Call a function f on every node of a tree, in depth-first prefix order
	

pub struct Tree<V> {
    children: Vec<Tree<V>>,
    value: V
}

impl<V> Tree<V> {
    pub fn dfs<F: Fn(&V)>(&self, f: F) {
        self.dfs_helper(&f);
    }
    fn dfs_helper<F: Fn(&V)>(&self, f: &F) {
        (f)(&self.value);
        for child in &self.children {
            child.dfs_helper(f)
        }
    }
    // ...
}

	
19 	
Reverse a list
Reverse the order of the elements of the list x.
This may reverse "in-place" and destroy the original ordering.
	

let y: Vec<_> = x.into_iter().rev().collect();

Alternative implementation:

x.reverse();

	
20 	
Return two values
Implement a function search which looks for item x in a 2D matrix m.
Return indices i, j of the matching cell.
Think of the most idiomatic way in the language to return the two values at the same time.
	

fn search<T: Eq>(m: &Vec<Vec<T>>, x: &T) -> Option<(usize, usize)> {
    for (i, row) in m.iter().enumerate() {
        for (j, column) in row.iter().enumerate() {
            if *column == *x {
                return Some((i, j));
            }
        }
    }

    None
}

	
21 	
Swap values
Swap the values of the variables a and b
	

std::mem::swap(&mut a, &mut b);

Alternative implementation:

let (a, b) = (b, a);

	
22 	
Convert string to integer
Extract the integer value i from its string representation s (in radix 10)
	

let i = s.parse::<i32>().unwrap();

Alternative implementation:

let i: i32 = s.parse().unwrap_or(0);

Alternative implementation:

let i = match s.parse::<i32>() {
  Ok(i) => i,
  Err(_e) => -1,
};

	
23 	
Convert real number to string with 2 decimal places
Given a real number x, create its string representation s with 2 decimal digits following the dot.
	

let s = format!("{:.2}", x);

	
24 	
Assign to string the japanese word ネコ
Declare a new string s and initialize it with the literal value "ネコ" (which means "cat" in japanese)
	

let s = "ネコ";

	
25 	
Send a value to another thread
Share the string value "Alan" with an existing running process which will then display "Hello, Alan"
	

let (send, recv) = channel();

thread::spawn(move || {
    loop {
        let msg = recv.recv().unwrap();
        println!("Hello, {:?}", msg);
    }  
});

send.send("Alan").unwrap();

	
26 	
Create a 2-dimensional array
Declare and initialize a matrix x having m rows and n columns, containing real numbers.
	

let mut x = vec![vec![0.0f64; N]; M];

Alternative implementation:

let mut x = [[0.0; N] ; M];

	
27 	
Create a 3-dimensional array
Declare and initialize a 3D array x, having dimensions boundaries m, n, p, and containing real numbers.
	

let x = vec![vec![vec![0.0f64; p]; n]; m];

Alternative implementation:

let x = [[[0.0f64; P]; N]; M];

	
28 	
Sort by a property
Sort the elements of the list (or array-like collection) items in ascending order of x.p, where p is a field of the type Item of the objects in items.
	

items.sort_by(|a,b| a.p.cmp(&b.p));

Alternative implementation:

items.sort_by_key(|x| x.p);

	
29 	
Remove item from list, by its index
Remove i-th item from list items.
This will alter the original list or return a new list, depending on which is more idiomatic.
Note that in most languages, the smallest valid value for i is 0.
	

items.remove(i)

	
30 	
Parallelize execution of 1000 independent tasks
Launch the concurrent execution of procedure f with parameter i from 1 to 1000.
Tasks are independent and f(i) doesn't return any value.
Tasks need not run all at the same time, so you may use a pool.
	

let threads: Vec<_> = (0..1000).map(|i| {
	thread::spawn(move || f(i))
}).collect();

for thread in threads {
	thread.join();
}

Alternative implementation:

(0..1000).into_par_iter().for_each(f);

	
31 	
Recursive factorial (simple)
Create the recursive function f which returns the factorial of the non-negative integer i, calculated from f(i-1)
	

fn f(n: u32) -> u32 {
    if n < 2 {
        1
    } else {
        n * f(n - 1)
    }
}

Alternative implementation:

fn factorial(num: u64) -> u64 {
    match num {
        0 | 1 => 1,
        _ => factorial(num - 1) * num,
    }
}

	
32 	
Integer exponentiation by squaring
Create function exp which calculates (fast) the value x power n.
x and n are non-negative integers.
	

fn exp(x: u64, n: u64) -> u64 {
    match n {
        0 => 1,
        1 => x,
        i if i % 2 == 0 => exp(x * x, n / 2),
        _ => x * exp(x * x, (n - 1) / 2),
    }     
}

Alternative implementation:

fn exp(x: u64, n: u32) -> u64 {
    x.pow(n)
}

	
33 	
Atomically read and update variable
Assign to the variable x the new value f(x), making sure that no other thread may modify x between the read and the write.
	

let mut x = x.lock().unwrap();
*x = f(x);

	
34 	
Create a set of objects
Declare and initialize a set x containing unique objects of type T.
	

let x: HashSet<T> = HashSet::new();

	
35 	
First-class function : compose
Implement a function compose (A -> C) with parameters f (A -> B) and g (B -> C), which returns the composition function g ∘ f
	

fn compose<'a, A, B, C, G, F>(f: F, g: G) -> Box<Fn(A) -> C + 'a>
	where F: 'a + Fn(A) -> B, G: 'a + Fn(B) -> C
{
	Box::new(move |x| g(f(x)))
}

Alternative implementation:

fn compose<A, B, C>(f: impl Fn(A) -> B, g: impl Fn(B) -> C) -> impl Fn(A) -> C {
    move |x| g(f(x))
}

	
36 	
First-class function : generic composition
Implement a function compose which returns composition function g ∘ f for any functions f and g having exactly 1 parameter.
	

fn compose<'a, A, B, C, G, F>(f: F, g: G) -> Box<Fn(A) -> C + 'a>
	where F: 'a + Fn(A) -> B, G: 'a + Fn(B) -> C
{
	Box::new(move |x| g(f(x)))
}

Alternative implementation:

fn compose<A, B, C>(f: impl Fn(A) -> B, g: impl Fn(B) -> C) -> impl Fn(A) -> C {
    move |x| g(f(x))
}

	
37 	
Currying
Transform a function that takes multiple arguments into a function for which some of the arguments are preset.
	

fn add(a: u32, b: u32) -> u32 {
    a + b
}

let add5 = move |x| add(5, x);
 

	
38 	
Extract a substring
Find substring t consisting in characters i (included) to j (excluded) of string s.
Character indices start at 0 unless specified otherwise.
Make sure that multibyte characters are properly handled.
	

let t = s.graphemes(true).skip(i).take(j - i).collect::<String>();

Alternative implementation:

let t = s.substring(i, j);

	
39 	
Check if string contains a word
Set boolean ok to true if string word is contained in string s as a substring, or to false otherwise.
	

let ok = s.contains(word);

	
41 	
Reverse a string
Create string t containing the same characters as string s, in reverse order.
Original string s must remain unaltered. Each character must be handled correctly regardless its number of bytes in memory.
	

let t = s.chars().rev().collect::<String>();

Alternative implementation:

let t: String = s.chars().rev().collect();

	
42 	
Continue outer loop
Print each item v of list a which is not contained in list b.
For this, write an outer loop to iterate on a and an inner loop to iterate on b.
	

'outer: for va in &a {
    for vb in &b {
        if va == vb {
            continue 'outer;
        }
    }
    println!("{}", va);
}

	
43 	
Break outer loop
Look for a negative value v in 2D integer matrix m. Print it and stop searching.
	

'outer: for v in m {
    'inner: for i in v {
        if i < 0 {
            println!("Found {}", i);
            break 'outer;
        }
    }
}

	
44 	
Insert element in list
Insert the element x at position i in the list s. Further elements must be shifted to the right.
	

s.insert(i, x);

	
45 	
Pause execution for 5 seconds
Sleep for 5 seconds in current thread, before proceeding with the next instructions.
	

thread::sleep(time::Duration::from_secs(5));

	
46 	
Extract beginning of string (prefix)
Create string t consisting of the 5 first characters of string s.
Make sure that multibyte characters are properly handled.
	

let t = s.char_indices().nth(5).map_or(s, |(i, _)| &s[..i]);

Alternative implementation:

let t = s.chars().take(5).collect::<String>();

	
47 	
Extract string suffix
Create string t consisting in the 5 last characters of string s.
Make sure that multibyte characters are properly handled.
	

let last5ch = s.chars().count() - 5;
let t: String = s.chars().skip(last5ch).collect();

	
48 	
Multi-line string literal
Assign to variable s a string literal consisting in several lines of text, including newlines.
	

let s = "line 1
line 2
line 3";

Alternative implementation:

let s = r#"Huey
Dewey
Louie"#;

	
49 	
Split a space-separated string
Build list chunks consisting in substrings of input string s, separated by one or more space characters.
	

let chunks: Vec<_> = s.split_whitespace().collect();

Alternative implementation:

let chunks: Vec<_> = s.split_ascii_whitespace().collect();

Alternative implementation:

let chunks: Vec<_> = s.split(' ').collect();

	
50 	
Make an infinite loop
Write a loop that has no end clause.
	

loop {
	// Do something
}

	
51 	
Check if map contains key
Determine whether the map m contains an entry for the key k
	

m.contains_key(&k)

	
52 	
Check if map contains value
Determine whether the map m contains an entry with the value v, for some key.
	

let does_contain = m.values().any(|&val| *val == v);

	
53 	
Join a list of strings
Concatenate elements of string list x joined by the separator ", " to create a single string y.
	

let y = x.join(", ");

	
54 	
Compute sum of integers
Calculate the sum s of the integer list or array x.
	

x.iter().sum()

Alternative implementation:

let s = x.iter().sum::<i32>();

	
55 	
Convert integer to string
Create the string representation s (in radix 10) of the integer value i.
	

let s = i.to_string();

Alternative implementation:

let s = format!("{}", i);

	
56 	
Launch 1000 parallel tasks and wait for completion
Fork-join : launch the concurrent execution of procedure f with parameter i from 1 to 1000.
Tasks are independent and f(i) doesn't return any value.
Tasks need not run all at the same time, so you may use a pool.
Wait for the completion of the 1000 tasks and then print "Finished".
	

let threads: Vec<_> = (0..1000).map(|i| thread::spawn(move || f(i))).collect();

for t in threads {
	t.join();
}

	
57 	
Filter list
Create the list y containing the items from the list x that satisfy the predicate p. Respect the original ordering. Don't modify x in-place.
	

let y: Vec<_> = x.iter().filter(p).collect();

	
58 	
Extract file content to a string
Create string lines from the content of the file with filename f.
	

let mut file = File::open(f)?;
let mut lines = String::new();
file.read_to_string(&mut lines)?;

Alternative implementation:

let lines = fs::read_to_string(f).expect("Can't read file.");

	
59 	
Write to standard error stream
Print the message "x is negative" to standard error (stderr), with integer x value substitution (e.g. "-2 is negative").
	

eprintln!("{} is negative", x);

	
60 	
Read command line argument
Assign to x the string value of the first command line parameter, after the program name.
	

let first_arg = env::args().skip(1).next();

let fallback = "".to_owned();
let x = first_arg.unwrap_or(fallback);

Alternative implementation:

let x = env::args().nth(1).unwrap_or("".to_string());

	
61 	
Get current date
Assign to the variable d the current date/time value, in the most standard type.
	

let d = time::now();

Alternative implementation:

let d = SystemTime::now();

	
62 	
Find substring position
Set i to the first position of string y inside string x, if exists.

Specify if i should be regarded as a character index or as a byte index.

Explain the behavior when y is not contained in x.
	

let i = x.find(y);

	
63 	
Replace fragment of a string
Assign to x2 the value of string x with all occurrences of y replaced by z.
Assume occurrences of y are not overlapping.
	

let x2 = x.replace(&y, &z);

	
64 	
Big integer : value 3 power 247
Assign to x the value 3^247
	

let a = 3.to_bigint().unwrap();
let x = num::pow(a, 247);

	
65 	
Format decimal number
From the real value x in [0,1], create its percentage string representation s with one digit after decimal point. E.g. 0.15625 -> "15.6%"
	

let s = format!("{:.1}%", 100.0 * x);

	
66 	
Big integer exponentiation
Calculate the result z of x power n, where x is a big integer and n is a positive integer.
	

let z = num::pow(x, n);

	
67 	
Binomial coefficient "n choose k"
Calculate binom(n, k) = n! / (k! * (n-k)!). Use an integer type able to handle huge numbers.
	

fn binom(n: u64, k: u64) -> BigInt {
    let mut res = BigInt::one();
    for i in 0..k {
        res = (res * (n - i).to_bigint().unwrap()) /
              (i + 1).to_bigint().unwrap();
    }
    res
}

	
68 	
Create a bitset
Create an object x to store n bits (n being potentially large).
	

let mut x = vec![false; n];

	
69 	
Seed random generator
Use seed s to initialize a random generator.

If s is constant, the generator output will be the same each time the program runs. If s is based on the current value of the system clock, the generator output will be different each time.
	

let s = 32;
let mut rng = StdRng::seed_from_u64(s);

	
70 	
Use clock as random generator seed
Get the current datetime and provide it as a seed to a random generator. The generator sequence will be different at each run.
	

let d = SystemTime::now()
    .duration_since(SystemTime::UNIX_EPOCH)
    .expect("Duration since UNIX_EPOCH failed");
let mut rng = StdRng::seed_from_u64(d.as_secs());

	
71 	
Echo program implementation
Basic implementation of the Echo program: Print all arguments except the program name, separated by space, followed by newline.
The idiom demonstrates how to skip the first argument if necessary, concatenate arguments as strings, append newline and print it to stdout.
	

println!("{}", env::args().skip(1).collect::<Vec<_>>().join(" "));

Alternative implementation:

println!("{}", std::env::args().skip(1).format(" "));

	
74 	
Compute GCD
Compute the greatest common divisor x of big integers a and b. Use an integer type able to handle huge numbers.
	

let x = a.gcd(&b);

	
75 	
Compute LCM
Compute the least common multiple x of big integers a and b. Use an integer type able to handle huge numbers.
	

let x = a.lcm(&b);

	
76 	
Binary digits from an integer
Create the string s of integer x written in base 2.

E.g. 13 -> "1101"
	

let s = format!("{:b}", x);

Alternative implementation:

let s = format!("{x:b}");

	
77 	
Complex number
Declare a complex x and initialize it with value (3i - 2). Then multiply it by i.
	

let mut x = Complex::new(-2, 3);
x *= Complex::i();

	
78 	
"do while" loop
Execute a block once, then execute it again as long as boolean condition c is true.
	

loop {
    doStuff();
    if !c { break; }
}

Alternative implementation:

while {
   doStuff();
   c
} { /* EMPTY */ }

	
79 	
Convert integer to floating point number
Declare the floating point number y and initialize it with the value of the integer x .
	

let y = x as f64;

	
80 	
Truncate floating point number to integer
Declare integer y and initialize it with the value of floating point number x . Ignore non-integer digits of x .
Make sure to truncate towards zero: a negative x must yield the closest greater integer (not lesser).
	

let y = x as i32;

	
81 	
Round floating point number to integer
Declare the integer y and initialize it with the rounded value of the floating point number x .
Ties (when the fractional part of x is exactly .5) must be rounded up (to positive infinity).
	

let y = x.round() as i64;

	
82 	
Count substring occurrences
Find how many times string s contains substring t.
Specify if overlapping occurrences are counted.
	

let c = s.matches(t).count();

	
83 	
Regex with character repetition
Declare regular expression r matching strings "http", "htttp", "httttp", etc.
	

let r = Regex::new(r"htt+p").unwrap();

	
84 	
Count bits set in integer binary representation
Count number c of 1s in the integer i in base 2.

E.g. i=6 → c=2
	

let c = i.count_ones();

	
85 	
Check if integer addition will overflow
Write boolean function addingWillOverflow which takes two integers x, y and return true if (x+y) overflows.

An overflow may be above the max positive value, or below the min negative value.
	

fn adding_will_overflow(x: usize, y: usize) -> bool {
    x.checked_add(y).is_none()
}

	
86 	
Check if integer multiplication will overflow
Write boolean function multiplyWillOverflow which takes two integers x, y and return true if (x*y) overflows.

An overflow may be above the max positive value, or below the min negative value.
	

fn multiply_will_overflow(x: i64, y: i64) -> bool {
    x.checked_mul(y).is_none()
}

	
87 	
Stop program
Exit immediately.
If some extra cleanup work is executed by the program runtime (not by the OS itself), describe it.
	

std::process::exit(0);

	
88 	
Allocate 1M bytes
Create a new bytes buffer buf of size 1,000,000.
	

let buf: Vec<u8> = Vec::with_capacity(1000000);

	
89 	
Handle invalid argument
You've detected that the integer value of argument x passed to the current function is invalid. Write the idiomatic way to abort the function execution and signal the problem.
	

enum CustomError { InvalidAnswer }

fn do_stuff(x: i32) -> Result<i32, CustomError> {
    if x != 42 {
        Err(CustomError::InvalidAnswer)
    } else {
        Ok(x)
    }
}

	
90 	
Read-only outside
Expose a read-only integer x to the outside world while being writable inside a structure or a class Foo.
	

struct Foo {
    x: usize
}

impl Foo {
    pub fn new(x: usize) -> Self {
        Foo { x }
    }

    pub fn x<'a>(&'a self) -> &'a usize {
        &self.x
    }

    pub fn bar(&mut self) {
        self.x += 1;
    }
}

	
91 	
Load JSON file into object
Read from the file data.json and write its content into the object x.
Assume the JSON data is suitable for the type of x.
	

let x = ::serde_json::from_reader(File::open("data.json")?)?;

	
92 	
Save object into JSON file
Write the contents of the object x into the file data.json.
	

::serde_json::to_writer(&File::create("data.json")?, &x)?

	
93 	
Pass a runnable procedure as parameter
Implement procedure control which receives one parameter f, and runs f.
	

fn control(f: impl Fn()) {
    f();
}

	
94 	
Print the type of a variable
Print the name of the type of x. Explain if it is a static type or dynamic type.

This may not make sense in all languages.
	

fn type_of<T>(_: &T) -> &'static str {
    std::intrinsics::type_name::<T>()
}

println!("{}", type_of(&x));

	
95 	
Get file size
Assign to variable x the length (number of bytes) of the local file at path.
	

let x = fs::metadata(path)?.len();

Alternative implementation:

let x = path.metadata()?.len();

	
96 	
Check string prefix
Set boolean b to true if string s starts with prefix prefix, false otherwise.
	

let b = s.starts_with(prefix);

	
97 	
Check string suffix
Set boolean b to true if string s ends with string suffix, false otherwise.
	

let b = s.ends_with(suffix);

	
98 	
Epoch seconds to date object
Convert a timestamp ts (number of seconds in epoch-time) to a date with time d. E.g. 0 -> 1970-01-01 00:00:00
	

let d = NaiveDateTime::from_timestamp(ts, 0);

	
99 	
Format date YYYY-MM-DD
Assign to the string x the value of the fields (year, month, day) of the date d, in format YYYY-MM-DD.
	

Utc::today().format("%Y-%m-%d")

Alternative implementation:

let format = format_description!("[year]-[month]-[day]");
let x = d.format(&format).expect("Failed to format the date");

	
100 	
Sort by a comparator
Sort elements of array-like collection items, using a comparator c.
	

items.sort_by(c);

	
101 	
Load from HTTP GET request into a string
Make an HTTP request with method GET to the URL u, then store the body of the response in the string s.
	

let client = Client::new();
let s = client.get(u).send().and_then(|res| res.text())?;

Alternative implementation:

let s = ureq::get(u).call().into_string()?;

Alternative implementation:

let mut response = reqwest::blocking::get(u)?;
let mut s = String::new();
response.read_to_string(&mut s)?;

	
102 	
Load from HTTP GET request into a file
Make an HTTP request with method GET to URL u, then store the body of the response in file result.txt. Try to save the data as it arrives if possible, without having all its content in memory at once.
	

let client = Client::new();
match client.get(&u).send() {
    Ok(res) => {
        let file = File::create("result.txt")?;
        ::std::io::copy(res, file)?;
    },
    Err(e) => eprintln!("failed to send request: {}", e),
};

	
105 	
Current executable name
Assign to the string s the name of the currently executing program (but not its full path).
	

fn get_exec_name() -> Option<String> {
    std::env::current_exe()
        .ok()
        .and_then(|pb| pb.file_name().map(|s| s.to_os_string()))
        .and_then(|s| s.into_string().ok())
}

fn main() -> () {
    let s = get_exec_name().unwrap();
    println!("{}", s);
}

Alternative implementation:

let s = std::env::current_exe()
    .expect("Can't get the exec path")
    .file_name()
    .expect("Can't get the exec name")
    .to_string_lossy()
    .into_owned();

	
106 	
Get program working directory
Assign to string dir the path of the working directory.
(This is not necessarily the folder containing the executable itself)
	

let dir = env::current_dir().unwrap();

	
107 	
Get folder containing current program
Assign to string dir the path of the folder containing the currently running executable.
(This is not necessarily the working directory, though.)
	

let dir = std::env::current_exe()?
    .canonicalize()
    .expect("the current exe should exist")
    .parent()
    .expect("the current exe should be a file")
    .to_string_lossy()
    .to_owned();

	
109 	
Number of bytes of a type
Set n to the number of bytes of a variable t (of type T).
	

let n = ::std::mem::size_of::<T>();

	
110 	
Check if string is blank
Set the boolean blank to true if the string s is empty, or null, or contains only whitespace ; false otherwise.
	

let blank = s.trim().is_empty();

Alternative implementation:

let blank = s.chars().all(|c| c.is_whitespace());

	
111 	
Launch other program
From current process, run program x with command-line parameters "a", "b".
	

let output = Command::new("x")
    .args(&["a", "b"])
    .spawn()
    .expect("failed to execute process");

Alternative implementation:

let output = Command::new("x")
        .args(&["a", "b"])
        .output()
        .expect("failed to execute process");

Alternative implementation:

let output = Command::new("x")
        .args(&["a", "b"])
        .status()
        .expect("failed to execute process");

	
112 	
Iterate over map entries, ordered by keys
Print each key k with its value x from an associative array mymap, in ascending order of k.
	

for (k, x) in mymap {
    println!("({}, {})", k, x);
}

	
113 	
Iterate over map entries, ordered by values
Print each key k with its value x from an associative array mymap, in ascending order of x.
Note that multiple entries may exist for the same value x.
	

for (k, x) in mymap.iter().sorted_by_key(|x| x.1) {
	println!("[{},{}]", k, x);
}

Alternative implementation:

let mut items: Vec<_> = mymap.iter().collect();
items.sort_by_key(|item| item.1);
for (k, x) in items {
    println!("[{},{}]", k, x);
}

	
114 	
Test deep equality
Set boolean b to true if objects x and y contain the same values, recursively comparing all referenced elements in x and y.
Tell if the code correctly handles recursive types.
	

let b = x == y;

	
115 	
Compare dates
Set boolean b to true if date d1 is strictly before date d2 ; false otherwise.
	

let b = d1 < d2;

	
116 	
Remove occurrences of word from string
Remove all occurrences of string w from string s1, and store the result in s2.
	

s2 = s1.replace(w, "");

Alternative implementation:

let s2 = str::replace(s1, w, "");

	
117 	
Get list size
Set n to the number of elements of the list x.
	

let n = x.len();

	
118 	
List to set
Create the set y from the list x.
x may contain duplicates. y is unordered and has no repeated values.
	

let y: HashSet<_> = x.into_iter().collect();

	
119 	
Deduplicate list
Remove duplicates from the list x.
Explain if the original order is preserved.
	

x.sort();
x.dedup();

Alternative implementation:

let dedup: Vec<_> = x.iter().unique().collect();

	
120 	
Read integer from stdin
Read an integer value from the standard input into the variable n
	

fn get_input() -> String {
    let mut buffer = String::new();
    std::io::stdin().read_line(&mut buffer).expect("Failed");
    buffer
}

let n = get_input().trim().parse::<i64>().unwrap();

Alternative implementation:

let mut input = String::new();
io::stdin().read_line(&mut input).unwrap();
let n: i32 = input.trim().parse().unwrap();

Alternative implementation:

let n: i32 = std::io::stdin()
    .lock()
    .lines()
    .next()
    .expect("stdin should be available")
    .expect("couldn't read from stdin")
    .trim()
    .parse()
    .expect("input was not an integer");

Alternative implementation:

let n: i32 = read!();

	
121 	
UDP listen and read
Listen UDP traffic on port p and read 1024 bytes into buffer b.
	

let mut b = [0 as u8; 1024];
let sock = UdpSocket::bind(("localhost", p)).unwrap();
sock.recv_from(&mut b).unwrap();

	
122 	
Declare an enumeration
Create an enumerated type Suit with 4 possible values SPADES, HEARTS, DIAMONDS, CLUBS.
	

enum Suit {
    Spades,
    Hearts,
    Diamonds,
    Clubs,
}

	
123 	
Assert condition
Verify that predicate isConsistent returns true, otherwise report assertion violation.
Explain if the assertion is executed even in production environment or not.
	

assert!(is_consistent);

	
124 	
Binary search for a value in sorted array
Write the function binarySearch which returns the index of an element having the value x in the sorted array a, or -1 if no such element exists.
	

a.binary_search(&x).unwrap_or(-1);

	
125 	
Measure function call duration
measure the duration t, in nanoseconds, of a call to the function foo. Print this duration.
	

let start = Instant::now();
foo();
let duration = start.elapsed();
println!("{}", duration);

	
126 	
Multiple return values
Write a function foo that returns a string and a boolean value.
	

fn foo() -> (String, bool) {
    (String::from("bar"), true)
}

	
127 	
Source code inclusion
Import the source code for the function foo body from a file "foobody.txt".
	

fn main() {
    include!("foobody.txt");
}

	
128 	
Breadth-first traversing of a tree
Call a function f on every node of a tree, in breadth-first prefix order
	

struct Tree<V> {
    children: Vec<Tree<V>>,
    value: V
}

impl<V> Tree<V> {
    fn bfs(&self, f: impl Fn(&V)) {
        let mut q = VecDeque::new();
        q.push_back(self);

        while let Some(t) = q.pop_front() {
            (f)(&t.value);
            for child in &t.children {
                q.push_back(child);
            }
        }
    }
}

	
129 	
Breadth-first traversal in a graph
Call the function f on every vertex accessible from the vertex start, in breadth-first prefix order
	

struct Vertex<V> {
	value: V,
	neighbours: Vec<Weak<RefCell<Vertex<V>>>>,
}

// ...

fn bft(start: Rc<RefCell<Vertex<V>>>, f: impl Fn(&V)) {
	let mut q = vec![start];
	let mut i = 0;
	while i < q.len() {
	    let v = Rc::clone(&q[i]);
	    i += 1;
	    (f)(&v.borrow().value);
	    for n in &v.borrow().neighbours {
	        let n = n.upgrade().expect("Invalid neighbour");
	        if q.iter().all(|v| v.as_ptr() != n.as_ptr()) {
	            q.push(n);
	        }
	    }
	}
}

	
130 	
Depth-first traversal in a graph
Call th function f on every vertex accessible from the vertex v, in depth-first prefix order
	

struct Vertex<V> {
	value: V,
	neighbours: Vec<Weak<RefCell<Vertex<V>>>>,
}

// ...

fn dft_helper(start: Rc<RefCell<Vertex<V>>>, f: &impl Fn(&V), s: &mut Vec<*const Vertex<V>>) {
	s.push(start.as_ptr());
	(f)(&start.borrow().value);
	for n in &start.borrow().neighbours {
		let n = n.upgrade().expect("Invalid neighbor");
		if s.iter().all(|&p| p != n.as_ptr()) {
			Self::dft_helper(n, f, s);
		}
	}
}

	
131 	
Successive conditions
Execute f1 if condition c1 is true, or else f2 if condition c2 is true, or else f3 if condition c3 is true.
Don't evaluate a condition when a previous condition was true.
	

if c1 { f1() } else if c2 { f2() } else if c3 { f3() }

Alternative implementation:

match true {
    _ if c1 => f1(),
    _ if c2 => f2(),
    _ if c3 => f3(),
    _ => (),
}

	
132 	
Measure duration of procedure execution
Run procedure f, and return the duration of the execution of f.
	

let start = Instant::now();
f();
let duration = start.elapsed();

	
133 	
Case-insensitive string contains
Set boolean ok to true if string word is contained in string s as a substring, even if the case doesn't match, or to false otherwise.
	

let re = Regex::new(&format!("(?i){}", regex::escape(word))).unwrap();
let ok = re.is_match(&s);

Alternative implementation:

let re =
    RegexBuilder::new(&regex::escape(word))
    .case_insensitive(true)
    .build().unwrap();

let ok = re.is_match(s);

Alternative implementation:

let ok = s.to_ascii_lowercase().contains(&word.to_ascii_lowercase());

	
134 	
Create a new list
Declare and initialize a new list items, containing 3 elements a, b, c.
	

let items = vec![a, b, c];

	
135 	
Remove item from list, by its value
Remove at most 1 item from list items, having the value x.
This will alter the original list or return a new list, depending on which is more idiomatic.
If there are several occurrences of x in items, remove only one of them. If x is absent, keep items unchanged.
	

if let Some(i) = items.first(&x) {
    items.remove(i);
}

	
136 	
Remove all occurrences of a value from a list
Remove all occurrences of value x from list items.
This will alter the original list or return a new list, depending on which is more idiomatic.
	

items = items.into_iter().filter(|&item| item != x).collect();

Alternative implementation:

items.retain(|&item| item != x);

	
137 	
Check if string contains only digits
Set the boolean b to true if the string s contains only characters in the range '0'..'9', false otherwise.
	

let chars_are_numeric: Vec<bool> = s.chars()
				.map(|c|c.is_numeric())
				.collect();
let b = !chars_are_numeric.contains(&false);

Alternative implementation:

let b = s.chars().all(char::is_numeric);

Alternative implementation:

let b = s.bytes().all(|c| c.is_ascii_digit());

	
138 	
Create temp file
Create a new temporary file on the filesystem.
	

let temp_dir = TempDir::new("prefix")?;
let temp_file = File::open(temp_dir.path().join("file_name"))?;

	
139 	
Create temp directory
Create a new temporary folder on filesystem, for writing.
	

let tmp = TempDir::new("prefix")?;

	
140 	
Delete map entry
Delete from map m the entry having key k.

Explain what happens if k is not an existing key in m.
	

m.remove(&k);

	
141 	
Iterate in sequence over two lists
Iterate in sequence over the elements of the list items1 then items2. For each iteration print the element.
	

for i in item1.iter().chain(item2.iter()) {
    print!("{} ", i);
}

	
142 	
Hexadecimal digits of an integer
Assign to string s the hexadecimal representation (base 16) of integer x.

E.g. 999 -> "3e7"
	

let s = format!("{:X}", x);

	
143 	
Iterate alternatively over two lists
Iterate alternatively over the elements of the lists items1 and items2. For each iteration, print the element.

Explain what happens if items1 and items2 have different size.
	

for pair in izip!(&items1, &items2) {
    println!("{}", pair.0);
    println!("{}", pair.1);
}

	
144 	
Check if file exists
Set boolean b to true if file at path fp exists on filesystem; false otherwise.

Beware that you should never do this and then in the next instruction assume the result is still valid, this is a race condition on any multitasking OS.
	

let b = std::path::Path::new(fp).exists();

	
145 	
Print log line with datetime
Print message msg, prepended by current date and time.

Explain what behavior is idiomatic: to stdout or stderr, and what the date format is.
	

eprintln!("[{}] {}", humantime::format_rfc3339_seconds(std::time::SystemTime::now()), msg);

	
146 	
Convert string to floating point number
Extract floating point value f from its string representation s
	

let f = s.parse::<f32>().unwrap();

Alternative implementation:

let f: f32 = s.parse().unwrap();

	
147 	
Remove all non-ASCII characters
Create string t from string s, keeping only ASCII characters
	

let t = s.replace(|c: char| !c.is_ascii(), "");

Alternative implementation:

let t = s.chars().filter(|c| c.is_ascii()).collect::<String>();

	
148 	
Read list of integers from stdin
Read a list of integer numbers from the standard input, until EOF.
	

let mut string = String::new();
io::stdin().read_to_string(&mut string)?;
let result = string
    .lines()
    .map(i32::from_str)
    .collect::<Result<Vec<_>, _>>();

	
150 	
Remove trailing slash
Remove the last character from the string p, if this character is a forward slash /
	

if p.ends_with('/') { p.pop(); }

	
151 	
Remove string trailing path separator
Remove last character from string p, if this character is the file path separator of current platform.

Note that this also transforms unix root path "/" into the empty string!
	

let p = if ::std::path::is_separator(p.chars().last().unwrap()) {
    &p[0..p.len()-1]
} else {
    p
};

Alternative implementation:

p = p.strip_suffix(std::path::is_separator).unwrap_or(p);

	
152 	
Turn a character into a string
Create string s containing only the character c.
	

let s = c.to_string();

	
153 	
Concatenate string with integer
Create the string t as the concatenation of the string s and the integer i.
	

let t = format!("{}{}", s, i);
// or
let t = format!("{s}{i}");

	
154 	
Halfway between two hex color codes
Find color c, the average between colors c1, c2.

c, c1, c2 are strings of hex color codes: 7 chars, beginning with a number sign # .
Assume linear computations, ignore gamma corrections.
	

"Too long for text box, see online demo"

	
155 	
Delete file
Delete from filesystem the file having path filepath.
	

let r = fs::remove_file(filepath);

	
156 	
Format integer with zero-padding
Assign to the string s the value of the integer i in 3 decimal digits. Pad with zeros if i < 100. Keep all digits if i ≥ 1000.
	

let s = format!("{:03}", i);

	
157 	
Declare constant string
Initialize a constant planet with string value "Earth".
	

const PLANET: &str = "Earth";

	
158 	
Random sublist
Create a new list y from randomly picking exactly k elements from list x.

It is assumed that x has at least k elements.
Each element must have same probability to be picked.
Each element from x must be picked at most once.
Explain if the original ordering is preserved or not.
	

let mut rng = &mut rand::thread_rng();
let y = x.choose_multiple(&mut rng, k).cloned().collect::<Vec<_>>();

	
159 	
Trie
Define a Trie data structure, where entries have an associated value.
(Not all nodes are entries)
	

struct Trie {
    val: String,
    nodes: Vec<Trie>
}

	
160 	
Detect if 32-bit or 64-bit architecture
Execute f32() if platform is 32-bit, or f64() if platform is 64-bit.
This can be either a compile-time condition (depending on target) or a runtime detection.
	

match std::mem::size_of::<&char>() {
    4 => f32(),
    8 => f64(),
    _ => {}
}

	
161 	
Multiply all the elements of a list
Multiply all the elements of the list elements by a constant c
	

let elements = elements.into_iter().map(|x| c * x).collect::<Vec<_>>();

Alternative implementation:

elements.iter_mut().for_each(|x| *x *= c);

	
162 	
Execute procedures depending on options
execute bat if b is a program option and fox if f is a program option.
	

if let Some(arg) = ::std::env::args().nth(1) {
    if &arg == "f" {
        fox();
    } else if &arg = "b" {
        bat();
    } else {
	eprintln!("invalid argument: {}", arg),
    }
} else {
    eprintln!("missing argument");
}

Alternative implementation:

if let Some(arg) = ::std::env::args().nth(1) {
    match arg.as_str() {
        "f" => fox(),
        "b" => box(),
        _ => eprintln!("invalid argument: {}", arg),
    };
} else {
    eprintln!("missing argument");
}

	
163 	
Print list elements by group of 2
Print all the list elements, two by two, assuming list length is even.
	

for pair in list.chunks(2) {
    println!("({}, {})", pair[0], pair[1]);
}

	
164 	
Open URL in the default browser
Open the URL s in the default browser.
Set boolean b to indicate whether the operation was successful.
	

webbrowser::open(s).expect("failed to open URL");

	
165 	
Last element of list
Assign to the variable x the last element of the list items.
	

let x = items[items.len()-1];

Alternative implementation:

let x = items.last().unwrap();

	
166 	
Concatenate two lists
Create the list ab containing all the elements of the list a, followed by all the elements of the list b.
	

let ab = [a, b].concat();

	
167 	
Trim prefix
Create string t consisting of string s with its prefix p removed (if s starts with p).
	

let t = s.trim_start_matches(p);

Alternative implementation:

let t = if s.starts_with(p) { &s[p.len()..] } else { s };

Alternative implementation:

let t = s.strip_prefix(p).unwrap_or(s);

	
168 	
Trim suffix
Create string t consisting of string s with its suffix w removed (if s ends with w).
	

let t = s.trim_end_matches(w);

Alternative implementation:

let t = s.strip_suffix(w).unwrap_or(s);

	
169 	
String length
Assign to the integer n the number of characters of the string s.
Make sure that multibyte characters are properly handled.
n can be different from the number of bytes of s.
	

let n = s.chars().count();

	
170 	
Get map size
Set n to the number of elements stored in mymap.

This is not always equal to the map capacity.
	

let n = mymap.len();

	
171 	
Add an element at the end of a list
Append element x to the list s.
	

s.push(x);

	
172 	
Insert an entry in a map
Insert value v for key k in map m.
	

m.insert(k, v);

	
173 	
Format a number with grouped thousands
Number will be formatted with a comma separator between every group of thousands.
	

println!("{}", 1000.separated_string());

	
174 	
Make HTTP POST request
Make a HTTP request with method POST to the URL u
	

let client = reqwest::blocking::Client::new();
let mut response = client.post(u).body("abc").send()?;

	
175 	
Bytes to hex string
From array a of n bytes, build the equivalent hex string s of 2n digits.
Each byte (256 possible values) is encoded as two hexadecimal characters (16 possible values per digit).
	

let s = a.encode_hex::<String>();

Alternative implementation:

let mut s = String::with_capacity(2 * n);
for byte in a {
    write!(s, "{:02X}", byte)?;
}

	
176 	
Hex string to byte array
From hex string s of 2n digits, build the equivalent array a of n bytes.
Each pair of hexadecimal characters (16 possible values per digit) is decoded into one byte (256 possible values).
	

let a: Vec<u8> = Vec::from_hex(s).expect("Invalid Hex String");

	
178 	
Check if point is inside rectangle
Set boolean b to true if if the point with coordinates (x,y) is inside the rectangle with coordinates (x1,y1,x2,y2) , or to false otherwise.
Describe if the edges are considered to be inside the rectangle.
	

struct Rect {
    x1: i32,
    x2: i32,
    y1: i32,
    y2: i32,
}

impl Rect {
    fn contains(&self, x: i32, y: i32) -> bool {
        return self.x1 < x && x < self.x2 && self.y1 < y && y < self.y2;
    }
}

	
179 	
Get center of a rectangle
Return the center c of the rectangle with coördinates(x1,y1,x2,y2)
	

struct Rectangle {
    x1: f64,
    y1: f64,
    x2: f64,
    y2: f64,
}

impl Rectangle {
    pub fn center(&self) -> (f64, f64) {
	    ((self.x1 + self.x2) / 2.0, (self.y1 + self.y2) / 2.0)
    }
}

	
180 	
List files in directory
Create list x containing the contents of directory d.

x may contain files and subfolders.
No recursive subfolder listing.
	

let x = std::fs::read_dir(d).unwrap();

Alternative implementation:

let x = std::fs::read_dir(d)?.collect::<Result<Vec<_>, _>>()?;

	
182 	
Quine program
Output the source of the program.
	

fn main() {
    let x = "fn main() {\n    let x = ";
    let y = "print!(\"{}{:?};\n    let y = {:?};\n    {}\", x, x, y, y)\n}\n";
    print!("{}{:?};
    let y = {:?};
    {}", x, x, y, y)
}

Alternative implementation:

fn main(){print!("{},{0:?})}}","fn main(){print!(\"{},{0:?})}}\"")}

	
184 	
Tomorrow
Assign to variable t a string representing the day, month and year of the day after the current date.
	

let t = chrono::Utc::now().date().succ().to_string();

	
185 	
Execute function in 30 seconds
Schedule the execution of f(42) in 30 seconds.
	

sleep(Duration::new(30, 0));
f(42);

	
186 	
Exit program cleanly
Exit a program cleanly indicating no error to OS
	

exit(0);

	
189 	
Filter and transform list
Produce a new list y containing the result of function T applied to all elements e of list x that match the predicate P.
	

let y = x.iter()
	.filter(P)
        .map(T)
	.collect::<Vec<_>>();

	
190 	
Call an external C function
Declare an external C function with the prototype

void foo(double *a, int n);

and call it, passing an array (or a list) of size 10 to a and 10 to n.

Use only standard features of your language.
	

extern "C" {
    /// # Safety
    ///
    /// `a` must point to an array of at least size 10
    fn foo(a: *mut libc::c_double, n: libc::c_int);
}

let mut a = [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0];
let n = 10;
unsafe {
    foo(a.as_mut_ptr(), n);
}

	
191 	
Check if any value in a list is larger than a limit
Given a one-dimensional array a, check if any value is larger than x, and execute the procedure f if that is the case
	

if a.iter().any(|&elem| elem > x) {
    f()
}

	
192 	
Declare a real variable with at least 20 digits
Declare a real variable a with at least 20 digits; if the type does not exist, issue an error at compile time.
	

let a = Decimal::from_str("1234567890.123456789012345").unwrap();

	
195 	
Pass a two-dimensional array
Pass an array a of real numbers to the procedure (resp. function) foo. Output the size of the array, and the sum of all its elements when each element is multiplied with the array indices i and j (assuming they start from one).
	

fn foo(a: Vec<Vec<usize>>) {
    println!(
        "Length of array: {}",
        a.clone()
            .into_iter()
            .flatten()
            .collect::<Vec<usize>>()
            .len()
    );

    let mut sum = 0;
    for (i, j) in izip!(&a[0], &a[1]) {
        sum += i * j
    }

    println!("Sum of all products of indices: {}", sum);
}

	
196 	
Pass a sub-array
Given an integer array a of size n, pass the first, third, fifth and seventh, ... up to the m th element to a routine foo which sets all these elements to 42.
	

fn foo(el: &mut i32) {
    *el = 42;
}
a.iter_mut().take(m).step_by(2).for_each(foo);

	
197 	
Get a list of lines from a file
Retrieve the contents of file at path into a list of strings lines, in which each element is a line of the file.
	

let lines = BufReader::new(File::open(path).unwrap())
	.lines()
	.collect::<Vec<_>>();

	
198 	
Abort program execution with error condition
Abort program execution with error condition x (where x is an integer value)
	

process::exit(x);

	
200 	
Return hypotenuse
Returns the hypotenuse h of the triangle where the sides adjacent to the square angle have lengths x and y.
	

fn hypot(x:f64, y:f64)-> f64 {
    let num = x.powi(2) + y.powi(2);
    num.powf(0.5)
}

	
202 	
Sum of squares
Calculate the sum of squares s of data, an array of floating point values.
	

let s = data.iter().map(|x| x.powi(2)).sum::<f32>();

	
205 	
Get an environment variable
Read an environment variable with the name "FOO" and assign it to the string variable foo. If it does not exist or if the system does not support environment variables, assign a value of "none".
	

let foo;
match env::var("FOO") {
    Ok(val) => foo = val,
    Err(_e) => foo = "none".to_string(),
}

Alternative implementation:

let foo = env::var("FOO").unwrap_or("none".to_string());

Alternative implementation:

let foo = match env::var("FOO") {
    Ok(val) => val,
    Err(_e) => "none".to_string(),
};

Alternative implementation:

if let Ok(tnt_root) = env::var("TNT_ROOT") {
     //
}

	
206 	
Switch statement with strings
Execute different procedures foo, bar, baz and barfl if the string str contains the name of the respective procedure. Do it in a way natural to the language.
	

match str {
    "foo" => foo(),
    "bar" => bar(),
    "baz" => baz(),
    "barfl" => barfl(),
    _ => {}
}

	
207 	
Allocate a list that is automatically deallocated
Allocate a list a containing n elements (n assumed to be too large for a stack) that is automatically deallocated when the program exits the scope it is declared in.
	

let a = vec![0; n];

	
208 	
Formula with arrays
Given the arrays a,b,c,d of equal length and the scalar e, calculate a = e*(a+b*c+cos(d)).
Store the results in a.
	

for i in 0..a.len() {
    a[i] = e * (a[i] + b[i] * c[i] + d[i].cos());
}

	
209 	
Type with automatic deep deallocation
Declare a type t which contains a string s and an integer array n with variable size, and allocate a variable v of type t. Allocate v.s and v.n and set them to the values "Hello, world!" for s and [1,4,9,16,25], respectively. Deallocate v, automatically deallocating v.s and v.n (no memory leaks).
	

struct T {
	s: String,
	n: Vec<usize>,
}

fn main() {
	let v = T {
		s: "Hello, world!".into(),
		n: vec![1,4,9,16,25]
	};
}

	
211 	
Create folder
Create the folder at path on the filesystem
	

fs::create_dir(path)?;

Alternative implementation:

fs::create_dir_all(path)?;

	
212 	
Check if folder exists
Set boolean b to true if path exists on the filesystem and is a directory; false otherwise.
	

let b: bool = Path::new(path).is_dir();

	
213 	
Case-insensitive string compare
Compare four strings in pair-wise variations. The string comparison can be implemented with an equality test or a containment test, must be case-insensitive and must apply Unicode casefolding.
	

for x in strings
    .iter()
    .combinations(2)
    .filter(|x| x[0].to_lowercase() == x[1].to_lowercase())
{
    println!("{:?} == {:?}", x[0], x[1])
}

	
215 	
Pad string on the left
Prepend extra character c at the beginning of string s to make sure its length is at least m.
The length is the number of characters, not the number of bytes.
	

if let Some(columns_short) = m.checked_sub(s.width()) {
    let padding_width = c
        .width()
        .filter(|n| *n > 0)
        .expect("padding character should be visible");
    // Saturate the columns_short
    let padding_needed = columns_short + padding_width - 1 / padding_width;
    let mut t = String::with_capacity(s.len() + padding_needed);
    t.extend((0..padding_needed).map(|_| c)
    t.push_str(&s);
    s = t;
}

	
217 	
Create a Zip archive
Create a zip-file with filename name and add the files listed in list to that zip-file.
	

let path = std::path::Path::new(_name);
let file = std::fs::File::create(&path).unwrap();
let mut zip = zip::ZipWriter::new(file); zip.start_file("readme.txt", FileOptions::default())?;                                                          
zip.write_all(b"Hello, World!\n")?;
zip.finish()?;

Alternative implementation:

fn zip(_name: &str, _list: Vec<&str>) -> zip::result::ZipResult<()>
{
    let path = std::path::Path::new(_name);
    let file = std::fs::File::create(&path).unwrap();
    let mut zip = zip::ZipWriter::new(file);
    for i in _list.iter() {
        zip.start_file(i as &str, FileOptions::default())?;
    }
    zip.finish()?;
    Ok(())
}

	
218 	
List intersection
Create the list c containing all unique elements that are contained in both lists a and b.
c should not contain any duplicates, even if a and b do.
The order of c doesn't matter.
	

let unique_a = a.iter().collect::<HashSet<_>>();
let unique_b = b.iter().collect::<HashSet<_>>();

let c = unique_a.intersection(&unique_b).collect::<Vec<_>>();

Alternative implementation:

let set_a: HashSet<_> = a.into_iter().collect();
let set_b: HashSet<_> = b.into_iter().collect();
let c = set_a.intersection(&set_b);

	
219 	
Replace multiple spaces with single space
Create the string t from the value of string s with each sequence of spaces replaced by a single space.

Explain if only the space characters will be replaced, or the other whitespaces as well: tabs, newlines.
	

let re = Regex::new(r"\s+").unwrap();
let t = re.replace_all(s, " ");

	
220 	
Create a tuple value
Create t consisting of 3 values having different types.

Explain if the elements of t are strongly typed or not.
	

let t = (2.5, "hello", -1);

	
221 	
Remove all non-digits characters
Create string t from string s, keeping only digit characters 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.
	

let t: String = s.chars().filter(|c| c.is_digit(10)).collect();

	
222 	
Find the first index of an element in list
Set i to the first index in list items at which the element x can be found, or -1 if items does not contain x.
	

let opt_i = items.iter().position(|y| *y == x);


let i = match opt_i {
   Some(index) => index as i32,
   None => -1
};

Alternative implementation:

let i = items.iter().position(|y| *y == x).map_or(-1, |n| n as i32);

	
223 	
for else loop
Loop through list items checking a condition. Do something else if no matches are found.

A typical use case is looping through a series of containers looking for one that matches a condition. If found, an item is inserted; otherwise, a new container is created.

These are mostly used as an inner nested loop, and in a location where refactoring inner logic into a separate function reduces clarity.
	

let mut found = false;
for item in items {
    if item == &"baz" {
        println!("found it");
        found = true;
        break;
    }
}
if !found {
    println!("never found it");
}

Alternative implementation:

if let None = items.iter().find(|&&item| item == "rockstar programmer") {
        println!("NotFound");
    };

Alternative implementation:

items
    .iter()
    .find(|&&item| item == "rockstar programmer")
    .or_else(|| {
        println!("NotFound");
        Some(&"rockstar programmer")
    });

	
224 	
Add element to the beginning of the list
Insert the element x at the beginning of the list items.
	

items.push_front(x);

	
225 	
Declare and use an optional argument
Declare an optional integer argument x to procedure f, printing out "Present" and its value if it is present, "Not present" otherwise
	

fn f(x: Option<()>) {
    match x {
        Some(x) => println!("Present {}", x),
        None => println!("Not present"),
    }
}

	
226 	
Delete last element from list
Remove the last element from list items.
	

items.pop();

	
227 	
Copy a list
Create the new list y containing the same elements as the list x.

Subsequent modifications of y must not affect x (except for the contents referenced by the elements themselves if they contain pointers).
	

let y = x.clone();

	
228 	
Copy a file
Copy the file at path src to dst.
	

fs::copy(src, dst).unwrap();

	
231 	
Test if bytes are a valid UTF-8 string
Set b to true if the byte sequence s consists entirely of valid UTF-8 character code points, false otherwise.
	

let b = std::str::from_utf8(&bytes).is_ok();

	
232 	
Read a command line boolean flag
Print "verbose is true" if the flag -v was passed to the program command line, "verbose is false" otherwise.
	

let matches = App::new("My Program")
                .arg(Arg::with_name("verbose")
                    .short("v")
                    .takes_value(false))
                .get_matches();
                   
if matches.is_present("verbose") {
    println!("verbose is true")
} else {
     println!("verbose is false")
}

	
234 	
Encode bytes to base64
Assign to string s the standard base64 encoding of the byte array data, as specified by RFC 4648.
	

let s = base64::encode(data);

	
235 	
Decode base64
Assign to byte array data the bytes represented by the base64 string s, as specified by RFC 4648.
	

let bytes = base64::decode(s).unwrap();

	
237 	
Xor integers
Assign to c the result of (a xor b)
	

let c = a ^ b;

	
238 	
Xor byte arrays
Write in a new byte array c the xor result of byte arrays a and b.

a and b have the same size.
	

let c: Vec<_> = a.iter().zip(b).map(|(x, y)| x ^ y).collect();

	
239 	
Find first regular expression match
Assign to string x the first word of string s consisting of exactly 3 digits, or the empty string if no such match exists.

A word containing more digits, or 3 digits as a substring fragment, must not match.
	

let re = Regex::new(r"\b\d\d\d\b").expect("failed to compile regex");
let x = re.find(s).map(|x| x.as_str()).unwrap_or("");

	
240 	
Sort 2 lists together
Lists a and b have the same length. Apply the same permutation to a and b to have them sorted based on the values of a.
	

let mut tmp: Vec<_> = a.iter().zip(b).collect();
tmp.as_mut_slice().sort_by_key(|(&x, _y)| x);
let (aa, bb): (Vec<i32>, Vec<i32>) = tmp.into_iter().unzip();

	
241 	
Yield priority to other threads
Explicitly decrease the priority of the current process, so that other execution threads have a better chance to execute now. Then resume normal execution and call function busywork.
	

::std::thread::yield_now();
busywork();

	
242 	
Iterate over a set
Call a function f on each element e of a set x.
	

for item in &x {
    f(item);
}

	
243 	
Print list
Print the contents of the list or array a on the standard output.
	

println!("{:?}", a)

	
244 	
Print a map
Print the contents of the map m to the standard output: keys and values.
	

println!("{:?}", m);

	
245 	
Print value of custom type
Print the value of object x having custom type T, for log or debug.
	

println!("{:?}", x);

	
246 	
Count distinct elements
Set c to the number of distinct elements in the list items.
	

let c = items.iter().unique().count();

	
247 	
Filter list in-place
Remove all the elements from list x that don't satisfy the predicate p, without allocating a new list.
Keep all the elements that do satisfy p.

For languages that don't have mutable lists, refer to idiom #57 instead.
	

let mut j = 0;
for i in 0..x.len() {
    if p(x[i]) {
        x[j] = x[i];
        j += 1;
    }
}
x.truncate(j);

Alternative implementation:

x.retain(p);

	
249 	
Declare and assign multiple variables
Define variables a, b and c in a concise way.
Explain if they need to have the same type.
	

let (a, b, c) = (42, "hello", 5.0);

	
251 	
Parse binary digits
Extract integer value i from its binary string representation s (in radix 2)
E.g. "1101" -> 13
	

let i = i32::from_str_radix(s, 2).expect("Not a binary number!");

	
252 	
Conditional assignment
Assign to the variable x the value "a" if calling the function condition returns true, or the value "b" otherwise.
	

x = if condition() { "a" } else { "b" };

	
253 	
Print stack trace
Print the stack frames of the current execution thread of the program.
	

let bt = Backtrace::new();
println!("{:?}", bt);

	
254 	
Replace value in list
Replace all exact occurrences of "foo" with "bar" in the string list x
	

for v in &mut x {
    if *v == "foo" {
        *v = "bar";
    }
}

	
255 	
Print a set
Print the values of the set x to the standard output.
The order of the elements is irrelevant and is not required to remain the same next time.
	

println!("{:?}", x);

	
256 	
Count backwards
Print the numbers 5, 4, ..., 0 (included), one line per number.
	

(0..=5).rev().for_each(|i| println!("{}", i));

	
257 	
Traverse list backwards
Print each index i and value x from the list items, from the last down to the first.
	

for (i, item) in items.iter().enumerate().rev() {
    println!("{} = {}", i, *item);
}

	
258 	
Convert list of strings to list of integers
Convert the string values from list a into a list of integers b.
	

let b: Vec<i64> = a.iter().map(|x| x.parse::<i64>().unwrap()).collect();

Alternative implementation:

let b: Vec<i32> = a.iter().flat_map(|s| s.parse().ok()).collect();

	
259 	
Split on several separators
Build the list parts consisting of substrings of the input string s, separated by any of the characters ',' (comma), '-' (dash), '_' (underscore).
	

let parts: Vec<_> = s.split(&[',', '-', '_'][..]).collect();

	
260 	
Create an empty list of strings
Declare a new list items of string elements, containing zero elements
	

let items: Vec<String> = vec![];

	
261 	
Format time hours-minutes-seconds
Assign to string x the value of fields (hours, minutes, seconds) of date d, in format HH:MM:SS.
	

let format = format_description!("[hour]:[minute]:[second]");
let x = d.format(&format).expect("Failed to format the time");

	
262 	
Count trailing zero bits
Assign to t the number of trailing 0 bits in the binary representation of the integer n.

E.g. for n=112, n is 1110000 in base 2 ⇒ t=4
	

let t = n.trailing_zeros();

	
263 	
Integer logarithm in base 2
Write two functions log2d and log2u, which calculate the binary logarithm of their argument n rounded down and up, respectively. n is assumed to be positive. Print the result of these functions for numbers from 1 to 12.
	

fn log2d(n: f64) -> f64 {
    n.log2().floor()
}

fn log2u(n: f64) -> f64 {
    n.log2().ceil()
}

fn main() {
    for n in 1..=12 {
        let f = f64::from(n);
        println!("{} {} {}", n, log2d(f), log2u(f));
    }
}

	
264 	
Automated passing of array bounds
Pass a two-dimensional integer array a to a procedure foo and print the size of the array in each dimension. Do not pass the bounds manually. Call the procedure with a two-dimensional array.
	

fn foo(v: Vec<Vec<i32>>) {
    println!("{} {}", v.len(), v[0].len());
}

let v = vec![
    vec![1, 2, 3],
    vec![4, 5, 6],
];
foo(v);

Alternative implementation:

fn foo<const X: usize, const Y: usize>(_: [[i32;X];Y]) {
    println!("{} {}", Y, X);
}

let a = [
    [1, 2, 3],
    [4, 5, 6],
];
foo(a);

	
265 	
Calculate parity of an integer
Set the integer variable i to 42 and calculate its parity (i.e. 0 if it contains an even number of bits, 1 if it contains an odd number of bits).
	

let i = 42i32;
let p = i.count_ones() % 2;

	
266 	
Repeated string
Assign to the string s the value of the string v repeated n times, and write it out.

E.g. v="abc", n=5 ⇒ s="abcabcabcabcabc"
	

let s = v.repeat(n);

	
267 	
Pass string to argument that can be of any type
Declare an argument x to a procedure foo that can be of any type. If the type of the argument is a string, print it, otherwise print "Nothing."

Test by passing "Hello, world!" and 42 to the procedure.
	

fn foo(x: &dyn Any) {
    if let Some(s) = x.downcast_ref::<String>() {
        println!("{}", s);
    } else {
        println!("Nothing")
    }
}

fn main() {
    foo(&"Hello, world!".to_owned());
    foo(&42);
}

	
268 	
User-defined operator
Define a type vector containing three floating point numbers x, y, and z. Write a user-defined operator x that calculates the cross product of two vectors a and b.
	

struct Vector {
    x: f32,
    y: f32,
    z: f32,
}

impl Mul for Vector {
    type Output = Self;

    fn mul(self, rhs: Self) -> Self {
        Self {
            x: self.y * rhs.z - self.z * rhs.y,
            y: self.z * rhs.x - self.x * rhs.z,
            z: self.x * rhs.y - self.y * rhs.x,
        }
    }
}

	
269 	
Enum to String
Given the enumerated type t with 3 possible values: bike, car, horse.
Set the enum value e to one of the allowed values of t.
Set the string s to hold the string representation of e (so, not the ordinal value).
Print s.
	

let e = t::bike;
let s = format!("{:?}", e);

println!("{}", s);

	
272 	
Play FizzBuzz
Fizz buzz is a children's counting game, and a trivial programming task used to affirm that a programmer knows the basics of a language: loops, conditions and I/O.

The typical fizz buzz game is to count from 1 to 100, saying each number in turn. When the number is divisible by 3, instead say "Fizz". When the number is divisible by 5, instead say "Buzz". When the number is divisible by both 3 and 5, say "FizzBuzz"
	

for i in 1..101 {
    match i {
        i if (i % 15) == 0 => println!("FizzBuzz"),
        i if (i % 3) == 0 => println!("Fizz"),
        i if (i % 5) == 0 => println!("Buzz"),
        _ => println!("{i}"),
    }
}

	
273 	
Check if folder is empty
Set the boolean b to true if the directory at filepath p is empty (i.e. doesn't contain any other files and directories)
	

let b = fs::read_dir(p).unwrap().count() == 0;

	
274 	
Remove all white space characters
Create the string t from the string s, removing all the spaces, newlines, tabulations, etc.
	

let t: String = s.chars().filter(|c| !c.is_whitespace()).collect();

	
276 	
Insert an element in a set
Insert an element e into the set x.
	

x.insert(e);

	
277 	
Remove an element from a set
Remove the element e from the set x.

Explains what happens if e was already absent from x.
	

x.remove(e);

Alternative implementation:

x.take(e)

	
278 	
Read one line from the standard input
Read one line into the string line.

Explain what happens if EOF is reached.
	

let mut buffer = String::new();
let mut stdin = io::stdin();
stdin.read_line(&mut buffer).unwrap();

	
279 	
Read list of strings from the standard input
Read all the lines (until EOF) into the list of strings lines.
	

let lines = std::io::stdin().lock().lines().map(|x| x.unwrap()).collect::<Vec<String>>();

	
280 	
Filter map
Remove all the elements from the map m that don't satisfy the predicate p.
Keep all the elements that do satisfy p.

Explain if the filtering happens in-place, i.e. if m is reused or if a new map is created.
	

m.retain(|_, &mut v| p(v));

	
281 	
Use a Point as a map key
You have a Point with integer coordinates x and y. Create a map m with key type Point (or equivalent) and value type string. Insert "Hello" at position (42, 5).
	

let mut map: HashMap<Point, String> = HashMap::new();
map.insert(Point { x: 42, y: 5 }, "Hello".into());

	
283 	
Split with a custom string separator
Build the list parts consisting of substrings of input string s, separated by the string sep.
	

let parts = s.split(sep);

Alternative implementation:

let parts = s.split(sep).collect::<Vec<&str>>();

Alternative implementation:

let parts: Vec<&str> = s.split(sep).collect();

	
284 	
Created a zeroed list of integers
Create a new list a (or array, or slice) of size n, where all elements are integers initialized with the value 0.
	

let a = vec![0; n];

	
285 	
Set variable to NaN
Given two floating point variables a and b, set a to a to a quiet NaN and b to a signalling NaN. Use standard features of the language only, without invoking undefined behavior.
	

let a: f64 = f64::NAN;

	
286 	
Iterate over characters of a string
Print a line "Char i is c" for each character c of the string s, where i is the character index of c in s (not the byte index).

Make sure that multi-byte characters are properly handled, and count for a single character.
	

for (i, c) in s.chars().enumerate() {
    println!("Char {} is {}", i, c);
}

	
287 	
Number of bytes of a string
Assign to n the number of bytes in the string s.

This can be different from the number of characters. If n includes more bytes than the characters per se (trailing zero, length field, etc.) then explain it. One byte is 8 bits.
	

let n = s.len();

	
288 	
Check if set contains a value
Set the boolean b to true if the set x contains the element e, false otherwise.
	

let b = x.contains(&e);

	
289 	
Concatenate two strings
Create the string s by concatenating the strings a and b.
	

let s = format!("{}{}", a, b);

Alternative implementation:

let s = a + b;

	
290 	
Sort sublist
Sort the part of the list items from index i (included) to index j (excluded), in place, using the comparator c.

Elements before i and after j must remain unchanged.
	

items[i..j].sort_by(c);

	
291 	
Remove sublist
Delete all the elements from index i (included) to index j (excluded) from the list items.
	

items.drain(i..j)

	
292 	
Write "Ni Hao" in Chinese to standard output in UTF-8
Write "Hello World and 你好" to standard output in UTF-8.
	

println!("Hello World and 你好")

	
293 	
Create a stack
Create a new stack s, push an element x, then pop the element into the variable y.
	

let mut s: Vec<T> = vec![];
s.push(x);
let y = s.pop().unwrap();

	
294 	
Print a comma-separated list of integers
Given an array a containing the three values 1, 12, 42, print out
"1, 12, 42" with a comma and a space after each integer except the last one.
	

let a = [1, 12, 42];
println!("{}", a.map(|i| i.to_string()).join(", "))

	
299 	
Comment out a single line
Write a line of comments.

This line will not be compiled or executed.
	

// This is a comment

	
301 	
Recursive Fibonacci sequence
Compute the Fibonacci sequence of n numbers using recursion.

Note that naive recursion is extremely inefficient for this task.
	

fn fib(n: i32) -> i32{
    if n < 2 {
        1
    }else{
        fib(n - 2) + fib(n - 1)
    }
}

	
302 	
String interpolation
Given the integer x = 8, assign to the string s the value "Our sun has 8 planets", where the number 8 was evaluated from x.
	

let s = format!("Our sun has {} planets", x);

Alternative implementation:

let s = format!("Our sun has {x} planets");

	
304 	
Encode string into UTF-8 bytes
Create the array of bytes data by encoding the string s in UTF-8.
	

let data = s.into_bytes();

	
306 	
Ensure list capacity
Preallocate memory in the list x for a minimum total capacity of 200 elements.

This is not possible in all languages. It is only meant as a performance optimization, should not change the length of x, and should not have any effect on correctness.
	

x.reserve(200);

	
307 	
XOR encrypt/decrypt string
Create a function that XOR encrypts/decrypts a string
	

fn xor(s: Vec<u8>, key: &[u8]) -> Vec<u8> {
    let mut b = key.iter().cycle();
    s.into_iter().map(|x| x ^ b.next().unwrap()).collect()
}

	
gg

Option<T>
To inner type

unwrap () -> T
unwrap_or (T) -> T
unwrap_or_else (() -> T) -> T
unwrap_or_default () -> T where T: Default

    expect (&str) -> T

Converting to another type

map ((T) -> U) -> Option<U>
map_or (U, (T) -> U) -> U

    map_or_else (() -> U, (T) -> U) -> U

To Result

ok_or (E) -> Result<T, E>

    ok_or_else (() -> E) -> Result<T, E>

Conditioning

filter ((&T) -> bool) -> Option<T>
and (Option<U>) -> Option<U>
and_then ((T) -> Option<U>) -> Option<U>
or (Option<T>) -> Option<T>
or_else (() -> Option<T>) -> Option<T>

    xor (Option<T>) -> Option<T>

Option<&T>
Cloning inner

cloned () -> Option<T> where T: Clone

    copied () -> Option<T> where T: Copy

Option<Option<T>>

    flatten () -> Option<T>

Option<Result<T, E>>

    transpose () -> Result<Option<T>, E>

&Option<T>
Checking inner

is_some () -> bool

    is_none () -> bool

To inner reference

as_ref () -> Option<&T>
iter () -> Iterator<&T>

    as_deref () -> Option<&U>
    where T: Deref<Target = U>

&mut Option<T>
To inner mutable reference

as_mut () -> Option<&mut T>
iter_mut () -> Iterator<&mut T>

    as_deref_mut () -> Option<&mut U>
    where T: DerefMut + Deref<Target = U>

Mutation

take () -> Option<T>
replace (T) -> Option<T>
insert (T) -> &mut T
get_or_insert (T) -> &mut T

    get_or_insert_with (() -> T) -> &mut T

Result<T, E>
To inner type

unwrap () -> T where E: Debug
unwrap_err () -> E where T: Debug
unwrap_or (T) -> T
unwrap_or_else ((E) -> T) -> T
unwrap_or_default () -> T where T: Default
expect (&str) -> T
expect_err (&str) -> E
ok () -> Option<T>

    err () -> Option<E>

Mapping

map ((T) -> U) -> Result<U, E>
map_err ((E) -> F) -> Result<T, F>
map_or (U, (T) -> U) -> U

    map_or_else ((E) -> U, (T) -> U) -> U

Conditioning

and (Result<U, E>) -> Result<U, E>
and_then ((T) -> Result<U, E>) -> Result<U, E>
or (Result<T, F>) -> Result<T, F>

    or_else ((E) -> Result<T, F>) -> Result<T, F>

Result<Option<T>, E>
Transposing

    transpose () -> Option<Result<T, E>>

&Result<T, E>
Checking inner

is_ok () -> bool

    is_err () -> bool

To inner reference

as_ref () -> Result<&T, &E>

    iter () -> Iterator<Item = &T>

&mut Result<T, E>
To inner mutable reference

as_mut () -> Result<&mut T, &mut E>

    iter_mut () -> Iterator<Item = &mut T>

Iterator<Item = T>
Mapping and filtering

map        (( T) -> U)         -> Iterator<Item = U>
filter     ((&T) -> bool)      -> Iterator<Item = T>

    filter_map (( T) -> Option<U>) -> Iterator<Item = U>

Collecting and folding

fold (S, (S, T) -> S) -> S
collect () -> B where B: FromIterator<T>

    partition ((&T) -> bool) -> (B, B) where B: Default + Extend<T>

Counting and enumerating

count () -> usize
last () -> Option<T>

    enumerate () -> Iterator<Item = (usize, T)>

Combining with other iterators

zip   (IntoIterator<Item = U>) -> Iterator<Item = (T, U)>

    chain (IntoIterator<Item = T>) -> Iterator<Item = T>

Flattening

flatten () -> Iterator<U> where T: IntoIterator<U>

    flat_map ((T) -> IntoIterator<Item = U>) -> Iterator<Item = U>

Taking and skipping

skip (usize) -> Iterator<Item = T>
take (usize) -> Iterator<Item = T>
skip_while ((&T) -> bool) -> Iterator<Item = T>
take_while ((&T) -> bool) -> Iterator<Item = T>

    step_by (usize) -> Iterator<Item = T>

Misc. iterating

for_each ((T) -> ()) -> ()
inspect ((&T) -> ()) -> Iterator<Item = T>

    scan (S, (&mut S, T) -> Option<U>) -> Iterator<Item = U>

Calculations

sum     () -> S where S: Sum<T>

    product () -> P where P: Product<T>

Maximum and minimum

max () -> Option<T> where T: Ord
min () -> Option<T> where T: Ord
max_by ((&T, &T) -> Ordering) -> Option<T>
min_by ((&T, &T) -> Ordering) -> Option<T>
max_by_key ((&T) -> U) -> Option<T> where U: Ord

    min_by_key ((&T) -> U) -> Option<T> where U: Ord

Comparing with another iterator

eq (IntoIterator<Item = T>) -> bool where T: PartialEq
ne (IntoIterator<Item = T>) -> bool where T: PartialEq
lt (IntoIterator<Item = T>) -> bool where T: PartialOrd
le (IntoIterator<Item = T>) -> bool where T: PartialOrd
gt (IntoIterator<Item = T>) -> bool where T: PartialOrd
ge (IntoIterator<Item = T>) -> bool where T: PartialOrd
cmp (IntoIterator<Item = T>) -> Ordering where T: Ord

    partial_cmp (IntoIterator<Item = T>)
    -> Option<Ordering> where T: PartialOrd

Reversing and cycling

rev   () -> Iterator<Item = T> where Self: DoubleEndedIterator

    cycle () -> Iterator<Item = T> where Self: Clone

Iterator<Item = &T>
Cloning inner

cloned () -> Iterator<T> where T: Clone

    copied () -> Iterator<T> where T: Copy

&mut Iterator<Item = T>
Finding and positioning

find      ((&T) -> bool)      -> Option<T>
find_map  (( T) -> Option<U>) -> Option<U>
position  (( T) -> bool)      -> Option<usize>

    rposition (( T) -> bool)      -> Option<usize>
    where Self: ExactSizeIterator + DoubleEndedIterator

Boolean operations

all ((T) -> bool) -> bool

    any ((T) -> bool) -> bool

Try iterating

try_for_each   ((T) -> R) -> R where R: Try<Ok = ()>

    try_fold (S, (S, T) -> R) -> R where R: Try<Ok = S>

iter
Creating simple iterators

empty () -> Iterator<Item = T>
once (T) -> Iterator<Item = T>
once_with (() -> T) -> Iterator<Item = T>
repeat (T) -> Iterator<Item = T> where T: Clone
repeat_with (() -> T) -> Iterator<Item = T>
from_fn (() -> Option<T>) -> Iterator<Item = T>

    successors (Option<T>, (&T) -> Option<T>) -> Iterator<Item = T>

&[T]
Splitting to iterator

split  ((&T) -> bool) -> Iterator<Item = &[T]>
rsplit ((&T) -> bool) -> Iterator<Item = &[T]>
splitn  (usize, (&T) -> bool) -> Iterator<Item = &[T]>

    rsplitn (usize, (&T) -> bool) -> Iterator<Item = &[T]>

Splitting at position

split_at (usize) -> (&[T], &[T])
split_first () -> Option<(&T, &[T])>

    split_last  () -> Option<(&T, &[T])>

Chunks and windows

chunks        (usize) -> Iterator<Item = &[T]>
chunks_exact  (usize) -> Iterator<Item = &[T]>
rchunks       (usize) -> Iterator<Item = &[T]>
rchunks_exact (usize) -> Iterator<Item = &[T]>

    windows       (usize) -> Iterator<Item = &[T]>

Matching

contains    (&T)   -> bool where T: PartialEq
starts_with (&[T]) -> bool where T: PartialEq

    ends_with   (&[T]) -> bool where T: PartialEq

Binary searching

binary_search (&T)                   -> Result<usize, usize> where T: Ord
binary_search_by ((&T) -> Ordering)  -> Result<usize, usize>

    binary_search_by_key (&B, (&T) -> B) -> Result<usize, usize> where B: Ord

Getting and iterating

first () -> Option<&T>
last  () -> Option<&T>
get (SliceIndex<[T]>

) -> Option<&T>

    iter () -> Iterator<Item = &T>

Length

len () -> usize

    is_empty () -> bool

&mut [T]
Splitting to iterator

split_mut  ((&T) -> bool) -> Iterator<Item = &mut [T]>
rsplit_mut ((&T) -> bool) -> Iterator<Item = &mut [T]>
splitn_mut  (usize, (&T) -> bool) -> Iterator<Item = &mut [T]>

    rsplitn_mut (usize, (&T) -> bool) -> Iterator<Item = &mut [T]>

Splitting at position

split_at_mut (usize) -> (&mut [T], &mut [T])
split_first_mut () -> Option<(&mut T, &mut [T])>

    split_last_mut  () -> Option<(&mut T, &mut [T])>

Chunks

chunks_mut        (usize) -> Iterator<Item = &mut [T]>
chunks_exact_mut  (usize) -> Iterator<Item = &mut [T]>
rchunks_mut       (usize) -> Iterator<Item = &mut [T]>

    rchunks_exact_mut (usize) -> Iterator<Item = &mut [T]>

Sorting

sort () where T: Ord
sort_by ((&T, &T) -> Ordering)
sort_by_key ((&T) -> K) where K: Ord
sort_by_cached_key ((&T) -> K) where K: Ord
sort_unstable () where T: Ord
sort_unstable_by ((&T, &T) -> Ordering)

    sort_unstable_by_key ((&T) -> K) where K: Ord

Rearranging

swap (usize, usize)
reverse ()
rotate_left (usize)

    rotate_right (usize)

Overriding

swap_with_slice  (&mut [T])
copy_from_slice  (&[T]) where T: Copy

    clone_from_slice (&[T]) where T: Clone

Getting and iterating

first_mut () -> Option<&mut T>
last_mut  () -> Option<&mut T>
get_mut (SliceIndex<[T]>

) -> Option<&mut T>

    iter_mut () -> Iterator<Item = &mut T>

&mut Vec<T>
Adding and removing single item

push (T)
pop () -> Option<T>
insert (usize, T)
remove (usize) -> T

    swap_remove (usize) -> T

Extending

append (&mut Vec<T>)
extend (IntoIterator<Item = T>)
extend (IntoIterator<Item = &T>) where T: Copy

    extend_from_slice (&[T]) where T: Clone

Resizing

truncate (usize)
resize (usize, T) where T: Clone

    resize_with (usize, () -> T)

Clearing

clear ()

    retain ((&T) -> bool)

Removing or replacing range into iterator

drain  (RangeBounds<usize>

) -> Iterator<T>

    splice (RangeBounds<usize>
    , IntoIterator<Item = T>) -> Iterator<T>

Deduplicating

dedup () where T: PartialEq
dedup_by ((&mut T, &mut T) -> bool)

    dedup_by_key ((&mut T) -> K) where K: PartialEq

Splitting off

    split_off (usize) -> Vec<T>

Capacity manipulation

reserve (usize)
reserve_exact (usize)

    shrink_to_fit ()

slice
Creating slice from reference

from_ref (&T) -> &[T]

    from_mut (&mut T) -> &mut [T]

&[u8]
ASCII

is_ascii () -> bool
eq_ignore_ascii_case (&[u8]) -> bool
to_ascii_uppercase () -> Vec<u8>

    to_ascii_lowercase () -> Vec<u8>

&mut [u8]
ASCII

make_ascii_uppercase ()

    make_ascii_lowercase ()

str
Bytes

from_utf8     (&[u8])     -> Result<&str, Utf8Error>

    from_utf8_mut (&mut [u8]) -> Result<&mut str, Utf8Error>

&str
Chars

chars () -> Iterator<Item = char>
char_indices () -> Iterator<Item = (usize, char)>

    is_char_boundary (usize) -> bool

Bytes

bytes () -> Iterator<Item = u8>

    as_bytes () -> &[u8]

Splitting to two parts

    split_at (usize) -> (&str, &str)

Splitting to iterator

lines () -> Iterator<Item = &str>
split_whitespace () -> Iterator<Item = &str>
split_ascii_whitespace () -> Iterator<Item = &str>
split  (Pattern

) -> Iterator<Item = &str>
rsplit (Pattern

) -> Iterator<Item = &str>
splitn  (usize, Pattern

) -> Iterator<Item = &str>
rsplitn (usize, Pattern

) -> Iterator<Item = &str>
split_terminator  (Pattern

) -> Iterator<Item = &str>

    rsplit_terminator (Pattern
    ) -> Iterator<Item = &str>

Trimming

trim       () -> &str
trim_start () -> &str
trim_end   () -> &str
trim_matches       (Pattern

) -> &str
trim_start_matches (Pattern

) -> &str

    trim_end_matches   (Pattern
    ) -> &str

Matching and finding

contains    (Pattern

) -> bool
starts_with (Pattern

) -> bool
ends_with   (Pattern

) -> bool
find  (Pattern

) -> Option<usize>
rfind (Pattern

) -> Option<usize>
matches  (Pattern

) -> Iterator<Item = &str>
rmatches (Pattern

) -> Iterator<Item = &str>
match_indices  (Pattern

) -> Iterator<Item = (usize, &str)>

    rmatch_indices (Pattern
    ) -> Iterator<Item = (usize, &str)>

Case

to_uppercase () -> String
to_lowercase () -> String
to_ascii_uppercase () -> String
to_ascii_lowercase () -> String

    eq_ignore_ascii_case (&str) -> bool

Replacing

replace  (Pattern

, &str) -> String

    replacen (Pattern
    , &str, usize) -> String

Length

len () -> usize

    is_empty () -> bool

Misc.

is_ascii () -> bool
repeat (usize) -> String
encode_utf16 () -> Iterator<Item = u16>

    parse () -> Result<F, F::Err> where F: FromStr

&mut str
Splitting to two parts

    split_at_mut (usize) -> (&mut str, &mut str)

Case conversion

make_ascii_uppercase ()

    make_ascii_lowercase ()

&mut String
Inserting and appending string

push_str (&str)

    insert_str (usize, &str)

Adding and removing char

push (char)
pop () -> Option<char>
insert (usize, char)

    remove (usize) -> char

Clearing

clear ()
truncate (usize)

    retain ((char) -> bool)

Capacity manipulation

reserve (usize)
reserve_exact (usize)

    shrink_to_fit ()

Misc.

split_off (usize) -> String
replace_range (RangeBounds<usize>

, &str)

    drain (RangeBounds<usize>
    ) -> Iterator<Item = char>

    Dark
    Single
    Large
    GitHub


Fork me on GitHub

Ferris holding a cheat sheet.
Rust Language Cheat Sheet
Even for the Internet it's ... pretty shocking.

    Contains clickable links to The Book BK, Rust by Example EX, Std Docs STD, Nomicon NOM, Reference REF.
    ➕

Font Ligatures (..=, =>) Night Mode 💡

Language Constructs

    Data Structures
    References & Pointers
    Functions & Behavior
    Control Flow
    Organizing Code
    Type Aliases and Casts
    Macros & Attributes
    Pattern Matching
    Generics & Constraints
    Higher-Ranked Items
    Strings & Chars
    Documentation
    Miscellaneous

Behind the Scenes

    The Abstract Machine
    Language Sugar
    Memory & Lifetimes

Memory Layout

    Basic Types
    Custom Types
    References & Pointers
    Closures
    Standard Library Types

Misc

    Links & Services
    Printing & PDF

Standard Library

    One-Liners
    Thread Safety
    Iterators
    Number Conversions
    String Conversions
    String Output

Tooling

    Project Anatomy
    Cargo
    Cross Compilation
    Tooling Directives

Working with Types

    Types, Traits, Generics
    Foreign Types and Traits
    Type Conversions

Coding Guides

    Idiomatic Rust
    Async-Await 101
    Closures in APIs
    Unsafe, Unsound, Undefined
    Adversarial Code🝖
    API Stability

Hello, Rust!

If you are new to Rust, or if you want to try the things below:
Hello World

fn main() {
    println!("Hello, world!");
}

▶️ Edit & Run
Strengths

Things Rust does measurably really well

    Compiled code about same performance as C / C++, and excellent memory and energy efficiency.
    Can avoid 70% of all safety issues present in C / C++, and most memory issues.
    Strong type system prevents data races, brings 'fearless concurrency' (amongst others).
    Seamless C interop, and dozens of supported platforms (based on LLVM).
    "Most loved language" for 4 5 6 7 years in a row. 🤷‍♀️
    Modern tooling: cargo (builds just work), clippy (550+ code quality lints), rustup (easy toolchain mgmt).

Weaknesses

Points you might run into

    Steep learning curve;1 compiler enforcing (esp. memory) rules that would be "best practices" elsewhere.
    Missing Rust-native libs in some domains, target platforms (esp. embedded), IDE features.1
    Longer compile times than "similar" code in other languages.1
    No formal language specification, can prevent legal use in some domains (aviation, medical, …).
    Careless (use of unsafe in) libraries can secretly break safety guarantees.

1 Compare Rust Survey.
Installation

Download

    Get installer from rustup.rs (highly recommended)🔥

IDEs

    IntelliJ (free) or CLion (paid) with IntelliJ Rust
    Visual Studio Code with rust-analyzer

First Steps

Modular Beginner Resources

    Tour of Rust - Live code and explanations, side by side.
    Rust in Easy English - 60+ concepts, simple English, example-driven.

In addition, have a look at the usual suspects. BK EX STD

    Opinion 💬 — If you have never seen or used any Rust it might be good to visit one of the links above before continuing; the next chapter might feel a bit terse otherwise.

Data Structures

Data types and memory locations defined via keywords.
Example	Explanation
struct S {}	Define a struct BK EX STD REF with named fields.
     struct S { x: T }	Define struct with named field x of type T.
     struct S ​(T);	Define "tupled" struct with numbered field .0 of type T.
     struct S;	Define zero sized NOM unit struct. Occupies no space, optimized away.
enum E {}	Define an enum, BK EX REF c. algebraic data types, tagged unions.
     enum E { A, B​(), C {} }	Define variants of enum; can be unit- A, tuple- B ​() and struct-like C{}.
     enum E { A = 1 }	If variants are only unit-like, allow discriminant values, e.g., for FFI.
union U {}	Unsafe C-like union REF for FFI compatibility. 🝖
static X: T = T();	Global variable BK EX REF with 'static lifetime, single memory location.
const X: T = T();	Defines constant, BK EX REF copied into a temporary when used.
let x: T;	Allocate T bytes on stack1 bound as x. Assignable once, not mutable.
let mut x: T;	Like let, but allow for mutability BK EX and mutable borrow.2
     x = y;	Moves y to x, invalidating y if T is not Copy, STD and copying y otherwise.

1 Bound variables BK EX REF live on stack for synchronous code. In async {} they become part of async's state machine, may reside on heap.
2 Technically mutable and immutable are misnomer. Immutable binding or shared reference may still contain Cell STD, giving interior mutability.
 

Creating and accessing data structures; and some more sigilic types.
Example	Explanation
S { x: y }	Create struct S {} or use'ed enum E::S {} with field x set to y.
S { x }	Same, but use local variable x for field x.
S { ..s }	Fill remaining fields from s, esp. useful with Default.
S { 0: x }	Like S ​(x) below, but set field .0 with struct syntax.
S​ (x)	Create struct S ​(T) or use'ed enum E::S​ () with field .0 set to x.
S	If S is unit struct S; or use'ed enum E::S create value of S.
E::C { x: y }	Create enum variant C. Other methods above also work.
()	Empty tuple, both literal and type, aka unit. STD
(x)	Parenthesized expression.
(x,)	Single-element tuple expression. EX STD REF
(S,)	Single-element tuple type.
[S]	Array type of unspecified length, i.e., slice. EX STD REF Can't live on stack. *
[S; n]	Array type EX STD REF of fixed length n holding elements of type S.
[x; n]	Array instance REF (expression) with n copies of x.
[x, y]	Array instance with given elements x and y.
x[0]	Collection indexing, here w. usize. Implementable with Index, IndexMut.
     x[..]	Same, via range (here full range), also x[a..b], x[a..=b], ... c. below.
a..b	Right-exclusive range STD REF creation, e.g., 1..3 means 1, 2.
..b	Right-exclusive range to STD without starting point.
..=b	Inclusive range to STD without starting point.
a..=b	Inclusive range, STD 1..=3 means 1, 2, 3.
a..	Range from STD without ending point.
..	Full range, STD usually means the whole collection.
s.x	Named field access, REF might try to Deref if x not part of type S.
s.0	Numbered field access, used for tuple types S ​(T).

* For now,RFC pending completion of tracking issue.
References & Pointers

Granting access to un-owned memory. Also see section on Generics & Constraints.
Example	Explanation
&S	Shared reference BK STD NOM REF (type; space for holding any &s).
     &[S]	Special slice reference that contains (address, length).
     &str	Special string slice reference that contains (address, length).
     &mut S	Exclusive reference to allow mutability (also &mut [S], &mut dyn S, …).
     &dyn T	Special trait object BK reference that contains (address, vtable).
&s	Shared borrow BK EX STD (e.g., address, len, vtable, … of this s, like 0x1234).
     &mut s	Exclusive borrow that allows mutability. EX
*const S	Immutable raw pointer type BK STD REF w/o memory safety.
     *mut S	Mutable raw pointer type w/o memory safety.
     &raw const s	Create raw pointer w/o going through reference; c. ptr:addr_of!() STD 🚧 🝖
     &raw mut s	Same, but mutable. 🚧 Raw ptrs. are needed for unaligned, packed fields. 🝖
ref s	Bind by reference, EX makes binding reference type. 🗑️
     let ref r = s;	Equivalent to let r = &s.
     let S { ref mut x } = s;	Mutable ref binding (let x = &mut s.x), shorthand destructuring ↓ version.
*r	Dereference BK STD NOM a reference r to access what it points to.
     *r = s;	If r is a mutable reference, move or copy s to target memory.
     s = *r;	Make s a copy of whatever r references, if that is Copy.
     s = *r;	Won't work 🛑 if *r is not Copy, as that would move and leave empty place.
     s = *my_box;	Special case🔗 for Box that can also move out Box'ed content if it isn't Copy.
'a	A lifetime parameter, BK EX NOM REF duration of a flow in static analysis.
     &'a S	Only accepts an address holding some s; addr. existing 'a or longer.
     &'a mut S	Same, but allow content of address to be changed.
     struct S<'a> {}	Signals this S will contain address with lifetime 'a. Creator of S decides 'a.
     trait T<'a> {}	Signals any S, which impl T for S, might contain address.
     fn f<'a>(t: &'a T)	Signals this function handles some address. Caller decides 'a.
'static	Special lifetime lasting the entire program execution.
Functions & Behavior

Define units of code and their abstractions.
Example	Explanation
trait T {}	Define a trait; BK EX REF common behavior types can adhere to.
trait T : R {}	T is subtrait of supertrait BK EX REF R. Any S must impl R before it can impl T.
impl S {}	Implementation REF of functionality for a type S, e.g., methods.
impl T for S {}	Implement trait T for type S; specifies how exactly S acts like T.
impl !T for S {}	Disable an automatically derived auto trait. NOM REF 🚧 🝖
fn f() {}	Definition of a function; BK EX REF or associated function if inside impl.
     fn f() -> S {}	Same, returning a value of type S.
     fn f(&self) {}	Define a method, BK EX REF e.g., within an impl S {}.
struct S ​(T);	More arcanely, also↑ defines fn S(x: T) -> S constructor function. RFC 🝖
const fn f() {}	Constant fn usable at compile time, e.g., const X: u32 = f(Y). '18
async fn f() {}	Async REF '18 function transformation, ↓ makes f return an impl Future. STD
     async fn f() -> S {}	Same, but make f return an impl Future<Output=S>.
     async { x }	Used within a function, make { x } an impl Future<Output=X>.
fn() -> S	Function pointers, BK STD REF memory holding address of a callable.
Fn() -> S	Callable Trait BK STD (also FnMut, FnOnce), implemented by closures, fn's …
|| {} 	A closure BK EX REF that borrows its captures, ↓ REF (e.g., a local variable).
     |x| {}	Closure accepting one argument named x, body is block expression.
     |x| x + x	Same, without block expression; may only consist of single expression.
     move |x| x + y 	Closure taking ownership of its captures; i.e., y transferred to closure.
     return || true 	Closures sometimes look like logical ORs (here: return a closure).
unsafe	If you enjoy debugging segfaults Friday night; unsafe code. ↓ BK EX NOM REF
     unsafe fn f() {}	Means "calling can cause UB, ↓ YOU must check requirements".
     unsafe trait T {}	Means "careless impl. of T can cause UB; implementor must check".
     unsafe { f(); }	Guarantees to compiler "I have checked requirements, trust me".
     unsafe impl T for S {}	Guarantees S is well-behaved w.r.t T; people may use T on S safely.
Control Flow

Control execution within a function.
Example	Explanation
while x {}	Loop, REF run while expression x is true.
loop {}	Loop indefinitely REF until break. Can yield value with break x.
for x in iter {}	Syntactic sugar to loop over iterators. BK STD REF
if x {} else {}	Conditional branch REF if expression is true.
'label: loop {}	Loop label, EX REF useful for flow control in nested loops.
break	Break expression REF to exit a loop.
     break x	Same, but make x value of the loop expression (only in actual loop).
     break 'label	Exit not only this loop, but the enclosing one marked with 'label.
     break 'label x	Same, but make x the value of the enclosing loop marked with 'label.
continue 	Continue expression REF to the next loop iteration of this loop.
continue 'label	Same but instead of this loop, enclosing loop marked with 'label.
x?	If x is Err or None, return and propagate. BK EX STD REF
x.await	Only works inside async. Yield flow until Future STD or Stream x ready. REF '18
return x	Early return REF from function. More idiomatic is to end with expression.
     { return }	Inside normal {}-blocks return exits surrounding function.
     || { return }	Within closures return exits that closure only, i.e., closure is s. function.
     async { return }	Inside async a return only REF 🛑 exits that {} block, i.e., async {} is s.f.!
f()	Invoke callable f (e.g., a function, closure, function pointer, Fn, …).
x.f()	Call member function, requires f takes self, &self, … as first argument.
     X::f(x)	Same as x.f(). Unless impl Copy for X {}, f can only be called once.
     X::f(&x)	Same as x.f().
     X::f(&mut x)	Same as x.f().
     S::f(&x)	Same as x.f() if X derefs to S, i.e., x.f() finds methods of S.
     T::f(&x)	Same as x.f() if X impl T, i.e., x.f() finds methods of T if in scope.
X::f()	Call associated function, e.g., X::new().
     <X as T>::f()	Call trait method T::f() implemented for X.
Organizing Code

Segment projects into smaller units and minimize dependencies.
Example	Explanation
mod m {}	Define a module, BK EX REF get definition from inside {}. ↓
mod m;	Define a module, get definition from m.rs or m/mod.rs. ↓
a::b	Namespace path EX REF to element b within a (mod, enum, …).
     ::b	Search b in crate root '15 REF or external prelude '18 REF; global path. REF 🗑️
     crate::b	Search b in crate root. '18
     self::b	Search b in current module.
     super::b	Search b in parent module.
use a::b;	Use EX REF b directly in this scope without requiring a anymore.
use a::{b, c};	Same, but bring b and c into scope.
use a::b as x;	Bring b into scope but name x, like use std::error::Error as E.
use a::b as _;	Bring b anonymously into scope, useful for traits with conflicting names.
use a::*;	Bring everything from a in, only recommended if a is some prelude. STD 🔗
pub use a::b;	Bring a::b into scope and reexport from here.
pub T	"Public if parent path is public" visibility BK REF for T.
     pub(crate) T	Visible at most1 in current crate.
     pub(super) T	Visible at most1 in parent.
     pub(self) T	Visible at most1 in current module (default, same as no pub).
     pub(in a::b) T	Visible at most1 in ancestor a::b.
extern crate a;	Declare dependency on external crate; BK REF 🗑️ just use a::b in '18.
extern "C" {}	Declare external dependencies and ABI (e.g., "C") from FFI. BK EX NOM REF
extern "C" fn f() {}	Define function to be exported with ABI (e.g., "C") to FFI.

1 Items in child modules always have access to any item, regardless if pub or not.
Type Aliases and Casts

Short-hand names of types, and methods to convert one type to another.
Example	Explanation
type T = S;	Create a type alias, BK REF i.e., another name for S.
Self	Type alias for implementing type, REF e.g. fn new() -> Self.
self	Method subject in fn f(self) {}, same as fn f(self: Self) {}.
     &self	Same, but refers to self as borrowed, same as f(self: &Self)
     &mut self	Same, but mutably borrowed, same as f(self: &mut Self)
     self: Box<Self>	Arbitrary self type, add methods to smart pointers (my_box.f_of_self()).
S as T	Disambiguate BK REF type S as trait T, e.g., <S as T>::f().
S as R	In use of symbol, import S as R, e.g., use a::S as R.
x as u32	Primitive cast, EX REF may truncate and be a bit surprising. 1 NOM

1 See Type Conversions below for all the ways to convert between types.
Macros & Attributes

Code generation constructs expanded before the actual compilation happens.
Example	Explanation
m!()	Macro BK STD REF invocation, also m!{}, m![] (depending on macro).
#[attr]	Outer attribute, EX REF annotating the following item.
#![attr]	Inner attribute, annotating the upper, surrounding item.
 
Inside Macros	Explanation
$x:ty	Macro capture, the :... fragment REF declares what is allowed for $x. 1
$x	Macro substitution, e.g., use the captured $x:ty from above.
$(x),*	Macro repetition REF zero or more times in macros by example.
     $(x),?	Same, but zero or one time.
     $(x),+	Same, but one or more times.
     $(x)<<+	In fact separators other than , are also accepted. Here: <<.

1 See Tooling Directives below for all captures.
Pattern Matching

Constructs found in match or let expressions, or function parameters.
Example	Explanation
match m {}	Initiate pattern matching, BK EX REF then use match arms, c. next table.
let S(x) = get();	Notably, let also destructures EX similar to the table below.
     let S { x } = s;	Only x will be bound to value s.x.
     let (_, b, _) = abc;	Only b will be bound to value abc.1.
     let (a, ..) = abc;	Ignoring 'the rest' also works.
     let (.., a, b) = (1, 2);	Specific bindings take precedence over 'the rest', here a is 1, b is 2.
     let s @ S { x } = get();	Bind s to S while x is bound to s.x, pattern binding, BK EX REF c. below 🝖
     let w @ t @ f = get();	Stores 3 copies of get() result in each w, t, f. 🝖
     let Some(x) = get();	Won't work 🛑 if pattern can be refuted, REF use if let instead.
if let Some(x) = get() {}	Branch if pattern can be assigned (e.g., enum variant), syntactic sugar. *
while let Some(x) = get() {}	Equiv.; here keep calling get(), run {} as long as pattern can be assigned.
fn f(S { x }: S)	Function parameters also work like let, here x bound to s.x of f(s). 🝖

* Desugars to match get() { Some(x) => {}, _ => () }.
 

Pattern matching arms in match expressions. Left side of these arms can also be found in let expressions.
Within Match Arm	Explanation
E::A => {}	Match enum variant A, c. pattern matching. BK EX REF
E::B ( .. ) => {}	Match enum tuple variant B, ignoring any index.
E::C { .. } => {}	Match enum struct variant C, ignoring any field.
S { x: 0, y: 1 } => {}	Match struct with specific values (only accepts s with s.x of 0 and s.y of 1).
S { x: a, y: b } => {}	Match struct with any(!) values and bind s.x to a and s.y to b.
     S { x, y } => {}	Same, but shorthand with s.x and s.y bound as x and y respectively.
S { .. } => {}	Match struct with any values.
D => {}	Match enum variant E::D if D in use.
D => {}	Match anything, bind D; possibly false friend 🛑 of E::D if D not in use.
_ => {}	Proper wildcard that matches anything / "all the rest".
0 | 1 => {}	Pattern alternatives, or-patterns. RFC
     E::A | E::Z => {}	Same, but on enum variants.
     E::C {x} | E::D {x} => {}	Same, but bind x if all variants have it.
     Some(A | B) => {}	Same, can also match alternatives deeply nested.
(a, 0) => {}	Match tuple with any value for a and 0 for second.
[a, 0] => {}	Slice pattern, REF 🔗 match array with any value for a and 0 for second.
     [1, ..] => {}	Match array starting with 1, any value for rest; subslice pattern. REF RFC
     [1, .., 5] => {}	Match array starting with 1, ending with 5.
     [1, x @ .., 5] => {}	Same, but also bind x to slice representing middle (c. pattern binding).
     [a, x @ .., b] => {}	Same, but match any first, last, bound as a, b respectively.
1 .. 3 => {}	Range pattern, BK REF here matches 1 and 2; partially unstable. 🚧
     1 ..= 3 => {}	Inclusive range pattern, matches 1, 2 and 3.
     1 .. => {}	Open range pattern, matches 1 and any larger number.
x @ 1..=5 => {}	Bind matched to x; pattern binding, BK EX REF here x would be 1, 2, … or 5.
     Err(x @ Error {..}) => {}	Also works nested, here x binds to Error, esp. useful with if below.
S { x } if x > 10 => {}	Pattern match guards, BK EX REF condition must be true as well to match.
Generics & Constraints

Generics combine with type constructors, traits and functions to give your users more flexibility.
Example	Explanation
S<T>	A generic BK EX type with a type parameter (T is placeholder name here).
S<T: R>	Type short hand trait bound BK EX specification (R must be actual trait).
     T: R, P: S	Independent trait bounds (here one for T and one for P).
     T: R, S	Compile error, 🛑 you probably want compound bound R + S below.
     T: R + S	Compound trait bound, BK EX T must fulfill R and S.
     T: R + 'a	Same, but w. lifetime. T must fulfill R, if T has lifetimes, must outlive 'a.
     T: ?Sized	Opt out of a pre-defined trait bound, here Sized. ?
     T: 'a	Type lifetime bound; EX if T has references, they must outlive 'a.
     T: 'static	Same; does esp. not mean value t will 🛑 live 'static, only that it could.
     'b: 'a	Lifetime 'b must live at least as long as (i.e., outlive) 'a bound.
S<const N: usize>	Generic const bound; REF user of type S can provide constant value N.
     S<10>	Where used, const bounds can be provided as primitive values.
     S<{5+5}>	Expressions must be put in curly brackets.
S<T> where T: R	Almost same as S<T: R> but more pleasant to read for longer bounds.
     S<T> where u8: R<T>	Also allows you to make conditional statements involving other types.
S<T = R>	Default parameters; BK bit easier to use, but still flexible.
     S<const N: u8 = 0>	Default parameter for constants; e.g., in f(x: S) {} param N is 0.
     S<T = u8>	Default parameter for types, e.g., in f(x: S) {} param T is u8.
S<'_>	Inferred anonymous lifetime; asks compiler to 'figure it out' if obvious.
S<_>	Inferred anonymous type, e.g., as let x: Vec<_> = iter.collect()
S::<T>	Turbofish STD call site type disambiguation, e.g. f::<u32>().
trait T<X> {}	A trait generic over X. Can have multiple impl T for S (one per X).
trait T { type X; }	Defines associated type BK REF RFC X. Only one impl T for S possible.
     type X = R;	Set associated type within impl T for S { type X = R; }.
impl<T> S<T> {}	Implement functionality for any T in S<T>, here T type parameter.
impl S<T> {}	Implement functionality for exactly S<T>, here T specific type (e.g., S<u32>).
fn f() -> impl T	Existential types, BK returns an unknown-to-caller S that impl T.
fn f(x: &impl T)	Trait bound,"impl traits", BK somewhat similar to fn f<S:T>(x: &S).
fn f(x: &dyn T)	Marker for dynamic dispatch, BK REF f will not be monomorphized.
fn f() where Self: R;	In trait T {}, make f accessible only on types known to also impl R.
     fn f() where Self: Sized;	Using Sized can opt f out of dyn T trait object vtable, enabling trait obj.
     fn f() where Self: R {}	Other R useful w. dflt. methods (non dflt. would need be impl'ed anyway).
Higher-Ranked Items 🝖

Actual types and traits, abstract over something, usually lifetimes.
Example	Explanation
for<'a>	Marker for higher-ranked bounds. NOM REF 🝖
     trait T: for<'a> R<'a> {}	Any S that impl T would also have to fulfill R for any lifetime.
fn(&'a u8)	Function pointer type holding fn callable with specific lifetime 'a.
for<'a> fn(&'a u8)	Higher-ranked type1 🔗 holding fn callable with any lt.; subtype↓ of above.
     fn(&'_ u8)	Same; automatically expanded to type for<'a> fn(&'a u8).
     fn(&u8)	Same; automatically expanded to type for<'a> fn(&'a u8).
dyn for<'a> Fn(&'a u8)	Higher-ranked (trait-object) type, works like fn above.
     dyn Fn(&'_ u8)	Same; automatically expanded to type dyn for<'a> Fn(&'a u8).
     dyn Fn(&u8)	Same; automatically expanded to type dyn for<'a> Fn(&'a u8).

1 Yes, the for<> is part of the type, which is why you write impl T for for<'a> fn(&'a u8) below.
 
Implementing Traits	Explanation
impl<'a> T for fn(&'a u8) {}	For fn. pointer, where call accepts specific lt. 'a, impl trait T.
impl T for for<'a> fn(&'a u8) {}	For fn. pointer, where call accepts any lt., impl trait T.
     impl T for fn(&u8) {}	Same, short version.
Strings & Chars

Rust has several ways to create textual values.
Example	Explanation
"..."	String literal, REF, 1 UTF-8, will interpret \n as line break 0xA, …
r"..."	Raw string literal. REF, 1 UTF-8, won't interpret \n, …
r#"..."#	Raw string literal, UTF-8, but can also contain ". Number of # can vary.
b"..."	Byte string literal; REF, 1 constructs ASCII [u8], not a string.
br"...", br#"..."#	Raw byte string literal, ASCII [u8], combination of the above.
'🦀'	Character literal, REF fixed 4 byte unicode 'char'. STD
b'x'	ASCII byte literal. REF

1 Supports multiple lines out of the box. Just keep in mind Debug↓ (e.g., dbg!(x) and println!("{x:?}")) might render them as \n, while Display↓ (e.g., println!("{x}")) renders them proper.
Documentation

Debuggers hate him. Avoid bugs with this one weird trick.
Example	Explanation
///	Outer line doc comment,1 BK EX REF use these on types, traits, functions, …
//!	Inner line doc comment, mostly used at start of file to document module.
//	Line comment, use these to document code flow or internals.
/*...*/	Block comment. 2 🗑️
/**...*/	Outer block doc comment. 2 🗑️
/*!...*/	Inner block doc comment. 2 🗑️

1 Tooling Directives outline what you can do inside doc comments.

2 Generally discouraged due to bad UX. If possible use equivalent line comment instead with IDE support.
Miscellaneous

These sigils did not fit any other category but are good to know nonetheless.
Example	Explanation
!	Always empty never type. 🚧 BK EX STD REF
_	Unnamed wildcard REF variable binding, e.g., |x, _| {}.
     let _ = x;	Unnamed assignment is no-op, does not 🛑 move out x or preserve scope!
_x	Variable binding explicitly marked as unused.
1_234_567	Numeric separator for visual clarity.
1_u8	Type specifier for numeric literals EX REF (also i8, u16, …).
0xBEEF, 0o777, 0b1001	Hexadecimal (0x), octal (0o) and binary (0b) integer literals.
r#foo	A raw identifier BK EX for edition compatibility. 🝖
x;	Statement REF terminator, c. expressions EX REF
Common Operators

Rust supports most operators you would expect (+, *, %, =, ==, …), including overloading. STD Since they behave no differently in Rust we do not list them here.
Behind the Scenes

Arcane knowledge that may do terrible things to your mind, highly recommended.
The Abstract Machine

Like C and C++, Rust is based on an abstract machine.
Overview
Rust
→
CPU

🛑 Misleading.
Rust
→
Abstract Machine
→
CPU

Correct.
 

With rare exceptions you are never 'allowed to reason' about the actual CPU. You write code for an abstracted CPU. Rust then (sort of) understands what you want, and translates that into actual RISC-V / x86 / ... machine code.
 

This abstract machine

    is not a runtime, and does not have any runtime overhead, but is a computing model abstraction,
    contains concepts such as memory regions (stack, ...), execution semantics, ...
    knows and sees things your CPU might not care about,
    forms a contract between programmer and machine,
    and exploits all of the above for optimizations.

Misconceptions

Things people may incorrectly assume they should get away with if Rust targeted CPU directly, and more correct counterparts:
 
Without AM	With AM
0xffff_ffff would make a valid char. 🛑	Memory more than just bits.
0xff and 0xff are same pointer. 🛑	Pointers can come from different domains.
Any r/w pointer on 0xff always fine. 🛑	Read and write reference may not exist same time.
Null reference is just 0x0 in some register. 🛑	Holding 0x0 in reference summons Cthulhu.
Language Sugar

If something works that "shouldn't work now that you think about it", it might be due to one of these.
Name	Description
Coercions NOM	Weakens types to match signature, e.g., &mut T to &T; c. type conversions. ↓
Deref NOM 🔗	Derefs x: T until *x, **x, … compatible with some target S.
Prelude STD	Automatic import of basic items, e.g., Option, drop, ...
Reborrow	Since x: &mut T can't be copied; moves new &mut *x instead.
Lifetime Elision BK NOM REF	Automatically annotates f(x: &T) to f<'a>(x: &'a T).
Method Resolution REF	Derefs or borrow x until x.f() works.
Match Ergonomics RFC	Repeatedly dereferences scrutinee and adds ref and ref mut to bindings.
Rvalue Static Promotion RFC	Makes references to constants 'static, e.g., &42, &None, &mut [].
Dual Definitions RFC	Defining one thing (e.g., struct S(u8)) implicitly def. another (e.g., fn S).
 

    Opinion 💬 — The features above will make your life easier, but might hinder your understanding. If any (type-related) operation ever feels inconsistent it might be worth revisiting this list.

Memory & Lifetimes

An illustrated guide to moves, references and lifetimes.
Types & Moves
 
Application Memory
S(1)
t
Variables
S(1)
a t
Moves
M { ... } ⛔
c
Type Safety
S(1)▼ S(2)▼ S(3)
t
Scope & Drop
Call Stack
S(1)
a x
Function Boundaries
S(1)
a x x
Nested Functions
S(1) M { }
a x m
Repurposing Memory
References & Pointers
 
▼
S(1) 0x3
a r
References as Pointers
 
▼
S(2) 0x3 S(1)
a r d
Access to Non-Owned Memory
 
▼
0x3 M { x } ⛔ ⛔
a r d
References Guard Referents
 
▼
0x3
p
Raw Pointers
Lifetime Basics
"Lifetime" of Things
 
▼
S(2) 0xa
c r
Meaning of r: &'c S
 
▼
S(0) S(3) S(2) 0x6 ⛔
a b c r
Typelikeness of Lifetimes
 
▼
  0x6 S(4) ⛔
b
Borrowed State
Lifetimes in Functions
S(1) S(2) ? 0x6 0xa
b c r x y
Function Parameters
S(1) S(2) ?
a b c r
Problem of 'Borrowed' Propagation
 
▼
S(1) S(2) y + _
a b c r
Lifetimes Propagate Borrowed State
S(2)
a c
Unlocking
Advanced 🝖
 
▼
 
▼
 
S(1) 0x2 0x6 0x2
a ra rb rval
References to References
S(1)▼
_
Drop and _

↕️ Examples expand by clicking.
 
Memory Layout

Byte representations of common types.
Basic Types

Essential types built into the core of the language.
Numeric Types REF
u8, i8
u16, i16
u32, i32
u64, i64
u128, i128
f32
f64
usize, isize
Same as ptr on platform.

 
Unsigned Types
Type	Max Value
u8	255
u16	65_535
u32	4_294_967_295
u64	18_446_744_073_709_551_615
u128	340_282_366_920_938_463_463_374_607_431_768_211_455
usize	Depending on platform pointer size, same as u16, u32, or u64.
Signed Types
Type	Max Value
i8	127
i16	32_767
i32	2_147_483_647
i64	9_223_372_036_854_775_807
i128	170_141_183_460_469_231_731_687_303_715_884_105_727
isize	Depending on platform pointer size, same as i16, i32, or i64.
 
Type	Min Value
i8	-128
i16	-32_768
i32	-2_147_483_648
i64	-9_223_372_036_854_775_808
i128	-170_141_183_460_469_231_731_687_303_715_884_105_728
isize	Depending on platform pointer size, same as i16, i32, or i64.
Float Types🝖

Sample bit representation* for a f32:
S E E E E E E E E F F F F F F F F F F F F F F F F F F F F F F F
 

Explanation:
f32	S (1)	E (8)	F (23)	Value
Normalized number	±	1 to 254	any	±(1.F)2 * 2E-127
Denormalized number	±	0	non-zero	±(0.F)2 * 2-126
Zero	±	0	0	±0
Infinity	±	255	0	±∞
NaN	±	255	non-zero	NaN
 

Similarly, for f64 types this would look like:
f64	S (1)	E (11)	F (52)	Value
Normalized number	±	1 to 2046	any	±(1.F)2 * 2E-1023
Denormalized number	±	0	non-zero	±(0.F)2 * 2-1022
Zero	±	0	0	±0
Infinity	±	2047	0	±∞
NaN	±	2047	non-zero	NaN
* Float types follow IEEE 754-2008 and depend on platform endianness.
Casting Pitfalls 🛑
Cast1	Gives	Note
3.9_f32 as u8	3	Truncates, consider x.round() first.
314_f32 as u8	255	Takes closest available number.
f32::INFINITY as u8	255	Same, treats INFINITY as really large number.
f32::NAN as u8	0	-
_314 as u8	58	Truncates excess bits.
_200 as i8	56	-
_257 as i8	-1	-
Arithmetical Pitfalls 🛑
Operation1	Gives	Note
200_u8 / 0_u8	Compile error.	-
200_u8 / _0 d, r	Panic.	Regular math may panic; here: division by zero.
200_u8 + 200_u8	Compile error.	-
200_u8 + _200 d	Panic.	Consider checked_, wrapping_, ... instead. STD
200_u8 + _200 r	144	In release mode this will overflow.
1_u8 / 2_u8	0	Other integer division truncates.
0.8_f32 + 0.1_f32	0.90000004	-
1.0_f32 / 0.0_f32	f32::INFINITY	-
0.0_f32 / 0.0_f32	f32::NAN	-
x < f32::NAN	false	NAN comparisons always return false.
x > f32::NAN	false	-
f32::NAN == f32::NAN	false	-

1 Expression _100 means anything that might contain the value 100, e.g., 100_i32, but is opaque to compiler.
d Debug build.
r Release build.
 
Textual Types REF
char
Any Unicode scalar.
str
... U T F - 8 ... unspecified times
Rarely seen alone, but as &str instead.
 
Basics
Type	Description
char	Always 4 bytes and only holds a single Unicode scalar value 🔗.
str	An u8-array of unknown length guaranteed to hold UTF-8 encoded code points.
Usage
Chars	Description
let c = 'a';	Often a char (unicode scalar) can coincide with your intuition of character.
let c = '❤';	It can also hold many Unicode symbols.
let c = '❤️';	But not always. Given emoji is two char (see Encoding) and can't 🛑 be held by c.1
c = 0xffff_ffff;	Also, chars are not allowed 🛑 to hold arbitrary bit patterns.
1 Fun fact, due to the Zero-width joiner (⨝) what the user perceives as a character can get even more unpredictable: 👨‍👩‍👧 is in fact 5 chars 👨⨝👩⨝👧, and rendering engines are free to either show them fused as one, or separately as three, depending on their abilities.
 
Strings	Description
let s = "a";	A str is usually never held directly, but as &str, like s here.
let s = "❤❤️";	It can hold arbitrary text, has variable length per c., and is hard to index.
Encoding🝖

let s = "I ❤ Rust";
let t = "I ❤️ Rust";
Variant	Memory Representation2
s.as_bytes()	49 20 e2 9d a4 20 52 75 73 74 3
s.chars()1	49 00 00 00 20 00 00 00 64 27 00 00 20 00 00 00 52 00 00 00 75 00 00 00 73 00 …
t.as_bytes()	49 20 e2 9d a4 ef b8 8f 20 52 75 73 74 4
t.chars()1	49 00 00 00 20 00 00 00 64 27 00 00 0f fe 01 00 20 00 00 00 52 00 00 00 75 00 …
 
1 Result then collected into array and transmuted to bytes.
2 Values given in hex, on x86.
3 Notice how ❤, having Unicode Code Point (U+2764), is represented as 64 27 00 00 inside the char, but got UTF-8 encoded to e2 9d a4 in the str.
4 Also observe how the emoji Red Heart ❤️, is a combination of ❤ and the U+FE0F Variation Selector, thus t has a higher char count than s.
 

    💬 For what seem to be browser bugs Safari and Edge render the hearts in Footnote 3 and 4 wrong, despite being able to differentiate them correctly in s and t above.

 
Custom Types

Basic types definable by users. Actual layout REF is subject to representation; REF padding can be present.
T
T
Sized ↓
T: ?Sized
T
Maybe DST ↓
[T; n]
T T T ... n times
Fixed array of n elements.
[T]
... T T T ... unspecified times
Slice type of unknown-many elements. Neither
Sized (nor carries len information), and most
often lives behind reference as &[T]. ↓
struct S;
Zero-Sized ↓
(A, B, C)
A B C
or maybe
B A C
Unless a representation is forced
(e.g., via #[repr(C)]), type layout
unspecified.
struct S { b: B, c: C }
B C
or maybe
C ↦ B
Compiler may also add padding.

    Also note, two types A(X, Y) and B(X, Y) with exactly the same fields can still have differing layout; never transmute() STD without representation guarantees.

 

These sum types hold a value of one of their sub types:
enum E { A, B, C }
Tag A
exclusive or
Tag B
exclusive or
Tag C
Safely holds A or B or C, also
called 'tagged union', though
compiler may omit tag.
union { ... }
A
unsafe or
B
unsafe or
C
Can unsafely reinterpret
memory. Result might
be undefined.
References & Pointers

References give safe access to 3rd party memory, raw pointers unsafe access. The corresponding mut types have an identical data layout to their immutable counterparts.
&'a T
ptr2/4/8 meta2/4/8
|
T
Must target some valid t of T,
and any such target must exist for
at least 'a.
*const T
ptr2/4/8 meta2/4/8
No guarantees.

Pointer Meta

Many reference and pointer types can carry an extra field, pointer metadata. STD It can be the element- or byte-length of the target, or a pointer to a vtable. Pointers with meta are called fat, otherwise thin.
&'a T
ptr2/4/8
|
T
No meta for
sized target.
(pointer is thin).
&'a T
ptr2/4/8 len2/4/8
|
T
If T is a DST struct such as
S { x: [u8] } meta field len is
length of dyn. sized content.
&'a [T]
ptr2/4/8 len2/4/8
|
... T T ...
Regular slice reference (i.e., the
reference type of a slice type [T]) ↑
often seen as &[T] if 'a elided.
&'a str
ptr2/4/8 len2/4/8
|
... U T F - 8 ...
String slice reference (i.e., the
reference type of string type str),
with meta len being byte length.

&'a dyn Trait
ptr2/4/8 ptr2/4/8
|
T
|
*Drop::drop(&mut T)
size
align
*Trait::f(&T, ...)
*Trait::g(&T, ...)
Meta points to vtable, where *Drop::drop(), *Trait::f(), ... are pointers to their respective impl for T.
Closures

Ad-hoc functions with an automatically managed data block capturing REF environment where closure was defined. For example:
move |x| x + y.f() + z
Y Z
Anonymous closure type C1
|x| x + y.f() + z
ptr2/4/8 ptr2/4/8
Anonymous closure type C2
|
Y
|
Z

    Also produces anonymous fn such as fc1(C1, X) or fc2(&C2, X). Details depend which FnOnce, FnMut, Fn ... is supported, based on properties of captured types.

Standard Library Types

Rust's standard library combines the above primitive types into useful types with special semantics, e.g.:
UnsafeCell<T>
T
Magic type allowing
aliased mutability.
Cell<T>
T
Allows T's
to move in
and out.
RefCell<T>
borrowed T
Also support dynamic
borrowing of T. Like Cell this
is Send, but not Sync.
AtomicUsize
usize2/4/8
Other atomic similarly.
Result<T, E>
Tag E
or
Tag T
Option<T>
Tag
or
Tag T
Tag may be omitted for
certain T, e.g., NonNull.
 
Order-Preserving Collections
Box<T>
ptr2/4/8 meta2/4/8
|
T
For some T stack proxy may carry
meta↑ (e.g., Box<[T]>).
Vec<T>
ptr2/4/8 capacity2/4/8 len2/4/8
|
T T ... len
← capacity →
Regular growable array vector of single type.
LinkedList<T> 🝖
head2/4/8 tail2/4/8 len2/4/8
|
|
next2/4/8 prev2/4/8 T
Elements head and tail both null or point to nodes on
the heap. Each node can point to its prev and next node.
Eats your cache (just look at the thing!); don't use unless
you evidently must. 🛑
VecDeque<T>
tail2/4/8 head2/4/8 ptr2/4/8 capacity2/4/8
|
T⁣T ... empty ... T⁣H
← capacity →
Index tail and head select in array-as-ringbuffer. This means content
may be non-contiguous and empty in the middle, as exemplified above.
 
Other Collections
HashMap<K, V>
bmask2/4/8 ctrl2/4/8 left2/4/8 len2/4/8
|
K:V K:V ... K:V ... K:V
Oversimplified!
Stores keys and values on heap according to hash value, SwissTable
implementation via hashbrown. HashSet identical to HashMap,
just type V disappears. Heap view grossly oversimplified. 🛑
BinaryHeap<T>
ptr2/4/8 capacity2/4/8 len2/4/8
|
T⁣0 T⁣1 T⁣1 T⁣2 T⁣2 ... len
← capacity →
Heap stored as array with 2N elements per layer. Each T
can have 2 children in layer below. Each T larger than its
children.
Owned Strings
String
ptr2/4/8 capacity2/4/8 len2/4/8
|
U T F - 8 ... len
← capacity →
Observe how String differs from &str and &[char].
CString
ptr2/4/8 len2/4/8
|
A B C ... len ... ␀
NUL-terminated but w/o NUL in middle.
OsString
Platform Defined
|
? ? / ? ?
Encapsulates how operating system
represents strings (e.g., WTF-8 on
Windows).
PathBuf
OsString
|
? ? / ? ?
Encapsulates how operating system
represents paths.
 
Shared Ownership

If the type does not contain a Cell for T, these are often combined with one of the Cell types above to allow shared de-facto mutability.
Rc<T>
ptr2/4/8 meta2/4/8
|
strng2/4/8 weak2/4/8 T
Share ownership of T in same thread. Needs nested Cell
or RefCellto allow mutation. Is neither Send nor Sync.
Arc<T>
ptr2/4/8 meta2/4/8
|
strng2/4/8 weak2/4/8 T
Same, but allow sharing between threads IF contained
T itself is Send and Sync.

Mutex<T> / RwLock<T>
inner poison2/4/8 T
Inner fields depend on platform. Needs to be
held in Arc to be shared between decoupled
threads, or via scope() for scoped threads.
Standard Library
One-Liners

Snippets that are common, but still easy to forget. See Rust Cookbook 🔗 for more.
Strings
Intent	Snippet
Concatenate strings (any Display↓ that is). 1 '21	format!("{x}{y}")
Append string (any Display to any Write). '21	write!(x, "{y}")
Split by separator pattern. STD 🔗	s.split(pattern)
     ... with &str	s.split("abc")
     ... with char	s.split('/')
     ... with closure	s.split(char::is_numeric)
Split by whitespace.	s.split_whitespace()
Split by newlines.	s.lines()
Split by regular expression.2	Regex::new(r"\s")?.split("one two three")

1 Allocates; if x or y are not going to be used afterwards consider using write! or std::ops::Add.
2 Requires regex crate.
I/O
Intent	Snippet
Create a new file	File::create(PATH)?
     Same, via OpenOptions	OpenOptions::new().create(true).write(true).truncate(true).open(PATH)?
Macros
Intent	Snippet
Macro w. variable arguments	macro_rules! var_args { ($($args:expr),*) => {{ }} }
     Using args, e.g., calling f multiple times.	     $( f($args); )*
Esoterics🝖
Intent	Snippet
Cleaner closure captures	wants_closure({ let c = outer.clone(); move || use_clone(c) })
Fix inference in 'try' closures	iter.try_for_each(|x| { Ok::<(), Error>(()) })?;
Iterate and edit &mut [T] if T Copy.	Cell::from_mut(mut_slice).as_slice_of_cells()
Get subslice with length.	&original_slice[offset..][..length]
Canary to ensure trait T is object safe.	const _: Option<&dyn T> = None;
Thread Safety
Examples	Send*	!Send
Sync*	Most types ... Arc<T>1,2, Mutex<T>2	MutexGuard<T>1, RwLockReadGuard<T>1
!Sync	Cell<T>2, RefCell<T>2	Rc<T>, &dyn Trait, *const T3, *mut T3

* An instance t where T: Send can be moved to another thread, a T: Sync means &t can be moved to another thread.
1 If T is Sync.
2 If T is Send.
3 If you need to send a raw pointer, create newtype struct Ptr(*const u8) and unsafe impl Send for Ptr {}. Just ensure you may send it.
Iterators
Obtaining Iterators

Basics

Assume you have a collection c of type C:

    c.into_iter() — Turns collection c into an Iterator STD i and consumes* c. Requires IntoIterator STD for C to be implemented. Type of item depends on what C was. 'Standardized' way to get Iterators.
    c.iter() — Courtesy method some collections provide, returns borrowing Iterator, doesn't consume c.
    c.iter_mut() — Same, but mutably borrowing Iterator that allow collection to be changed.

The Iterator

Once you have an i:

    i.next() — Returns Some(x) next element c provides, or None if we're done.

For Loops

    for x in c {} — Syntactic sugar, calls c.into_iter() and loops i until None.

* If it looks as if it doesn't consume c that's because type was Copy. For example, if you call (&c).into_iter() it will invoke .into_iter() on &c (which will consume the reference and turn it into an Iterator), but c remains untouched.
Implementing Iterators

Basics

Let's assume you have a struct Collection<T> {}.

    struct IntoIter<T> {} — Create a struct to hold your iteration status (e.g., an index) for value iteration.
    impl Iterator for IntoIter {} — Implement Iterator::next() so it can produce elements.

Collection<T>
IntoIter<T>
⌾ Iterator
Item = T;

Shared & Mutable Iterators

    struct Iter<T> {} — Create struct holding &Collection<T> for shared iteration.
    struct IterMut<T> {} — Similar, but holding &mut Collection<T> for mutable iteration.
    impl Iterator for Iter<T> {} — Implement shared iteration.
    impl Iterator for IterMut<T> {} — Implement mutable iteration.

In addition, you might want to add convenience methods:

    Collection::iter(&self) -> Iter,
    Collection::iter_mut(&mut self) -> IterMut.

Iter<T>
⌾ Iterator
Item = &T;
IterMut<T>
⌾ Iterator
Item = &mut T;

Making Loops Work

    impl IntoIterator for Collection {} — Now for x in c {} works.
    impl IntoIterator for &Collection {} — Now for x in &c {} works.
    impl IntoIterator for &mut Collection {} — Now for x in &mut c {} works.

Collection<T>
⌾ IntoIterator
Item = T;
To = IntoIter<T>
Iterate over T.
&Collection<T>
⌾ IntoIterator
Item = &T;
To = Iter<T>
Iterate over &T.
&mut Collectn<T>
⌾ IntoIterator
Item = &mut T;
To = IterMut<T>
Iterate over &mut T.
Number Conversions

As-correct-as-it-currently-gets number conversions.
↓ Have / Want →	u8 … i128	f32 / f64	String
u8 … i128	u8::try_from(x)? 1	x as f32 3	x.to_string()
f32 / f64	x as u8 2	x as f32	x.to_string()
String	x.parse::<u8>()?	x.parse::<f32>()?	x

1 If type true subset from() works directly, e.g., u32::from(my_u8).
2 Truncating (11.9_f32 as u8 gives 11) and saturating (1024_f32 as u8 gives 255); c. below.
3 Might misrepresent number (u64::MAX as f32) or produce Inf (u128::MAX as f32).
String Conversions

If you want a string of type …
String
If you have x of type …	Use this …
String	x
CString	x.into_string()?
OsString	x.to_str()?.to_string()
PathBuf	x.to_str()?.to_string()
Vec<u8> 1	String::from_utf8(x)?
&str	x.to_string() i
&CStr	x.to_str()?.to_string()
&OsStr	x.to_str()?.to_string()
&Path	x.to_str()?.to_string()
&[u8] 1	String::from_utf8_lossy(x).to_string()
CString
If you have x of type …	Use this …
String	CString::new(x)?
CString	x
OsString 2	CString::new(x.to_str()?)?
PathBuf	CString::new(x.to_str()?)?
Vec<u8> 1	CString::new(x)?
&str	CString::new(x)?
&CStr	x.to_owned() i
&OsStr 2	CString::new(x.to_os_string().into_string()?)?
&Path	CString::new(x.to_str()?)?
&[u8] 1	CString::new(Vec::from(x))?
*mut c_char 3	unsafe { CString::from_raw(x) }
OsString
If you have x of type …	Use this …
String	OsString::from(x) i
CString	OsString::from(x.to_str()?)
OsString	x
PathBuf	x.into_os_string()
Vec<u8> 1	?
&str	OsString::from(x) i
&CStr	OsString::from(x.to_str()?)
&OsStr	OsString::from(x) i
&Path	x.as_os_str().to_owned()
&[u8] 1	?
PathBuf
If you have x of type …	Use this …
String	PathBuf::from(x) i
CString	PathBuf::from(x.to_str()?)
OsString	PathBuf::from(x) i
PathBuf	x
Vec<u8> 1	?
&str	PathBuf::from(x) i
&CStr	PathBuf::from(x.to_str()?)
&OsStr	PathBuf::from(x) i
&Path	PathBuf::from(x) i
&[u8] 1	?
Vec<u8>
If you have x of type …	Use this …
String	x.into_bytes()
CString	x.into_bytes()
OsString	?
PathBuf	?
Vec<u8> 1	x
&str	Vec::from(x.as_bytes())
&CStr	Vec::from(x.to_bytes_with_nul())
&OsStr	?
&Path	?
&[u8] 1	x.to_vec()
&str
If you have x of type …	Use this …
String	x.as_str()
CString	x.to_str()?
OsString	x.to_str()?
PathBuf	x.to_str()?
Vec<u8> 1	std::str::from_utf8(&x)?
&str	x
&CStr	x.to_str()?
&OsStr	x.to_str()?
&Path	x.to_str()?
&[u8] 1	std::str::from_utf8(x)?
&CStr
If you have x of type …	Use this …
String	CString::new(x)?.as_c_str()
CString	x.as_c_str()
OsString 2	x.to_str()?
PathBuf	?,4
Vec<u8> 1,5	CStr::from_bytes_with_nul(&x)?
&str	?,4
&CStr	x
&OsStr 2	?
&Path	?
&[u8] 1,5	CStr::from_bytes_with_nul(x)?
*const c_char 1	unsafe { CStr::from_ptr(x) }
&OsStr
If you have x of type …	Use this …
String	OsStr::new(&x)
CString	?
OsString	x.as_os_str()
PathBuf	x.as_os_str()
Vec<u8> 1	?
&str	OsStr::new(x)
&CStr	?
&OsStr	x
&Path	x.as_os_str()
&[u8] 1	?
&Path
If you have x of type …	Use this …
String	Path::new(x) r
CString	Path::new(x.to_str()?)
OsString	Path::new(x.to_str()?) r
PathBuf	Path::new(x.to_str()?) r
Vec<u8> 1	?
&str	Path::new(x) r
&CStr	Path::new(x.to_str()?)
&OsStr	Path::new(x) r
&Path	x
&[u8] 1	?
&[u8]
If you have x of type …	Use this …
String	x.as_bytes()
CString	x.as_bytes()
OsString	?
PathBuf	?
Vec<u8> 1	&x
&str	x.as_bytes()
&CStr	x.to_bytes_with_nul()
&OsStr	x.as_bytes() 2
&Path	?
&[u8] 1	x
Other
You want	And have x	Use this …
*const c_char	CString	x.as_ptr()

i Short form x.into() possible if type can be inferred.
r Short form x.as_ref() possible if type can be inferred.

1 You should, or must if call is unsafe, ensure raw data comes with a valid representation for the string type (e.g., UTF-8 data for a String).

2 Only on some platforms std::os::<your_os>::ffi::OsStrExt exists with helper methods to get a raw &[u8] representation of the underlying OsStr. Use the rest of the table to go from there, e.g.:

use std::os::unix::ffi::OsStrExt;
let bytes: &[u8] = my_os_str.as_bytes();
CString::new(bytes)?

3 The c_char must have come from a previous CString. If it comes from FFI see &CStr instead.

4 No known shorthand as x will lack terminating 0x0. Best way to probably go via CString.

5 Must ensure vector actually ends with 0x0.
String Output

How to convert types into a String, or output them.
APIs

Rust has, among others, these APIs to convert types to stringified output, collectively called format macros:
Macro	Output	Notes
format!(fmt)	String	Bread-and-butter "to String" converter.
print!(fmt)	Console	Writes to standard output.
println!(fmt)	Console	Writes to standard output.
eprint!(fmt)	Console	Writes to standard error.
eprintln!(fmt)	Console	Writes to standard error.
write!(dst, fmt)	Buffer	Don't forget to also use std::io::Write;
writeln!(dst, fmt)	Buffer	Don't forget to also use std::io::Write;
 
Method	Notes
x.to_string() STD	Produces String, implemented for any Display type.
 

Here fmt is string literal such as "hello {}", that specifies output (compare "Formatting" tab) and additional parameters.
Printable Types

In format! and friends, types convert via trait Display "{}" STD or Debug "{:?}" STD , non exhaustive list:
Type	Implements	
String	Debug, Display	
CString	Debug	
OsString	Debug	
PathBuf	Debug	
Vec<u8>	Debug	
&str	Debug, Display	
&CStr	Debug	
&OsStr	Debug	
&Path	Debug	
&[u8]	Debug	
bool	Debug, Display	
char	Debug, Display	
u8 … i128	Debug, Display	
f32, f64	Debug, Display	
!	Debug, Display	
()	Debug	
 

In short, pretty much everything is Debug; more special types might need special handling or conversion ↑ to Display.
Formatting

Each argument designator in format macro is either empty {}, {argument}, or follows a basic syntax:

{ [argument] ':' [[fill] align] [sign] ['#'] [width [$]] ['.' precision [$]] [type] }

Element	Meaning
argument	Number (0, 1, ...), variable '21 or name,'18 e.g., print!("{x}").
fill	The character to fill empty spaces with (e.g., 0), if width is specified.
align	Left (<), center (^), or right (>), if width is specified.
sign	Can be + for sign to always be printed.
#	Alternate formatting, e.g. prettify DebugSTD formatter ? or prefix hex with 0x.
width	Minimum width (≥ 0), padding with fill (default to space). If starts with 0, zero-padded.
precision	Decimal digits (≥ 0) for numerics, or max width for non-numerics.
$	Interpret width or precision as argument identifier instead to allow for dynamic formatting.
type	DebugSTD (?) formatting, hex (x), binary (b), octal (o), pointer (p), exp (e) ... see more.
 
Format Example	Explanation
{}	Print the next argument using Display.STD
{x}	Same, but use variable x from scope. '21
{:?}	Print the next argument using Debug.STD
{2:#?}	Pretty-print the 3rd argument with DebugSTD formatting.
{val:^2$}	Center the val named argument, width specified by the 3rd argument.
{:<10.3}	Left align with width 10 and a precision of 3.
{val:#x}	Format val argument as hex, with a leading 0x (alternate format for x).
 
Full Example	Explanation
println!("{}", x)	Print x using DisplaySTD on std. out and append new line. '15 🗑️
println!("{x}")	Same, but use variable x from scope. '21
format!("{a:.3} {b:?}")	Convert PI with 3 digits, add space, b with Debug STD, return String. '21
 
Tooling
Project Anatomy

Basic project layout, and common files and folders, as used by cargo. ↓
Entry	Code
📁 .cargo/	Project-local cargo configuration, may contain config.toml. 🔗 🝖
📁 benches/	Benchmarks for your crate, run via cargo bench, requires nightly by default. * 🚧
📁 examples/	Examples how to use your crate, they see your crate like external user would.
     my_example.rs	Individual examples are run like cargo run --example my_example.
📁 src/	Actual source code for your project.
     main.rs	Default entry point for applications, this is what cargo run uses.
     lib.rs	Default entry point for libraries. This is where lookup for my_crate::f() starts.
📁 src/bin/	Place for additional binaries, even in library projects.
     extra.rs	Additional binary, run with cargo run --bin extra.
📁 tests/	Integration tests go here, invoked via cargo test. Unit tests often stay in src/ file.
.rustfmt.toml	In case you want to customize how cargo fmt works.
.clippy.toml	Special configuration for certain clippy lints, utilized via cargo clippy 🝖
build.rs	Pre-build script, 🔗 useful when compiling C / FFI, ...
Cargo.toml	Main project manifest, 🔗 Defines dependencies, artifacts ...
Cargo.lock	Dependency details for reproducible builds; add to git for apps, not for libs.
rust-toolchain.toml	Define toolchain override🔗 (channel, components, targets) for this project.

* On stable consider Criterion.
 

Minimal examples for various entry points might look like:
Applications

// src/main.rs (default application entry point)

fn main() {
    println!("Hello, world!");
}

Libraries

// src/lib.rs (default library entry point)

pub fn f() {}      // Is a public item in root, so it's accessible from the outside.

mod m {
    pub fn g() {}  // No public path (`m` not public) from root, so `g`
}                  // is not accessible from the outside of the crate.

Unit Tests

// src/my_module.rs (any file of your project)

fn f() -> u32 { 0 }

#[cfg(test)]
mod test {
    use super::f;           // Need to import items from parent module. Has
                            // access to non-public members.
    #[test]
    fn ff() {
        assert_eq!(f(), 0);
    }
}

Integration Tests

// tests/sample.rs (sample integration test)

#[test]
fn my_sample() {
    assert_eq!(my_crate::f(), 123); // Integration tests (and benchmarks) 'depend' to the crate like
}                                   // a 3rd party would. Hence, they only see public items.

Benchmarks🚧

// benches/sample.rs (sample benchmark)

#![feature(test)]   // #[bench] is still experimental

extern crate test;  // Even in '18 this is needed ... for reasons.
                    // Normally you don't need this in '18 code.

use test::{black_box, Bencher};

#[bench]
fn my_algo(b: &mut Bencher) {
    b.iter(|| black_box(my_crate::f())); // `black_box` prevents `f` from being optimized away.
}

Build Scripts

// build.rs (sample pre-build script)

fn main() {
    // You need to rely on env. vars for target; `#[cfg(...)]` are for host.
    let target_os = env::var("CARGO_CFG_TARGET_OS");
}

*See here for list of environment variables set.
Proc Macros🝖

// src/lib.rs (default entry point for proc macros)

extern crate proc_macro;  // Apparently needed to be imported like this.

use proc_macro::TokenStream;

#[proc_macro_attribute]   // Can now be used as `#[my_attribute]`
pub fn my_attribute(_attr: TokenStream, item: TokenStream) -> TokenStream {
    item
}

// Cargo.toml

[package]
name = "my_crate"
version = "0.1.0"

[lib]
proc-macro = true

 

Module trees and imports:
Module Trees

Modules BK EX REF and source files work as follows:

    Module tree needs to be explicitly defined, is not implicitly built from file system tree. 🔗
    Module tree root equals library, app, … entry point (e.g., lib.rs).

Actual module definitions work as follows:

    A mod m {} defines module in-file, while mod m; will read m.rs or m/mod.rs.
    Path of .rs based on nesting, e.g., mod a { mod b { mod c; }}} is either a/b/c.rs or a/b/c/mod.rs.
    Files not pathed from module tree root via some mod m; won't be touched by compiler! 🛑

Namespaces🝖

Rust has three kinds of namespaces:
Namespace Types 	Namespace Functions 	Namespace Macros
mod X {} 	fn X() {} 	macro_rules! X { ... }
X (crate) 	const X: u8 = 1; 	
trait X {} 	static X: u8 = 1; 	
enum X {} 		
union X {} 		
struct X {} 		
← struct X;1 → 	
← struct X();2 → 	

1 Counts in Types and in Functions, defines type X and constant X.
2 Counts in Types and in Functions, defines type X and function X.

    In any given scope, for example within a module, only one item item per namespace can exist, e.g.,
        enum X {} and fn X() {} can coexist
        struct X; and const X cannot coexist
    With a use my_mod::X; all items called X will be imported.

    Due to naming conventions (e.g., fn and mod are lowercase by convention) and common sense (most developers just don't name all things X) you won't have to worry about these kinds in most cases. They can, however, be a factor when designing macros.

 
Cargo

Commands and tools that are good to know.
Command	Description
cargo init	Create a new project for the latest edition.
cargo build	Build the project in debug mode (--release for all optimization).
cargo check	Check if project would compile (much faster).
cargo test	Run tests for the project.
cargo doc --open	Locally generate documentation for your code and dependencies.
cargo run	Run your project, if a binary is produced (main.rs).
     cargo run --bin b	Run binary b. Unifies features with other dependents (can be confusing).
     cargo run -p w	Run main of sub-workspace w. Treats features more as you would expect.
cargo ... --timings	Show what crates caused your build to take so long. 🔥
cargo tree	Show dependency graph.
cargo +{nightly, stable} ...	Use given toolchain for command, e.g., for 'nightly only' tools.
cargo +nightly ...	Some nightly-only commands (substitute ... with command below)
     rustc -- -Zunpretty=expanded	Show expanded macros. 🚧
rustup doc	Open offline Rust documentation (incl. the books), good on a plane!

Here cargo build means you can either type cargo build or just cargo b; and --release means it can be replaced with -r.
 

These are optional rustup components. Install them with rustup component add [tool].
Tool	Description
cargo clippy	Additional (lints) catching common API misuses and unidiomatic code. 🔗
cargo fmt	Automatic code formatter (rustup component add rustfmt). 🔗
 

A large number of additional cargo plugins can be found here.
 
Cross Compilation

🔘 Check target is supported.

🔘 Install target via rustup target install X.

🔘 Install native toolchain (required to link, depends on target).

Get from target vendor (Google, Apple, …), might not be available on all hosts (e.g., no iOS toolchain on Windows).

Some toolchains require additional build steps (e.g., Android's make-standalone-toolchain.sh).

🔘 Update ~/.cargo/config.toml like this:

[target.aarch64-linux-android]
linker = "[PATH_TO_TOOLCHAIN]/aarch64-linux-android/bin/aarch64-linux-android-clang"

or

[target.aarch64-linux-android]
linker = "C:/[PATH_TO_TOOLCHAIN]/prebuilt/windows-x86_64/bin/aarch64-linux-android21-clang.cmd"

🔘 Set environment variables (optional, wait until compiler complains before setting):

set CC=C:\[PATH_TO_TOOLCHAIN]\prebuilt\windows-x86_64\bin\aarch64-linux-android21-clang.cmd
set CXX=C:\[PATH_TO_TOOLCHAIN]\prebuilt\windows-x86_64\bin\aarch64-linux-android21-clang.cmd
set AR=C:\[PATH_TO_TOOLCHAIN]\prebuilt\windows-x86_64\bin\aarch64-linux-android-ar.exe
...

Whether you set them depends on how compiler complains, not necessarily all are needed.

    Some platforms / configurations can be extremely sensitive how paths are specified (e.g., \ vs /) and quoted.

✔️ Compile with cargo build --target=X
 
Tooling Directives

Special tokens embedded in source code used by tooling or preprocessing.
Macros

Inside a declarative BK macro by example BK EX REF macro_rules! implementation these work:
Within Macros	Explanation
$x:ty	Macro capture (here a type).
     $x:item	An item, like a function, struct, module, etc.
     $x:block	A block {} of statements or expressions, e.g., { let x = 5; }
     $x:stmt	A statement, e.g., let x = 1 + 1;, String::new(); or vec![];
     $x:expr	An expression, e.g., x, 1 + 1, String::new() or vec![]
     $x:pat	A pattern, e.g., Some(t), (17, 'a') or _.
     $x:ty	A type, e.g., String, usize or Vec<u8>.
     $x:ident	An identifier, for example in let x = 0; the identifier is x.
     $x:path	A path (e.g. foo, ::std::mem::replace, transmute::<_, int>).
     $x:literal	A literal (e.g. 3, "foo", b"bar", etc.).
     $x:lifetime	A lifetime (e.g. 'a, 'static, etc.).
     $x:meta	A meta item; the things that go inside #[...] and #![...] attributes.
     $x:vis	A visibility modifier; pub, pub(crate), etc.
     $x:tt	A single token tree, see here for more details.
$crate	Special hygiene variable, crate where macros is defined. ?
Documentation

Inside a doc comment BK EX REF these work:
Within Doc Comments	Explanation
```...```	Include a doc test (doc code running on cargo test).
```X,Y ...```	Same, and include optional configurations; with X, Y being ...
     rust	Make it explicit test is written in Rust; implied by Rust tooling.
     -	Compile test. Run test. Fail if panic. Default behavior.
     should_panic	Compile test. Run test. Execution should panic. If not, fail test.
     no_run	Compile test. Fail test if code can't be compiled, Don't run test.
     compile_fail	Compile test but fail test if code can be compiled.
     ignore	Do not compile. Do not run. Prefer option above instead.
     edition2018	Execute code as Rust '18; default is '15.
#	Hide line from documentation (``` # use x::hidden; ```).
[`S`]	Create a link to struct, enum, trait, function, … S.
[`S`](crate::S)	Paths can also be used, in the form of markdown links.
#![globals]

Attributes affecting the whole crate or app:
Opt-Out's	On	Explanation
#![no_std]	C	Don't (automatically) import stdSTD ; use coreSTD instead. REF
#![no_implicit_prelude]	CM	Don't add preludeSTD, need to manually import None, Vec, ... REF
#![no_main]	C	Don't emit main() in apps if you do that yourself. REF
 
Opt-In's	On	Explanation
#![feature(a, b, c)]	C	Rely on features that may never get stabilized, c. Unstable Book. 🚧
 
Builds	On	Explanation
#![windows_subsystem = "x"]	C	On Windows, make a console or windows app. REF 🝖
#![crate_name = "x"]	C	Specifiy current crate name, e.g., when not using cargo. ? REF 🝖
#![crate_type = "bin"]	C	Specifiy current crate type (bin, lib, dylib, cdylib, ...). REF 🝖
#![recursion_limit = "123"]	C	Set compile-time recursion limit for deref, macros, ... REF 🝖
#![type_length_limit = "456"]	C	Limits maximum number of type substitutions. REF 🝖
 
Handlers	On	Explanation
#[panic_handler]	F	Make some fn f(&PanicInfo) -> ! app's panic handler. REF
#[global_allocator]	S	Make static item impl. GlobalAlloc STD global allocator. REF
#[code]

Attributes primarily governing emitted code:
Developer UX	On	Explanation
#[non_exhaustive]	T	Future-proof struct or enum; hint it may grow in future. REF
#[path = "x.rs"]	M	Get module from non-standard file. REF
 
Codegen	On	Explanation
#[inline]	F	Nicely suggest compiler should inline function at call sites. REF
#[inline(always)]	F	Emphatically threaten compiler to inline call, or else. REF
#[inline(never)]	F	Instruct compiler to feel disappointed if it still inlines the function. REF
#[cold]	F	Hint that function probably isn't going to be called. REF
#[target_feature(enable="x")]	F	Enable CPU feature (e.g., avx2) for code of unsafe fn. REF
#[track_caller]	F	Allows fn to find callerSTD for better panic messages. REF
#[repr(X)]1	T	Use another representation instead of the default rust REF one:
     #[repr(C)]	T	Use a C-compatible (f. FFI), predictable (f. transmute) layout. REF
     #[repr(C, u8)]	enum	Give enum discriminant the specified type. REF
     #[repr(transparent)]	T	Give single-element type same layout as contained field. REF
     #[repr(packed(1))]	T	Lower alignment of struct and contained fields, mildly UB prone. REF
     #[repr(align(8))]	T	Raise alignment of struct to given value, e.g., for SIMD types. REF

1 Some representation modifiers can be combined, e.g., #[repr(C, packed(1))].
 
Linking	On	Explanation
#[no_mangle]	*	Use item name directly as symbol name, instead of mangling. REF
#[no_link]	X	Don't link extern crate when only wanting macros. REF
#[link(name="x", kind="y")]	X	Native lib to link against when looking up symbol. REF
#[link_name = "foo"]	F	Name of symbol to search for resolving extern fn. REF
#[link_section = ".sample"]	FS	Section name of object file where item should be placed. REF
#[export_name = "foo"]	FS	Export a fn or static under a different name. REF
#[used]	S	Don't optimize away static variable despite it looking unused. REF
#[quality]

Attributes used by Rust tools to improve code quality:
Code Patterns	On	Explanation
#[allow(X)]	*	Instruct rustc / clippy to ... ignore class X of possible issues. REF
#[warn(X)] 1	*	... emit a warning, mixes well with clippy lints. 🔥 REF
#[deny(X)] 1	*	... fail compilation. REF
#[forbid(X)] 1	*	... fail compilation and prevent subsequent allow overrides. REF
#[deprecated = "msg"]	*	Let your users know you made a design mistake. REF
#[must_use = "msg"]	FTX	Makes compiler check return value is processed by caller. 🔥 REF

1 There is some debate which one is the best to ensure high quality crates. Actively maintained multi-dev crates probably benefit from more aggressive deny or forbid lints; less-regularly updated ones probably more from conservative use of warn (as future compiler or clippy updates may suddenly break otherwise working code with minor issues).
 
Tests	On	Explanation
#[test]	F	Marks the function as a test, run with cargo test. 🔥 REF
#[ignore = "msg"]	F	Compiles but does not execute some #[test] for now. REF
#[should_panic]	F	Test must panic!() to actually succeed. REF
#[bench]	F	Mark function in bench/ as benchmark for cargo bench. 🚧 REF
 
Formatting	On	Explanation
#[rustfmt::skip]	*	Prevent cargo fmt from cleaning up item. 🔗
#![rustfmt::skip::macros(x)]	CM	... from cleaning up macro x. 🔗
#![rustfmt::skip::attributes(x)]	CM	... from cleaning up attribute x. 🔗
 
Documentation	On	Explanation
#[doc = "Explanation"]	*	Same as adding a /// doc comment. 🔗
#[doc(alias = "other")]	*	Provide another name users can search for in the docs. 🔗
#[doc(hidden)]	*	Prevent item from showing up in docs. 🔗
#![doc(html_favicon_url = "")]	C	Sets the favicon for the docs. 🔗
#![doc(html_logo_url = "")]	C	The logo used in the docs. 🔗
#![doc(html_playground_url = "")]	C	Generates Run buttons and uses given service. 🔗
#![doc(html_root_url = "")]	C	Base URL for links to external crates. 🔗
#![doc(html_no_source)]	C	Prevents source from being included in docs. 🔗
#[macros]

Attributes related to the creation and use of macros:
Macros By Example	On	Explanation
#[macro_export]	!	Export macro_rules! as pub on crate level REF
#[macro_use]	MX	Let macros persist past modules; or import from extern crate. REF
 
Proc Macros	On	Explanation
#[proc_macro]	F	Mark fn as function-like procedural macro callable as m!(). REF
#[proc_macro_derive(Foo)]	F	Mark fn as derive macro which can #[derive(Foo)]. REF
#[proc_macro_attribute]	F	Mark fn as attribute macro which can understand new #[x]. REF
 
Derives	On	Explanation
#[derive(X)]	T	Let some proc macro provide a goodish impl of trait X. 🔥 REF
#[cfg]

Attributes governing conditional compilation:
Config Attributes	On	Explanation
#[cfg(X)]	*	Include item if configuration X holds. REF
#[cfg(all(X, Y, Z))]	*	Include item if all options hold. REF
#[cfg(any(X, Y, Z))]	*	Include item if at least one option holds. REF
#[cfg(not(X))]	*	Include item if X does not hold. REF
#[cfg_attr(X, foo = "msg")]	*	Apply #[foo = "msg"] if configuration X holds. REF
 

    ⚠️ Note, options can generally be set multiple times, i.e., the same key can show up with multiple values. One can expect #[cfg(target_feature = "avx")] and #[cfg(target_feature = "avx2")] to be true at the same time.

 
Known Options	On	Explanation
#[cfg(target_arch = "x86_64")]	*	The CPU architecture crate is compiled for. REF
#[cfg(target_feature = "avx")]	*	Whether a particular class of instructions is available. REF
#[cfg(target_os = "macos")]	*	Operating system your code will run on. REF
#[cfg(target_family = "unix")]	*	Family operating system belongs to. REF
#[cfg(target_env = "msvc")]	*	How DLLs and functions are interfaced with on OS. REF
#[cfg(target_endian = "little")]	*	Main reason your cool new zero-cost protocol fails. REF
#[cfg(target_pointer_width = "64")]	*	How many bits pointers, usize and CPU words have. REF
#[cfg(target_vendor = "apple")]	*	Manufacturer of target. REF
#[cfg(debug_assertions)]	*	Whether debug_assert!() and friends would panic. REF
#[cfg(panic = "unwind")]	*	Whether unwind or abort will happen on panic. ?
#[cfg(proc_macro)]	*	Wheter crate compiled as proc macro. REF
#[cfg(test)]	*	Whether compiled with cargo test. 🔥 REF
#[cfg(feature = "serde")]	*	When your crate was compiled with feature serde. 🔥 REF
build.rs

Environment variables and outputs related to the pre-build script.
Input Environment	Explanation 🔗
CARGO_FEATURE_X	Environment variable set for each feature x activated.
     CARGO_FEATURE_SERDE	If feature serde were enabled.
     CARGO_FEATURE_SOME_FEATURE	If feature some-feature were enabled; dash - converted to _.
CARGO_CFG_X	Exposes cfg's; joins mult. opts. by , and converts - to _.
     CARGO_CFG_TARGET_OS=macos	If target_os were set to macos.
     CARGO_CFG_TARGET_FEATURE=avx,avx2	If target_feature were set to avx and avx2.
OUT_DIR	Where output should be placed.
TARGET	Target triple being compiled for.
HOST	Host triple (running this build script).
PROFILE	Can be debug or release.

Available in build.rs via env::var()?. List not exhaustive.
 
Output String	Explanation 🔗
cargo:rerun-if-changed=PATH	(Only) run this build.rs again if PATH changed.
cargo:rerun-if-env-changed=VAR	(Only) run this build.rs again if environment VAR changed.
cargo:rustc-link-lib=[KIND=]NAME	Link native library as if via -l option.
cargo:rustc-link-search=[KIND=]PATH	Search path for native library as if via -L option.
cargo:rustc-flags=FLAGS	Add special flags to compiler. ?
cargo:rustc-cfg=KEY[="VALUE"]	Emit given cfg option to be used for later compilation.
cargo:rustc-env=VAR=VALUE 	Emit var accessible via env!() in crate during compilation.
cargo:rustc-cdylib-link-arg=FLAG 	When building a cdylib, pass linker flag.
cargo:warning=MESSAGE	Emit compiler warning.

Emitted from build.rs via println!(). List not exhaustive.

For the On column in attributes:
C means on crate level (usually given as #![my_attr] in the top level file).
M means on modules.
F means on functions.
S means on static.
T means on types.
X means something special.
! means on macros.
* means on almost any item.
Working with Types
Types, Traits, Generics

Allowing users to bring their own types and avoid code duplication.
Types & Traits
Types
Type Equivalence and Conversions
Implementations — impl S { }
Traits — trait T { }
Implementing Traits for Types — impl T for S { }
Traits vs. Interfaces
Generics
Type Constructors — Vec<>
Generic Parameters — <T>
Const Generics — [T; N] and S<const N: usize>
Bounds (Simple) — where T: X
Bounds (Compound) — where T: X + Y
Implementing Families — impl<>
Blanket Implementations — impl<T> X for T { ... }
Advanced Concepts🝖
Trait Parameters — Trait<In> { type Out; }
Trait Authoring Considerations (Abstract)
Trait Authoring Considerations (Example)
Dynamic / Zero Sized Types
?Sized
Generics and Lifetimes — <'a>

Examples expand by clicking.
Foreign Types and Traits

A visual overview of types and traits in your crate and upstream.
u8
u16
f32
bool
char
Primitive Types
File
String
Builder
Composite Types
Vec<T>
Vec<T>
Vec<T>
&'a T
&'a T
&'a T
&mut 'a T
&mut 'a T
&mut 'a T
[T; n]
[T; n]
[T; n]
Type Constructors
Vec<T>
Vec<T>
f<T>() {}
drop() {}
Functions
PI
dbg!
Other
⌾ Copy
⌾ Deref
type Tgt;
⌾ From<T>
⌾ From<T>
⌾ From<T>
Traits
Items defined in upstream crates.
⌾ Serialize
⌾ Transport
⌾ ShowHex
Device
⌾ From<u8>
Foreign trait impl. for local type.
String
⌾ Serialize
Local trait impl. for foreign type.
String
⌾ From<u8>
🛑 Illegal, foreign trait for f. type.
String
⌾ From<Port>
Exception: Legal if used type local.
Port
⌾ From<u8>
⌾ From<u16>
Mult. impl. of trait with differing IN params.
Container
⌾ Deref
Tgt = u8;
⌾ Deref
Tgt = f32;
🛑 Illegal impl. of trait with differing OUT params.
T
T
T
⌾ ShowHex
Blanket impl. of trait for any type.
Your crate.

Examples of traits and types, and which traits you can implement for which type.
Type Conversions

How to get B when you have A?
Intro

fn f(x: A) -> B {
    // How can you obtain B from A?
}

Method	Explanation
Identity	Trivial case, B is exactly A.
Computation	Create and manipulate instance of B by writing code transforming data.
Casts	On-demand conversion between types where caution is advised.
Coercions	Automatic conversion within 'weakening ruleset'.1
Subtyping	Automatic conversion within 'same-layout-different-lifetimes ruleset'.1
 

1 While both convert A to B, coercions generally link to an unrelated B (a type "one could reasonably expect to have different methods"), while subtyping links to a B differing only in lifetimes.
Computation (Traits)

fn f(x: A) -> B {
    x.into()
}

Bread and butter way to get B from A. Some traits provide canonical, user-computable type relations:
Trait	Example	Trait implies ...
impl From<A> for B {}	a.into()	Obvious, always-valid relation.
impl TryFrom<A> for B {}	a.try_into()?	Obvious, sometimes-valid relation.
impl Deref for A {}	*a	A is smart pointer carrying B; also enables coercions.
impl AsRef<B> for A {}	a.as_ref()	A can be viewed as B.
impl AsMut<B> for A {}	a.as_mut()	A can be mutably viewed as B.
impl Borrow<B> for A {}	a.borrow()	A has borrowed analog B (behaving same under Eq, ...).
impl ToOwned for A { ... }	a.to_owned()	A has owned analog B.
Casts

fn f(x: A) -> B {
    x as B
}

Convert types with keyword as if conversion relatively obvious but might cause issues. NOM
A	B	Example	Explanation
Ptr	Ptr	device_ptr as *const u8	If *A, *B are Sized.
Ptr	Integer	device_ptr as usize	
Integer	Ptr	my_usize as *const Device	
Number	Number	my_u8 as u16	Often surprising behavior. ↑
enum w/o fields	Integer	E::A as u8	
bool	Integer	true as u8	
char	Integer	'A' as u8	
&[T; N]	*const T	my_ref as *const u8	
fn(...)	Ptr	f as *const u8	If Ptr is Sized.
fn(...)	Integer	f as usize	
 

Where Ptr, Integer, Number are just used for brevity and actually mean:

    Ptr any *const T or *mut T;
    Integer any countable u8 ... i128;
    Number any Integer, f32, f64.

    Opinion 💬 — Casts, esp. Number - Number, can easily go wrong. If you are concerned with correctness, consider more explicit methods instead.

Coercions

fn f(x: A) -> B {
    x
}

Automatically weaken type A to B; types can be substantially1 different. NOM
A	B	Explanation
&mut T	&T	Pointer weakening.
&mut T	*mut T	-
&T	*const T	-
*mut T	*const T	-
&T	&U	Deref, if impl Deref<Target=U> for T.
T	U	Unsizing, if impl CoerceUnsized<U> for T.2 🚧
T	V	Transitivity, if T coerces to U and U to V.
|x| x + x	fn(u8) -> u8	Non-capturing closure, to equivalent fn pointer.
 

1 Substantially meaning one can regularly expect a coercion result B to be an entirely different type (i.e., have entirely different methods) than the original type A.

2 Does not quite work in example above as unsized can't be on stack; imagine f(x: &A) -> &B instead. Unsizing works by default for:

    [T; n] to [T]
    T to dyn Trait if impl Trait for T {}.
    Foo<..., T, ...> to Foo<..., U, ...> under arcane 🔗 circumstances.

Subtyping🝖

fn f(x: A) -> B {
    x
}

Automatically converts A to B for types only differing in lifetimes NOM - subtyping examples:
A(subtype)	B(supertype)	Explanation
&'static u8	&'a u8	Valid, forever-pointer is also transient-pointer.
&'a u8	&'static u8	🛑 Invalid, transient should not be forever.
&'a &'b u8	&'a &'b u8	Valid, same thing. But now things get interesting. Read on.
&'a &'static u8	&'a &'b u8	Valid, &'static u8 is also &'b u8; covariant inside &.
&'a mut &'static u8	&'a mut &'b u8	🛑 Invalid and surprising; invariant inside &mut.
Box<&'static u8>	Box<&'a u8>	Valid, Box with forever is also box with transient; covariant.
Box<&'a u8>	Box<&'static u8>	🛑 Invalid, Box with transient may not be with forever.
Box<&'a mut u8>	Box<&'a u8>	🛑 ⚡ Invalid, see table below, &mut u8 never was a &u8.
Cell<&'static u8>	Cell<&'a u8>	🛑 Invalid, Cell are never something else; invariant.
fn(&'static u8)	fn(&'a u8)	🛑 If fn needs forever it may choke on transients; contravar.
fn(&'a u8)	fn(&'static u8)	But sth. that eats transients can be(!) sth. that eats forevers.
for<'r> fn(&'r u8)	fn(&'a u8)	Higher-ranked type for<'r> fn(&'r u8) is also fn(&'a u8).
 

In contrast, these are not🛑 examples of subtyping:
A	B	Explanation
u16	u8	🛑 Obviously invalid; u16 should never automatically be u8.
u8	u16	🛑 Invalid by design; types w. different data still never subtype even if they could.
&'a mut u8	&'a u8	🛑 Trojan horse, not subtyping; but coercion (still works, just not subtyping).
 
Variance🝖

fn f(x: A) -> B {
    x
}

Automatically converts A to B for types only differing in lifetimes NOM - subtyping variance rules:

    A longer lifetime 'a that outlives a shorter 'b is a subtype of 'b.
    Implies 'static is subtype of all other lifetimes 'a.
    Whether types with parameters (e.g., &'a T) are subtypes of each other the following variance table is used:

Construct1	'a	T	U
&'a T	covariant	covariant	
&'a mut T	covariant	invariant	
Box<T>		covariant	
Cell<T>		invariant	
fn(T) -> U		contravariant	covariant
*const T		covariant	
*mut T		invariant	

Covariant means if A is subtype of B, then T[A] is subtype of T[B].
Contravariant means if A is subtype of B, then T[B] is subtype of T[A].
Invariant means even if A is subtype of B, neither T[A] nor T[B] will be subtype of the other.

1 Compounds like struct S<T> {} obtain variance through their used fields, usually becoming invariant if multiple variances are mixed.

    💡 In other words, 'regular' types are never subtypes of each other (e.g., u8 is not subtype of u16), and a Box<u32> would never be sub- or supertype of anything. However, generally a Box<A>, can be subtype of Box<B> (via covariance) if A is a subtype of B, which can only happen if A and B are 'sort of the same type that only differed in lifetimes', e.g., A being &'static u32 and B being &'a u32.

 
Coding Guides
Idiomatic Rust

If you are used to Java or C, consider these.
Idiom	Code
Think in Expressions	y = if x { a } else { b };
	y = loop { break 5 };
	fn f() -> u32 { 0 }
Think in Iterators	(1..10).map(f).collect()
	names.iter().filter(|x| x.starts_with("A"))
Handle Absence with ?	y = try_something()?;
	get_option()?.run()?
Use Strong Types	enum E { Invalid, Valid { ... } } over ERROR_INVALID = -1
	enum E { Visible, Hidden } over visible: bool
	struct Charge(f32) over f32
Provide Builders	Car::new("Model T").hp(20).build();
Don't Panic	Panics are not exceptions, they may abort() entire process!
	Only raise panic! if impossible to handle error, better return Option or Result.
Split Implementations	Generic types S<T> can have a separate impl per T.
	Rust doesn't have OO, but with separate impl you can get specialization.
Unsafe	Avoid unsafe {}, often safer, faster solution without it. Exception: FFI.
Implement Traits	#[derive(Debug, Copy, ...)] and custom impl where needed.
Tooling	With clippy you can improve your code quality.
	Formatting with rustfmt helps others to read your code.
	Add unit tests BK (#[test]) to ensure your code works.
	Add doc tests BK (``` my_api::f() ```) to ensure docs match code.
Documentation	Annotate your APIs with doc comments that can show up on docs.rs.
	Don't forget to include a summary sentence and the Examples heading.
	If applicable: Panics, Errors, Safety, Abort and Undefined Behavior.
 

    🔥 We highly recommend you also follow the API Guidelines (Checklist) for any shared project! 🔥

 
Async-Await 101

If you are familiar with async / await in C# or TypeScript, here are some things to keep in mind:
Basics
Construct	Explanation
async	Anything declared async always returns an impl Future<Output=_>. STD
     async fn f() {}	Function f returns an impl Future<Output=()>.
     async fn f() -> S {}	Function f returns an impl Future<Output=S>.
     async { x }	Transforms { x } into an impl Future<Output=X>.
let sm = f(); 	Calling f() that is async will not execute f, but produce state machine sm. 1 2
     sm = async { g() };	Likewise, does not execute the { g() } block; produces state machine.
runtime.block_on(sm);	Outside an async {}, schedules sm to actually run. Would execute g(). 3 4
sm.await	Inside an async {}, run sm until complete. Yield to runtime if sm not ready.

1 Technically async transforms following code into anonymous, compiler-generated state machine type; f() instantiates that machine.
2 The state machine always impl Future, possibly Send & co, depending on types used inside async.
3 State machine driven by worker thread invoking Future::poll() via runtime directly, or parent .await indirectly.
4 Rust doesn't come with runtime, need external crate instead, e.g., tokio. Also, more helpers in futures crate.
Execution Flow

At each x.await, state machine passes control to subordinate state machine x. At some point a low-level state machine invoked via .await might not be ready. In that the case worker thread returns all the way up to runtime so it can drive another Future. Some time later the runtime:

    might resume execution. It usually does, unless sm / Future dropped.
    might resume with the previous worker or another worker thread (depends on runtime).

Simplified diagram for code written inside an async block :

       consecutive_code();           consecutive_code();           consecutive_code();
START --------------------> x.await --------------------> y.await --------------------> READY
// ^                          ^     ^                               Future<Output=X> ready -^
// Invoked via runtime        |     |
// or an external .await      |     This might resume on another thread (next best available),
//                            |     or NOT AT ALL if Future was dropped.
//                            |
//                            Execute `x`. If ready: just continue execution; if not, return
//                            this thread to runtime.

Caveats 🛑

With the execution flow in mind, some considerations when writing code inside an async construct:
Constructs 1	Explanation
sleep_or_block();	Definitely bad 🛑, never halt current thread, clogs executor.
set_TL(a); x.await; TL();	Definitely bad 🛑, await may return from other thread, thread local invalid.
s.no(); x.await; s.go();	Maybe bad 🛑, await will not return if Future dropped while waiting. 2
Rc::new(); x.await; rc();	Non-Send types prevent impl Future from being Send; less compatible.

1 Here we assume s is any non-local that could temporarily be put into an invalid state; TL is any thread local storage, and that the async {} containing the code is written without assuming executor specifics.
2 Since Drop is run in any case when Future is dropped, consider using drop guard that cleans up / fixes application state if it has to be left in bad condition across .await points.
 
Closures in APIs

There is a subtrait relationship Fn : FnMut : FnOnce. That means a closure that implements Fn STD also implements FnMut and FnOnce. Likewise a closure that implements FnMut STD also implements FnOnce. STD

From a call site perspective that means:
Signature	Function g can call …	Function g accepts …
g<F: FnOnce()>(f: F)	… f() once.	Fn, FnMut, FnOnce
g<F: FnMut()>(mut f: F)	… f() multiple times.	Fn, FnMut
g<F: Fn()>(f: F)	… f() multiple times.	Fn

Notice how asking for a Fn closure as a function is most restrictive for the caller; but having a Fn closure as a caller is most compatible with any function.
 

From the perspective of someone defining a closure:
Closure	Implements*	Comment
|| { moved_s; } 	FnOnce	Caller must give up ownership of moved_s.
|| { &mut s; } 	FnOnce, FnMut	Allows g() to change caller's local state s.
|| { &s; } 	FnOnce, FnMut, Fn	May not mutate state; but can share and reuse s.

* Rust prefers capturing by reference (resulting in the most "compatible" Fn closures from a caller perspective), but can be forced to capture its environment by copy or move via the move || {} syntax.
 

That gives the following advantages and disadvantages:
Requiring	Advantage	Disadvantage
F: FnOnce	Easy to satisfy as caller.	Single use only, g() may call f() just once.
F: FnMut	Allows g() to change caller state.	Caller may not reuse captures during g().
F: Fn	Many can exist at same time.	Hardest to produce for caller.
 
Unsafe, Unsound, Undefined

Unsafe leads to unsound. Unsound leads to undefined. Undefined leads to the dark side of the force.
Safe Code

Safe Code

    Safe has narrow meaning in Rust, vaguely 'the intrinsic prevention of undefined behavior (UB)'.
    Intrinsic means the language won't allow you to use itself to cause UB.
    Making an airplane crash or deleting your database is not UB, therefore 'safe' from Rust's perspective.
    Writing to /proc/[pid]/mem to self-modify your code is also 'safe', resulting UB not caused intrinsincally.

let y = x + x;  // Safe Rust only guarantees the execution of this code is consistent with
print(y);       // 'specification' (long story ...). It does not guarantee that y is 2x
                // (X::add might be implemented badly) nor that y is printed (Y::fmt may panic).

Unsafe Code

Unsafe Code

    Code marked unsafe has special permissions, e.g., to deref raw pointers, or invoke other unsafe functions.
    Along come special promises the author must uphold to the compiler, and the compiler will trust you.
    By itself unsafe code is not bad, but dangerous, and needed for FFI or exotic data structures.

// `x` must always point to race-free, valid, aligned, initialized u8 memory.
unsafe fn unsafe_f(x: *mut u8) {
    my_native_lib(x);
}

Undefined Behavior

Undefined Behavior (UB)

    As mentioned, unsafe code implies special promises to the compiler (it wouldn't need be unsafe otherwise).
    Failure to uphold any promise makes compiler produce fallacious code, execution of which leads to UB.
    After triggering undefined behavior anything can happen. Insidiously, the effects may be 1) subtle, 2) manifest far away from the site of violation or 3) be visible only under certain conditions.
    A seemingly working program (incl. any number of unit tests) is no proof UB code might not fail on a whim.
    Code with UB is objectively dangerous, invalid and should never exist.

if maybe_true() {
    let r: &u8 = unsafe { &*ptr::null() };   // Once this runs, ENTIRE app is undefined. Even if
} else {                                     // line seemingly didn't do anything, app might now run
    println!("the spanish inquisition");     // both paths, corrupt database, or anything else.
}

Unsound Code

Unsound Code

    Any safe Rust that could (even only theoretically) produce UB for any user input is always unsound.
    As is unsafe code that may invoke UB on its own accord by violating above-mentioned promises.
    Unsound code is a stability and security risk, and violates basic assumption many Rust users have.

fn unsound_ref<T>(x: &T) -> &u128 {      // Signature looks safe to users. Happens to be
    unsafe { mem::transmute(x) }         // ok if invoked with an &u128, UB for practically
}                                        // everything else.

 

    Responsible use of Unsafe 💬

        Do not use unsafe unless you absolutely have to.
        Follow the Nomicon, Unsafe Guidelines, always uphold all safety invariants, and never invoke UB.
        Minimize the use of unsafe and encapsulate it in small, sound modules that are easy to review.
        Never create unsound abstractions; if you can't encapsulate unsafe properly, don't do it.
        Each unsafe unit should be accompanied by plain-text reasoning outlining its safety.

 
Adversarial Code 🝖

Adversarial code is safe 3rd party code that compiles but does not follow API expectations, and might interfere with your own (safety) guarantees.
You author	User code may possibly ...
fn g<F: Fn()>(f: F) { ... }	Unexpectedly panic.
struct S<X: T> { ... }	Implement T badly, e.g., misuse Deref, ...
macro_rules! m { ... }	Do all of the above; call site can have weird scope.
 
Risk Pattern	Description
#[repr(packed)]	Packed alignment can make reference &s.x invalid.
impl std::... for S {}	Any trait impl, esp. std::ops may be broken. In particular ...
     impl Deref for S {}	May randomly Deref, e.g., s.x != s.x, or panic.
     impl PartialEq for S {}	May violate equality rules; panic.
     impl Eq for S {}	May cause s != s; panic; must not use s in HashMap & co.
     impl Hash for S {}	May violate hashing rules; panic; must not use s in HashMap & co.
     impl Ord for S {}	May violate ordering rules; panic; must not use s in BTreeMap & co.
     impl Index for S {}	May randomly index, e.g. s[x] != s[x]; panic.
     impl Drop for S {}	May run code or panic end of scope {}, during assignment s = new_s.
panic!()	User code can panic any time, resulting in abort or unwind.
catch_unwind(|| s.f(panicky))	Also, caller might force observation of broken state in s.
let ... = f();	Variable name can affect order of Drop execution. 1 🛑

1 Notably, when you rename a variable from _x to _ you will also change Drop behavior since you change semantics. A variable named _x will have Drop::drop() executed at the end of its scope, a variable named _ can have it executed immediately on 'apparent' assignment ('apparent' because a binding named _ means wildcard REF discard this, which will happen as soon as feasible, often right away)!
 

    Implications

        Generic code cannot be safe if safety depends on type cooperation w.r.t. most (std::) traits.
        If type cooperation is needed you must use unsafe traits (prob. implement your own).
        You must consider random code execution at unexpected places (e.g., re-assignments, scope end).
        You may still be observable after a worst-case panic.

    As a corollary, safe-but-deadly code (e.g., airplane_speed<T>()) should probably also follow these guides.

 
API Stability

When updating an API, these changes can break client code.RFC Major changes (🔴) are definitely breaking, while minor changes (🟡) might be breaking:
 
Crates
🔴 Making a crate that previously compiled for stable require nightly.
🟡 Altering use of Cargo features (e.g., adding or removing features).
 
Modules
🔴 Renaming / moving / removing any public items.
🟡 Adding new public items, as this might break code that does use your_crate::*.
 
Structs
🔴 Adding private field when all current fields public.
🔴 Adding public field when no private field exists.
🟡 Adding or removing private fields when at least one already exists (before and after the change).
🟡 Going from a tuple struct with all private fields (with at least one field) to a normal struct, or vice versa.
 
Enums
🔴 Adding new variants; can be mitigated with early #[non_exhaustive] REF
🔴 Adding new fields to a variant.
 
Traits
🔴 Adding a non-defaulted item, breaks all existing impl T for S {}.
🔴 Any non-trivial change to item signatures, will affect either consumers or implementors.
🟡 Adding a defaulted item; might cause dispatch ambiguity with other existing trait.
🟡 Adding a defaulted type parameter.
 
Traits
🔴 Implementing any "fundamental" trait, as not implementing a fundamental trait already was a promise.
🟡 Implementing any non-fundamental trait; might also cause dispatch ambiguity.
 
Inherent Implementations
🟡 Adding any inherent items; might cause clients to prefer that over trait fn and produce compile error.
 
Signatures in Type Definitions
🔴 Tightening bounds (e.g., <T> to <T: Clone>).
🟡 Loosening bounds.
🟡 Adding defaulted type parameters.
🟡 Generalizing to generics.
Signatures in Functions
🔴 Adding / removing arguments.
🟡 Introducing a new type parameter.
🟡 Generalizing to generics.
 
Behavioral Changes
🔴 / 🟡 Changing semantics might not cause compiler errors, but might make clients do wrong thing.
 
Misc
Links & Services

These are other great guides and tables.
Cheat Sheets	Description
Rust Learning⭐	Probably the best collection of links about learning Rust.
Functional Jargon in Rust	A collection of functional programming jargon explained in Rust.
Periodic Table of Types	How various types and references correlate.
Futures	How to construct and work with futures.
Rust Iterator Cheat Sheet	Summary of iterator-related methods from std::iter and itertools.
Type-Based Rust Cheat Sheet	Lists common types and how they convert.
 

All major Rust books developed by the community.
Books ️📚	Description
The Rust Programming Language	Standard introduction to Rust, start here if you are new.
     API Guidelines	How to write idiomatic and re-usable Rust.
     Asynchronous Programming 🚧	Explains async code, Futures, ...
     Design Patterns	Idioms, Patterns, Anti-Patterns.
     Edition Guide	Working with Rust 2015, Rust 2018, and beyond.
     Guide to Rustc Development	Explains how the compiler works internally.
     Little Book of Rust Macros	Community's collective knowledge of Rust macros.
     Reference 🚧	Reference of the Rust language.
     RFC Book	Look up accepted RFCs and how they change the language.
     Performance Book	Techniques to improve the speed and memory usage.
     Rust Cookbook	Collection of simple examples that demonstrate good practices.
     Rust in Easy English	Explains concepts in simplified English, good alternative start.
     Rust for the Polyglot Programmer	A guide for the experienced programmer.
     Rustdoc Book	Tips how to customize cargo doc and rustdoc.
     Rustonomicon	Dark Arts of Advanced and Unsafe Rust Programming.
     Unsafe Code Guidelines 🚧	Concise information about writing unsafe code.
     Unstable Book	Information about unstable items, e.g, #![feature(...)].
The Cargo Book	How to use cargo and write Cargo.toml.
The CLI Book	Information about creating CLI tools.
The Embedded Book	Working with embedded and #![no_std] devices.
     The Embedonomicon	First #![no_std] from scratch on a Cortex-M.
The WebAssembly Book	Working with the web and producing .wasm files.
     The wasm-bindgen Guide	How to bind Rust and JavaScript APIs in particular.

For more inofficial books see Little Book of Rust Books.
 

Comprehensive lookup tables for common components.
Tables 📋	Description
Rust Changelog	See all the things that changed in a particular version.
Rust Forge	Lists release train and links for people working on the compiler.
     Rust Platform Support	All supported platforms and their Tier.
     Rust Component History	Check nightly status of various Rust tools for a platform.
ALL the Clippy Lints	All the clippy lints you might be interested in.
Configuring Rustfmt	All rustfmt options you can use in .rustfmt.toml.
Compiler Error Index	Ever wondered what E0404 means?
 

Online services which provide information or tooling.
Services ⚙️	Description
crates.io	All 3rd party libraries for Rust.
std.rs	Shortcut to std documentation.
docs.rs	Documentation for 3rd party libraries, automatically generated from source.
lib.rs	Unofficial overview of quality Rust libraries and applications.
caniuse.rs	Check which Rust version introduced or stabilized a feature.
Rust Playground	Try and share snippets of Rust code.
Rust Search Extension	Browser extension to search docs, crates, attributes, books, …
 
Printing & PDF

    Want this Rust cheat sheet as a PDF? Download the latest PDF here. Alternatively, generate it yourself via File > Print and then "Save as PDF" (works great in Chrome, has some issues in Firefox).

Ralf Biedert, 2022 – cheats.rs

Legal & Privacy


Variable sized arrays / Vectors
let mut vec: Vec<T> = Vec::new();
= Vec::with_capacity();
= vec![];
= Vec::from(slice|str|VecDeque|CString)
= othervec.clone();
if T:Clone
Accessing
vec[3];
vec[1..3], vec[..3], vec[3..], vec[..]; vec[2] = a;
vec.len();
.is_empty();
.first_mut(); .last_mut();
-> Option
.get_mut(index);
-> Option
.contains(needle);
-> bool
.iter().find(|&T| -> bool);
-> Option
.binary_search(x:&T);
-> Result<usize, usize>Ok(i): pos, Err(i): pos for insertion
Adding
.push(3);
to end
.insert(index, element);
.extend(iterable);
.extend_from_slice(&[T]);
.append(other : Vec);
drains other
Removing
.pop();
removes last -> Option
.remove(index);
-> el, shifts left
.swap_remove(index);
-> el, fills with last
.drain(range);
-> iter that drains
.clear();
.retain(|i| -> bool);
in place
Manipulating
.sort();
in place
.sort_by(|&T|->Ordering);
in place
.sort_by_key(|&T|->Key);
Key:Ordering
.reverse();
in place
.swap(index1, index2);
Transforming (Iter, as_, to_)
.iter_mut();
.into_iter();
.chunks_mut(cnk_sz);
-> iter over a non overlapping slice at a time
.windows(wnd_sz);
-> iter over an overlapping slice at a time
.as_ref();
-> &[T] or &Vec<T>
.as_mut_slice();
-> &[T]
Memory
.reserve(100);
in addition to .len() or more
.reserve_exact(100);
in addition to .len()
Split
.split_at_mut(mid);
-> (p1, p2), [mid] in 2nd part
.split_mut(|&T| -> bool);
.splitn_mut(n, |&T| -> bool); .rsplitn_mut(_);
-> iter over subslices, seperated by ||->true,
.split_off(mid);
-> Vec; [mid] in 2nd part
Comparision
Traits
From<BinaryHeap> from() | BorrowMut borrow /_mut() | Clone clone/_from() | Hash hash/_slice() | IndexMut index/_mut() DerefMut deref/_mut() | FromIterator from_iter() | IntoIterator into_iter() | Extend extend() | PartialEq eq() ne() | PartialOrd partial_cmp() lt() le() gt() ge() | Eq | Ord cmp() | Drop drop() | Default default() | Debug (if T:Debug) fmt() | AsRef AsMut as_ref() as_mut() | From from() | Write write() write_all() flush() by_ref() .. |
Hashmaps / Dicts
use std::collections::HashMap;
let mut foo: HashMap<K, V> = HashMap::new();
= HashMap::with_capacity();
K: Eq, Hash
= other.clone();
if V,K:Clone
Access
foo[key];
foo.len();
.iter_mut();
-> iter over (&K, &V)
.into_iter();
-> Iter
.keys();
-> iter over keys
.values_mut();
-> iter over values
.is_empty();
-> bool
.contains_key(k:Q);
-> bool
Manipulate
.get_mut(k:&Q);
-> Option<&V>, K:Borrow<Q>
.entry(key);
in place manipulation
.drain();
-> iter that drains
.clear();
.extend(iter : <Item=(&K,&V)>);
.insert(k,v);
-> Option<&V>, None on success.
.remove(k:&Q);
-> Option<&V>
.from_iter(iter : <Item=(K,V)>);
-> HashMap
Manage
.capacity();
.reserve(additional);
.shrink_to_fit();
.clone_from(source);
overrides self
Comparision
.eq() .ne();
T: PartialEq
Special Hasher
let hm = HashMap::with_hasher(b);
= HashMap::with_capacity_and_hasher(b);
hm.hasher(b);
-> &BuildHasher
Traits
Clone clone() clone_from() | PartialEq eq() ne() | Eq | Debug fmt() | Default default() | Index index() | IntoIterator into_iter() | FromIterator from_iter() | Extend extend() |
Option
let foo : Option = Some(T::new());
                           = None;
If
.is_some();
.is_none();
&
.as_ref();
-> Option<&T>
.as_mut();
-> Option<&mut T>
.cloned();
Option<&T> -> Option<T> if T:Clone
.iter_mut();
Iter with 1 or 0 elements
Retrieve T
.unwrap();
-> T or panic
.expect(msg);
-> T or panic(msg)
.unwrap_or(default:T);
-> T
.unwrap_or_default();
-> T, if T:Default
.unwrap_or_else(|| -> T);
-> T
mutableopt.take();
-> Option<T>, moves T out of mutableopt
Manipulate (map)
.map(|t| -> U);
-> Option<U>
.map_or(default:U, |t| -> U);
-> Option<U>
.map_or_else(|| default -> U, |t| -> U);
-> Option<U>
to Result<>
.ok_or(err:E);
-> Result<T,E>
.ok_or_else(|| err -> E);
-> Result<T,E>
Boolean Combinations
a.and(b : Option<U>);
b if a && b
a.and_then(|| b -> Option<U>);
b if a && b
a.or(b : Option<T>);
a if a else b
a.or_else(|| b -> Option<T>);
a if a else b
Traits
Hash hash() | Debug fmt() | Ord cmp() | Eq | PartialOrd partial_cmp() lt() le() gt() ge() | PartialEq eq() ne() | Copy | Clone clone() clone_from() | Default default() | IntoIterator into_iter() | FromIterator from_iter() |
Result
let foo : Result = Ok(T::new());
                           = Err(E::new());
If
.is_ok();
.is_err();
&
.as_ref();
-> Result<&T, &E>
.as_mut();
-> Option<&mut T, &mut E>
.iter_mut();
Iter with 1 or 0 elements
Retrieve T
.unwrap();
-> T or panic; if E:Debug
.expect(msg);
-> T or panic(msg); if E:Debug
.unwrap_or(default:T);
-> T
.unwrap_or_else(|err| default -> T);
-> T
Retrieve E
.unwrap_err();
-> E; if T:Debug
Manipulate (map)
.map(|t| -> U);
-> Result<U,E>
.map_err(|e| -> F);
-> Result<T,F>
to Option<>
.ok();
-> Option<T>
.err();
-> Option<E>
Boolean Combinations
a.and(b : Result<U,E>);
b if a && b else first err
a.and_then(|| b -> Result<U,E>);
b if a && b else first error
a.or(b : Result<T,E>);
a if a else b
a.or_else(|| b -> Result<T,E>);
a if a else b
Traits
Hash hash() | Debug fmt() | Ord cmp() | Eq | PartialOrd partial_cmp() lt() le() gt() ge() | PartialEq eq() ne() | Copy | Clone clone() clone_from() | IntoIterator into_iter() | FromIterator from_iter() |
Rust Cheatsheet

Contribute at github.com/phaiax/rust-cheatsheet
Creative Commons License
This work is licensed under a .



    Introduction
    1. Notation
    2. Lexical structure
        2.1. Input format
        2.2. Keywords
        2.3. Identifiers
        2.4. Comments
        2.5. Whitespace
        2.6. Tokens
    3. Macros
        3.1. Macros By Example
        3.2. Procedural Macros
    4. Crates and source files
    5. Conditional compilation
    6. Items
        6.1. Modules
        6.2. Extern crates
        6.3. Use declarations
        6.4. Functions
        6.5. Type aliases
        6.6. Structs
        6.7. Enumerations
        6.8. Unions
        6.9. Constant items
        6.10. Static items
        6.11. Traits
        6.12. Implementations
        6.13. External blocks
        6.14. Generic parameters
        6.15. Associated Items
    7. Attributes
        7.1. Testing
        7.2. Derive
        7.3. Diagnostics
        7.4. Code generation
        7.5. Limits
        7.6. Type System
    8. Statements and expressions
        8.1. Statements
        8.2. Expressions
            8.2.1. Literal expressions
            8.2.2. Path expressions
            8.2.3. Block expressions
            8.2.4. Operator expressions
            8.2.5. Grouped expressions
            8.2.6. Array and index expressions
            8.2.7. Tuple and index expressions
            8.2.8. Struct expressions
            8.2.9. Call expressions
            8.2.10. Method call expressions
            8.2.11. Field access expressions
            8.2.12. Closure expressions
            8.2.13. Loop expressions
            8.2.14. Range expressions
            8.2.15. If and if let expressions
            8.2.16. Match expressions
            8.2.17. Return expressions
            8.2.18. Await expressions
            8.2.19. Underscore expressions
    9. Patterns
    10. Type system
        10.1. Types
            10.1.1. Boolean type
            10.1.2. Numeric types
            10.1.3. Textual types
            10.1.4. Never type
            10.1.5. Tuple types
            10.1.6. Array types
            10.1.7. Slice types
            10.1.8. Struct types
            10.1.9. Enumerated types
            10.1.10. Union types
            10.1.11. Function item types
            10.1.12. Closure types
            10.1.13. Pointer types
            10.1.14. Function pointer types
            10.1.15. Trait object types
            10.1.16. Impl trait type
            10.1.17. Type parameters
            10.1.18. Inferred type
        10.2. Dynamically Sized Types
        10.3. Type layout
        10.4. Interior mutability
        10.5. Subtyping and Variance
        10.6. Trait and lifetime bounds
        10.7. Type coercions
        10.8. Destructors
        10.9. Lifetime elision
    11. Special types and traits
    12. Names
        12.1. Namespaces
        12.2. Scopes
        12.3. Preludes
        12.4. Paths
        12.5. Name resolution
        12.6. Visibility and privacy
    13. Memory model
        13.1. Memory allocation and lifetime
        13.2. Variables
    14. Linkage
    15. Inline assembly
    16. Unsafety
        16.1. Unsafe functions
        16.2. Unsafe blocks
        16.3. Behavior considered undefined
        16.4. Behavior not considered unsafe
    17. Constant Evaluation
    18. Application Binary Interface
    19. The Rust runtime
    20. Appendices
        20.1. Macro Follow-Set Ambiguity Formal Specification
        20.2. Influences
        20.3. Glossary

The Rust Reference
Types

Every variable, item, and value in a Rust program has a type. The type of a value defines the interpretation of the memory holding it and the operations that may be performed on the value.

Built-in types are tightly integrated into the language, in nontrivial ways that are not possible to emulate in user-defined types. User-defined types have limited capabilities.

The list of types is:

    Primitive types:
        Boolean — bool
        Numeric — integer and float
        Textual — char and str
        Never — ! — a type with no values
    Sequence types:
        Tuple
        Array
        Slice
    User-defined types:
        Struct
        Enum
        Union
    Function types:
        Functions
        Closures
    Pointer types:
        References
        Raw pointers
        Function pointers
    Trait types:
        Trait objects
        Impl trait

Type expressions

    Syntax
    Type :
          TypeNoBounds
       | ImplTraitType
       | TraitObjectType

    TypeNoBounds :
          ParenthesizedType
       | ImplTraitTypeOneBound
       | TraitObjectTypeOneBound
       | TypePath
       | TupleType
       | NeverType
       | RawPointerType
       | ReferenceType
       | ArrayType
       | SliceType
       | InferredType
       | QualifiedPathInType
       | BareFunctionType
       | MacroInvocation

A type expression as defined in the Type grammar rule above is the syntax for referring to a type. It may refer to:

    Sequence types (tuple, array, slice).
    Type paths which can reference:
        Primitive types (boolean, numeric, textual).
        Paths to an item (struct, enum, union, type alias, trait).
        Self path where Self is the implementing type.
        Generic type parameters.
    Pointer types (reference, raw pointer, function pointer).
    The inferred type which asks the compiler to determine the type.
    Parentheses which are used for disambiguation.
    Trait types: Trait objects and impl trait.
    The never type.
    Macros which expand to a type expression.

Parenthesized types

    ParenthesizedType :
       ( Type )

In some situations the combination of types may be ambiguous. Use parentheses around a type to avoid ambiguity. For example, the + operator for type boundaries within a reference type is unclear where the boundary applies, so the use of parentheses is required. Grammar rules that require this disambiguation use the TypeNoBounds rule instead of Type.

type T<'a> = &'a (dyn Any + Send);

Recursive types

Nominal types — structs, enumerations, and unions — may be recursive. That is, each enum variant or struct or union field may refer, directly or indirectly, to the enclosing enum or struct type itself. Such recursion has restrictions:

    Recursive types must include a nominal type in the recursion (not mere type aliases, or other structural types such as arrays or tuples). So type Rec = &'static [Rec] is not allowed.
    The size of a recursive type must be finite; in other words the recursive fields of the type must be pointer types.

An example of a recursive type and its use:

enum List<T> {
    Nil,
    Cons(T, Box<List<T>>)
}

let a: List<i32> = List::Cons(7, Box::new(List::Cons(13, Box::new(List::Nil))));




A+VgEDitto lockscreen kbdin pis345Apolsiren

thoughtram

    Training
    Consulting
    Blog

← Back to Blog
Author

Pascal Precht
17 March 2020

Rust
References in Rust

New to Rust? Check out my YouTube channel or my free introduction course on Egghead!

If you’ve read our article on Rust’s Ownership or if you’ve written your first few programs and wondered what’s the difference between String and &str, you’re most likely aware that there’s the notion of references in Rust. References enable us to give things like functions an data structures access to values, without transferring ownership. Or, in other words, without moving them. In this article we’re going to explore references a bit further and take a closer look at some interesting characteristics.
What are references again?

Just in case you haven’t checked out the other linked articles, here’s a quick recap:

A reference is a nonowning pointer type that references another value in memory. References are created using the borrow-operator &, so the following code creates a variable x that owns 10 and a variable r, that is a reference to x:

let x = 10;
let r = &x;

Since 10 is a primitive type, it gets stored on the stack and so does the reference. Here’s roughly what it looks like in memory (if “stack” and “heap” are terms that don’t make sense to you, you should really have a look at our article on Ownership in Rust:

                   +–––––––+
                   │       │
            +–––+––V–+–––+–│–+–––+
stack frame │   │ 10 │   │ • │   │ 
            +–––+––––+–––+–––+–––+
                [––––]   [–––]
                  x        r

References can point to values anywhere in memory, not just the stack frame. The following code for example, creates a string slice reference as discussed in our article on String vs &str in Rust:

let my_name = "Pascal Precht".to_string();

let last_name = &my_name[7..];

A String is a pointer type that points at the data stored on the heap. Notice that the string slice is a reference to a substring of that data and therefore also points at the memory on the heap:

                my_name       last_name
            [––––––––––––]    [–––––––]
            +–––+––––+––––+–––+–––+–––+
stack frame │ • │ 16 │ 13 │   │ • │ 6 │ 
            +–│–+––––+––––+–––+–│–+–––+
              │                 │
              │                 +–––––––––+
              │                           │
              │                           │
              │                         [–│––––––– str –––––––––]
            +–V–+–––+–––+–––+–––+–––+–––+–V–+–––+–––+–––+–––+–––+–––+–––+–––+
       heap │ P │ a │ s │ c │ a │ l │   │ P │ r │ e │ c │ h │ t │   │   │   │
            +–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+

In case of strings, it’s also possible to create string literals, which are preallocated readonly memory. So for example name in the following code is a reference to a str that lives in preallocated memory as part of the program:

let name = "Pascal";

Which looks something like this:

            name: &str
            [–––––––]
            +–––+–––+
stack frame │ • │ 6 │ 
            +–│–+–––+
              │                 
              +––+                
                 │
 preallocated  +–V–+–––+–––+–––+–––+–––+
 read-only     │ P │ a │ s │ c │ a │ l │
 memory        +–––+–––+–––+–––+–––+–––+

Okay, so what else is there to say about references? A few things. Let’s start with shared references and mutable references.
Shared and mutable references

As you probably know, variables in Rust are immutable by default. The same applies to references as well. Say we have a struct Person and try to compile the code below:

struct Person {
  first_name: String,
  last_name: String,
  age: u8
}

let p = Person {
  first_name: "Pascal".to_string(),
  last_name: "Precht".to_string(),
  age: 28
};

let r = &p;

r.age = 29;

This will result in an error:

error[E0594]: cannot assign to `r.age` which is behind a `&` reference
  --> src/main.rs:16:3
   |
14 |   let r = &p;
   |           -- help: consider changing this to be a mutable reference: `&mut p`
15 |   
16 |   r.age = 29;
   |   ^^^^^^^^^^ `r` is a `&` reference, so the data it refers to cannot be written

You can see it action here. Rust is very clear about the issue and tells us to make &p mutable using the mut keyword. The same goes for r and p as well. However, this introduces another characteristic. There can be only one mutable reference at a time.

let mut r = &mut p;
let mut r2 = &mut p;

The code above tries to create two mutable references to the same data. If we try to compile this code, Rust will emit this error:

error[E0499]: cannot borrow `p` as mutable more than once at a time
  --> src/main.rs:15:16
   |
14 |   let mut r = &mut p;
   |               ------ first mutable borrow occurs here
15 |   let mut r2 = &mut p;
   |                ^^^^^^ second mutable borrow occurs here
16 |   
17 |   r.age = 29;
   |   ---------- first borrow later used here

While it may occur unexpected, it actually makes perfect sense. Rust claims to be memory safe and one of the things that make this claim true, is that there can’t be multiple mutable references to the same data. Allowing multiple such references in different parts of the code, there’d be no guarantee that one of them won’t mutate the data in an unexpected way.

On the other hand though, it’s possible to have as many shared references of the same data as needed. So assuming p and r aren’t mutable, doing this would be totally fine:

let r = &p;
let r2 = &p;
let r3 = &p;
let r4 = &p;
let r5 = &p;

It’s even possible to have references of references!

let r = &p;
let rr = &r; // &&p
let rrr = &rr; // &&&p
let rrrr = &rrr; // &&&&p
let rrrrr = &rrrrr; // &&&&&p

But wait… How would that be practical? If we pass r5, which really is a &&&&&p, to a function, how is that function supposed to work with a reference to a reference to a reference to a… you get the idea. Turns out, references can be dereferenced.
Dereferencing References

References can be dereferenced using the *-operator, so one can access their underlying value in memory. If we take the code snippet from earlier where x owned 10 and r held a reference to it, the reference could be dereferenced as follows for comparison:

let x = 10;
let r = &x;

if *r == 10 {
  println!("Same!");
}

However, let’s take a look at this slightly different code:

fn main() {
  let x = 10;
  let r = &x;
  let rr = &r; // `rr` is a `&&x`

  if is_ten(rr) {
    println!("Same!");
  }
}

fn is_ten(val: &i32) -> bool {
  *val == 10
}

is_ten() takes a &i32, or, a reference to a 32 bit signed integer. The thing we pass to it though, is actually a &&i32, or, a reference to a reference to a 32 bit signed integer.

So for this to work, it looks like val: &i32 should actually be val: &&i32, and the expression *val == 10 should be **val == 10. In fact, if make those changes to the code it compiles and runs as expected. You can see it in action here. However, it turns out that when not making these changes, the code still compiles, so what’s going on there?

Rust’s comparison operators (things like == and >= etc) are smart enough to traverse a chain of references until they reach a value, as long as both operands have the same type. This means in practice, you can have as many references to references as needed, the “synctactical cost” stays the same as the compiler will figure it out for you!
Implicit dereferencing and borrowing

At this point, you might be wondering: How come I don’t have to use the *-operator when calling methods on certain types?

To illustrate this, let’s have a look at the Person struct from earlier:

struct Person {
  first_name: String,
  last_name: String,
  age: u8
}

fn main() {
  let pascal = Person {
    first_name: "Pascal".to_string(),
    last_name: "Precht".to_string(),
    age: 28
  };

  let r = &pascal;

  println!("Hello, {}!", r.first_name);
}

Notice that, even though we’re working with a reference, we didn’t have to use the *-operator to access the first_name property of r, which is actually a reference. What we’re experiencing here is another usability feature of the Rust compiler. It turns out the .-operator performs the dereferencing implicitly, if needed!

The same code can be de-sugared to:

println!("Hello, {}!", (*r).first_name);

The same applies to borrowing references and mutable references as well. For example, an array’s sort() method needs a &mut self. However, we don’t have to worry about that when writing code like this:

fn main() {
  let mut numbers = [3, 1, 2];
  numbers.sort();
}

The .-operator will implicitly borrow a reference to its left operand. This means, the .sort() call is the equivalent of:

(&mut numbers).sort();

🤯 How cools is that?
What’s next?

If there’s one more thing that should be talked about when it comes to references in Rust, it’s probably its safety and lifetime characteristics. You can read more about that in our article about Lifetimes in Rust!
Liked this Rust article?

I started learning Rust out of curiosity with zero experience in systems programming. I know the pain. Learning Rust doesn't have to be hard. If you liked the article, sign up here and I'll inform you about new Rust content. ✌🏼
Written by  Author

Pascal Precht
Company

    Blog
    Training
    Angular Master Class
    Git Master Class
    RxJS Master Class
    Consulting and Code Review
    Code of Conduct

Community

    Twitter
    Facebook
    Github

Legal Notice

© 2014-2022 thoughtram GmbH

Academy
Testimonials
Blog
Community
Sign In
Join Academy
Rust Cheat Sheet

We created this Rust Cheat Sheet initially for students of our Rust Bootcamp: Rust Programming: The Complete Developer's Guide.

But we're now sharing it with any and all Developers that want to learn and remember some of the key functions and concepts of Rust, and have a quick reference guide to the fundamentals of Rust.

We guarantee this is the best and most comprehensive Rust Cheat Sheet you can find.

If you'd like to download a PDF version of this Rust Cheat Sheet, enter your email below and we'll send it to you!
Download This Rust PDF Cheatsheet For Free

No spam, ever. Unsubscribe anytime.

If you’ve stumbled across this cheatsheet and are just starting to learn Rust, you've made a great choice! Rust is a super productive, super safe, and super fast language. This has made it the most loved programming language amongst developers and it's a great laguage to learn if you're interested in becoming a Backend Developer or Fullstack Developer.

However, if you're stuck in an endless cycle of YouTube tutorials and want to start building real world projects, become a professional developer, have fun and actually get hired, then come join the Zero To Mastery Academy. You'll learn Rust from actual industry professionals alongside thousands of students in our private Discord community.

You'll not only learn to become a top 10% Rust Developer by learning advanced topics most courses don't cover. But you'll also build Rust projects, including a clipboard web service featuring Handlebars template rendering, state and cookie management, and database connections that you'll be able to add to your portfolio and wow employers!

Just want the cheatsheet? No problem! Please enjoy and if you'd like to submit any suggestions, feel free to email us at support@zerotomastery.io.
Contents
Rustup
Cargo
Documentation comments
Operators

Mathematical, Comparison, Logical, Bitwise
Primitive Data Types

Signed Integers, Unsigned Integers, Floating Point Numbers, Strings / Characters, Other
Declarations

Variables, Constants
Type Aliases

New Types
Functions

Closures
Control Flow

if, if let, match, while, while let, for, loop
Structures

impl Blocks, Matching on Structures, Destructuring Assignment
Enumerations

Match on Enums
Tuples
Arrays
Slices

Slice Patterns
Option
Result / Error Handling

Question Mark Operator
Iterator
Ownership & Borrowing

Lifetimes
Traits

Associated Types, Trait Objects, Default, From/Into
Generics
Operator Overloading

Index
Concurrent Programming

Threads, Channels, Mutex, Async
Modules

Inline Modules, Modules as Files
Testing

Test Module, Doctests
Standard Library Macros
Standard Library Derive Macros
Declarative Macros

Valid Positions, Fragment Specifiers, Repetitions, Example Macros, Macro Notes
Rustup

Rustup is used to install and manage Rust toolchains. Toolchains are complete installations of Rust compiler and tools.

Click for more details
Command 	Description
rustup show 	Show currently installed & active toolchains
rustup update 	Update all toolchains
rustup default TOOLCHAIN 	Set the default toolchain
rustup component list 	List available components
rustup component add NAME 	Add a component (like Clippy or offline docs)
rustup target list 	List available compilation targets
rustup target add NAME 	Add a compilation target
Cargo

Cargo is a tool used to build and run Rust projects.

Click for more details
Command 	Description
cargo init 	Create a new binary project
cargo init --lib 	Create a new library project
cargo check 	Check code for errors
cargo clippy 	Run code linter (use rustup component add clippy to install)
cargo doc 	Generate documentation
cargo run 	Run the project
cargo --bin NAME 	Run a specific project binary
cargo build 	Build everything in debug mode
cargo build --bin NAME 	Build a specific binary in debug mode
cargo build --release 	Bulld everything in release mode
cargo build --target NAME 	Build for a specific target
cargo --explain CODE 	Detailed information regarding an compiler error code
cargo test 	Run all tests
cargo test TEST_NAME 	Run a specific test
cargo test --doc 	Run doctests only
cargo test --examples 	Run tests for example code only
cargo bench 	Run benchmarks
Documentation Comments

Rust has support for doc comments using the rustdoc tool. This tool can be invoked using cargo doc and it will generate HTML documentation for your crate. In addition to generating documentation, the tool will also test your example code.

Click for more details

/// Documentation comments use triple slashes.
/// 
/// They are parsed in markdown format, so things
/// like headers, tables, task lists, and links to other types
/// can be included in the documentation.
/// 
/// Example code can also be included in doc comments with
/// three backticks (`). All example code in documentation is
/// tested with `cargo test` (this only applies to library crates).
fn is_local_phone_number(num: &str) -> bool {
    use regex::Regex;
    let re = Regex::new(r"[0-9]{3}-[0-9]{4}").unwrap();
    re.is_match(num)
}

Operators
Mathematical
Operator 	Description
+ 	add
- 	subtract
* 	multiply
/ 	divide
% 	remainder / modulo
+= 	add and assign
-= 	subtract and assign
*= 	multiply and assign
/= 	divide and assign
%= 	remainder / modulo and assign
Comparison
Operator 	Description
== 	equal
!= 	not equal
< 	less than
<= 	less than or equal
> 	greater than
>= 	greater than or equal
Logical
Operator 	Description
&& 	and
|| 	or
! 	not
Bitwise
Operator 	Description
& 	and
| 	or
^ 	xor
<< 	left shift
>> 	right shift
&= 	and and assign
|= 	or and assign
^= 	xor and assign
<<= 	left shift and assign
>>= 	right shift and assign
Primitive Data Types
Signed Integers
Type 	Default 	Range
i8 	0 	-128..127
i16 	0 	-32768..32767
i32 	0 	-2147483648..2147483647
i64 	0 	-9223372036854775808..9223372036854775807
i128 	0 	min: -170141183460469231731687303715884105728
i128 	0 	max: 170141183460469231731687303715884105727
isize 	0 	<pointer size on target architecture>
Unsigned Integers
Type 	Default 	Range
u8 	0 	0..255
u16 	0 	0..65535
u32 	0 	0..4294967295
u64 	0 	0..18446744073709551615
u128 	0 	0..340282366920938463463374607431768211455
usize 	0 	<pointer size on target architecture>
Floating Point Numbers
Type 	Default 	Notes
f32 	0 	32-bit floating point
f64 	0 	64-bit floating point
Strings / Characters
Type 	Notes
char 	Unicode scalar value. Create with single quotes ''
String 	UTF-8-encoded string
&str 	Slice into String / Slice into a static str. Create with double quotes "" or r#""# for a raw mode (no escape sequences, can use double quotes)
OsString 	Platform-native string
OsStr 	Borrowed OsString
CString 	C-compatible nul-terminated string
CStr 	Borrowed CString
Other
Type 	Notes
bool 	true or false
unit 	() No value / Meaningless value
fn 	Function pointer
tuple 	Finite length sequence
array 	Fixed-sized array
slice 	Dynamically-sized view into a contiguous sequence
Declarations
Variables

// `let` will create a new variable binding
let foo = 1;
// bindings are immutable by default
foo = 2;              // ERROR: cannot assign; `foo` not mutable

let mut bar = 1;      // create mutable binding
bar = 2;              // OK to mutate

let baz = 'a';        // use single quotes to create a character
let baz = "ok";       // use double quotes to create a string
// variables can be shadowed, so these lines have been valid
let baz = 42;         // `baz` is now an integer; 'a' and "ok" no longer accessible

// Rust infers types, but you can use annotations as well
let foo: i32 = 50;    // set `foo` to i32
let foo: u8 = 100;    // set `foo` to u8
// let foo: u8 = 256; // ERROR: 256 too large to fit in u8

let bar = 14.5_f32;   // underscore can be used to set numeric type...
let bar = 99_u8;
let bar = 1_234_567;  // ...and also to make it easier to read long numbers

let baz;              // variables can start uninitialized, but they must be set before usage
// let foo = baz;     // ERROR: possibly uninitialized.
baz = 0;              // `baz` is now initialized
// baz = 1;           // ERROR: didn't declare baz as mutable

// naming convention:
let use_snake_case_for_variables = ();

Constants

// `const` will create a new constant value
const PEACE: char = '☮';    // type annotations are required
const MY_CONST: i32 = 4;    // naming conventions is SCREAMING_SNAKE_CASE

// const UNINIT_CONST: usize;  // ERROR: must have initial value for constants

// use `once_cell` crate if you need lazy initialization of a constant
use once_cell::sync::OnceCell;
const HOME_DIR: OnceCell<String> = OnceCell::new();
// use .set to set the value (can only be done once)
HOME_DIR.set(std::env::var("HOME").expect("HOME not set"));
// use .get to retrieve the value
HOME_DIR.get().unwrap();

Type Aliases

Type aliases allow long types to be represented in a more compact format.

// use `type` to create a new type alias
type Foo = Bar;
type Miles = u64;
type Centimeters = u64;
type Callbacks = HashMap<String, Box<dyn Fn(i32, i32) -> i32>>;

struct Contact {
    name: String,
    phone: String,
}
type ContactName = String;
// type aliases can contain other type aliases
type ContactIndex = HashMap<ContactName, Contact>;

// type aliases can be used anywhere a type can be used
fn add_contact(index: &mut ContactIndex, contact: Contact) {
    index.insert(contact.name.to_owned(), contact);
}

// type aliases can also contain lifetimes ...
type BorrowedItems<'a> = Vec<&'a str>;
// ... and also contain generic types
type GenericThings<T> = Vec<Thing<T>>;

New Types

"New Types" are existing types wrapped up in a new type. This can be used to implement traits for types that are defined outside of your crate and can be used for stricter compile-time type checking.

// This block uses type aliases instead of New Types:
{
    type Centimeters = f64;
    type Kilograms = f64;
    type Celsius = f64;

    fn add_distance(a: Centimeters, b: Centimeters) -> Centimeters {
        a + b
    }
    fn add_weight(a: Kilograms, b: Kilograms) -> Kilograms {
        a + b
    }
    fn add_temperature(a: Celsius, b: Celsius) -> Celsius {
        a + b
    }

    let length = 20.0;
    let weight = 90.0;
    let temp = 27.0;

    // Since type aliases are the same as their underlying type,
    // it's possible to accidentally use the wrong data as seen here:
    let distance = add_distance(weight, 10.0);
    let total_weight = add_weight(temp, 20.0);
    let new_temp = add_temperature(length, 5.0);
}

// This block uses new types instead of type aliases:
{
    // create 3 tuple structs as new types, each wrapping f64
    struct Centimeters(f64);
    struct Kilograms(f64);
    struct Celsius(f64);

    fn add_distance(a: Centimeters, b: Centimeters) -> Centimeters {
        // access the field using .0
        Centimeters(a.0 + b.0)
    }
    fn add_weight(a: Kilograms, b: Kilograms) -> Kilograms {
        Kilograms(a.0 + b.0)
    }
    fn add_temperature(a: Celsius, b: Celsius) -> Celsius {
        Celsius(a.0 + b.0)
    }

    // the type must be specified
    let length = Centimeters(20.0);
    let weight = Kilograms(90.0);
    let temp = Celsius(27.0);

    let distance = add_distance(length, Centimeters(10.0));
    let total_weight = add_weight(weight, Kilograms(20.0));
    let new_temp = add_temperature(temp, Celsius(5.0));

    // using the wrong type is now a compiler error:
    // let distance = add_distance(weight, Centimeters(10.0));
    // let total_weight = add_weight(temp, Kilograms(20.0));
    // let new_temp = add_temperature(length, Celsius(5.0));
}

Functions

Functions are fundamental to programming in Rust. Signatures require type annotations for all input parameters and all output types. Functions evaluate their bodies as an expression, so data can be returned without using the return keyword.

Click for more details

// use the `fn` keyword to create a function
fn func_name() { /* body */ }

// type annotations required for all parameters
fn print(msg: &str) {
    println!("{msg}");
}

// use -> to return values
fn sum(a: i32, b: i32) -> i32 {
    a + b   // `return` keyword optional
}
sum(1, 2);  // call a function

// `main` is the entry point to all Rust programs
fn main() {}

// functions can be nested
fn outer() -> u32 {
    fn inner() -> u32 { 42 }
    inner()         // call nested function & return the result
}

// use `pub` to make a function public
pub fn foo() {}

// naming convention:
fn snake_case_for_functions() {}

Closures

Closures are similar to functions but offer additional capabilities. They capture (or "close over") their environment which allows them to capture variables without needing to explicitly supply them via parameters.
Type 	Notes
Fn 	Closure can be called any number of times
FnMut 	Closure can mutate values
FnOnce 	Closure can only be called one time

Click for more details

// use pipes to create closures
let hello = || println!("hi");
// parameters to closures go between the pipes
let msg = |msg| println!("{msg}");
// closures are called just like a function
msg("hello");

// type annotations can be provided...
let sum = |a: i32, b: i32| -> i32 { a + b };
// ...but they are optional
let sum = |a, b| a + b;
let four = sum(2, 2);
assert_eq!(four, 4);

// closures can be passed to functions using the `dyn` keyword
fn take_closure(clos: &dyn Fn()) {
    clos();
}
let hello = || println!("hi");
take_closure(&hello);

// use the `move` keyword to move values into the closure
let hi = String::from("hi");
let hello = move || println!("{hi}");
// `hi` can no longer be used because it was moved into `hello`

Control Flow

Control flow allows code to branch to different sections, or to repeat an action multiple times. Rust provides multiple control flow mechanisms to use for different situations.
if

if checks if a condition evalutes to true and if so, will execute a specific branch of code.

if some_bool { /* body */ }

if one && another {
    // when true
} else {
    // when false
}

if a || (b && c) {
    // when one of the above
} else if d {
    // when d
} else {
    // none are true
}

// `if` is an expression, so it can be assigned to a variable
let (min, max, num) = (0, 10, 12);
let num = if num > max {
    max
} else if num < min {
    min
} else {
    num
};
assert_eq!(num, 10);

if let

if let will destructure data only if it matches the provided pattern. It is commonly used to operate on data within an Option or Result.

Click for more details

let something = Some(1);
if let Some(inner) = something {
    // use `inner` data
    assert_eq!(inner, 1);
}

enum Foo {
    Bar,
    Baz
}
let bar = Foo::Bar;
if let Foo::Baz = bar {
    // when bar == Foo::Baz
} else {
    // anything else 
}

// `if let` is an expression, so it can be assigned to a variable
let maybe_num = Some(1);
let definitely_num = if let Some(num) = maybe_num { num } else { 10 };
assert_eq!(definitely_num, 1);

match

Match provides exhaustive pattern matching. This allows the compiler to ensure that every possible case is handled and therefore reduces runtime errors.

Click for more details

let num = 0; 
match num {
    // ... on a single value
    0 => println!("zero"),
    // ... on multiple values
    1 | 2 | 3 => println!("1, 2, or 3"),
    // ... on a range
    4..=9 => println!("4 through 9"),
    // ... with a guard
    n if n >= 10 && n <= 20 => println!("{n} is between 10 and 20"),
    // ... using a binding
    n @ 21..=30 => println!("{n} is between 21 and 30"),
    // ... anything else
    _ => println!("number is ignored"),
}

// `match` is an expression, so it will evaluate and can be assigned
let num = 0;
let msg = match num {
    0 => "zero",
    1 => "one",
    _ => "other",
};
assert_eq!(msg, "zero");

while

while will continually execute code as long as a condition is true.

// must be mutable so it can be modified in the loop
let mut i = 0;

// as long as `i` is less than 10, execute the body
while i < 10 {
    if i == 5 {
        break;     // completely stop execution of the loop
    }
    if i == 8 {
        continue;  // stop execution of this iteration, restart from `while`
    }

    // don't forget to adjust `i`, otherwise the loop will never terminate
    i += 1;
}

// `while` loops can be labeled for clarity and must start with single quote (')
let mut r = 0;
let mut c = 0;
// label named 'row
'row: while r < 10 {
    // label named 'col
    'col: while c < 10 {
        if c == 3 {
            break 'row;     // break from 'row, terminating the entire loop
        }
        if c == 4 {
            continue 'row;  // stop current 'col iteration and continue from 'row
        }
        if c == 5 {
            continue 'col;  // stop current 'col iteration and continue from 'col
        }
        c += 1;
    }
    r += 1;
}

while let

while let will continue looping as long as a pattern match is successful. The let portion of while let is similar to if let: it can be used to destructure data for utilization in the loop.

let mut maybe = Some(10);
// if `maybe` is a `Some`, bind the inner data to `value` and execute the loop
while let Some(value) = maybe {
    println!("{maybe:?}");
    if value == 1 {
        // loop will exit on next iteration
        // because the pattern match will fail
        maybe = None;
    } else {
        maybe = Some(value - 1);
    }
}

for

Rust's for loop is to iterate over collections that implement the Iterator trait.

// iterate through a collection
let numbers = vec![1, 2, 3];
for num in numbers {
    // values are moved into this loop
}

// .into_iter() is implicitly called when using `for`
let numbers = vec![1, 2, 3];
for num in numbers.into_iter() {
    // values are moved into this loop
}

// use .iter() to borrow the values
let numbers = vec![1, 2, 3];
for num in numbers.iter() {
    // &1
    // &2
    // &3
}

// ranges can be used to iterate over numbers
for i in 1..3 {     // exclusive range
    // 1
    // 2
}

loop

The loop keyword is used for infinite loops. Prefer using loop instead of while when you specifically want to loop endlessly.

loop { /* forever */ }

// loops can be labled
'outer: loop {
    'inner: loop {
        continue 'outer;    // immediately begin the next 'outer loop
        break 'inner;       // exit out of just the 'inner loop
    }
}

// loops are expressions
let mut iterations = 0;
let total = loop {
    iterations += 1;
    if iterations == 5 {
        // using `break` with a value will evaluate the loop
        break iterations;
    }
};
// total == 5

Structures

Structures allow data to be grouped into a single unit.

Click for more details

struct Foo;          // define a structure containing no data
let foo = Foo;       // create a new `Foo`

struct Dimension(i32, i32, i32);     // define a "tuple struct" containing 3 data points
let container = Dimension(1, 2, 3);  // create a new `Dimension`
let (w, d, h) = (container.0, container.1, container.2);
// w, d, h, now accessible

// define a structure containing two pieces of information
struct Baz {
    field_1: i32,   // an i32
    field_2: bool,  // a bool
}
// create a new `Baz`
let baz = Baz {
    field_1: 0,     // all fields must be defined
    field_2: true,
};

impl Blocks

impl blocks allow functionality to be associated with a structure or enumeration.

Click for more details

struct Bar {
    inner: bool,
}

// `impl` keyword to implement functionality
impl Bar {
    // `Self` is an alias for the name of the structure
    pub fn new() -> Self {
        // create a new `Bar`
        Self { inner: false }
    }
    // `pub` (public) functions are accessible outside the module
    pub fn make_bar() -> Bar {
        Bar { inner: false }
    }

    // use `&self` to borrow an instance of `Bar`
    fn is_true(&self) -> bool {
        self.inner
    }

    // use `&mut self` to mutably borrow an instance of `Bar`
    fn make_true(&mut self) {
        self.inner = true;
    }

    // use `self` to move data out of `Bar`
    fn into_inner(self) -> bool {
        // `Bar` will be destroyed after returning `self.inner`
        self.inner
    }
}

let mut bar = Bar::new();           // make a new `Bar`
bar.make_true();                    // change the inner value
assert_eq!(bar.is_true(), true);    // get the inner value
let value = bar.into_inner();       // move the inner value out of `Bar`

// `bar` was moved into `bar.into_inner()` and can no longer be used

Matching on Structures

Structures can be used within match expressions and all or some of a structure's values can be matched upon.

struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    // match when ...
    // ... x == 0 && y == 0
    Point { x: 0, y: 0 } => (),
    // ... x == 0 and then ignore y
    Point { x: 0, .. } => (),
    // ... y == 0 and then ignore x
    Point { y: 0, .. } => (),
    // ... x == 0 and then capture y while checking if y == 2; bind y
    Point { x: 0, y } if y == 2 => println!("{y}"),
    // ... the product of x and y is 100; bind x and y
    Point { x, y } if x * y == 100 => println!("({x},{y})"),
    // ... none of the above are satisfied; bind x and y
    Point { x, y } => println!("({x},{y})"),
    // ... none of the above are satisfied while also ignoring x and y
    // (this will never match because `Point {x, y}` matches everything)
    _ => (),
}

Destructuring Assignment

Destructuring assignment allows structure fields to be accessed based on patterns. Doing so moves data out of the structure.

struct Member {
    name: String,
    address: String,
    phone: String,
}

let m = Member {
    name: "foo".to_string(),
    address: "bar".to_string(),
    phone: "phone".to_string(),
};

// move `name` out of the structure; ignore the rest
let Member { name, .. } = m;
// move `name` out of the structure; bind to `id`; ignore the rest
let Member { name: id, .. } = m;
// move `name` out of the structure; bind to `id`
let id = m.name;

Enumerations

Rust enumerations can have multiple choices, called variants, with each variant optionally containing data. Enumerations can only represent one variant at a time and are useful for storing data based on different conditions. Example use cases include messages, options to functions, and different types of errors.

impl blocks can also be used on enumerations.

Click for more details

// a structure wrapping a usize which represents an error code
struct ErrorCode(usize);

// enumerations are created with the `enum` keyword
enum ProgramError {
    // a single variant
    EmptyInput,
    // a variant containing String data
    InvalidInput(String),
    // a variant containing a struct
    Code(ErrorCode),
}

// create one ProgramError of each variant
let empty = ProgramError::EmptyInput;
let invalid = ProgramError::InvalidInput(String::from("whoops!"));
let error_code = ProgramError::Code(ErrorCode(9));

Match on Enums

enum ProgramError {
    // a single variant
    EmptyInput,
    // a variant containing String data
    InvalidInput(String),
    // a variant containing a struct
    Code(ErrorCode),
}

let some_error: ProgramError = some_fallible_fn();

match some_error {
    // match on the ...
    // ... EmptyInput variant
    ProgramError::EmptyInput => (),
    // ... InvalidInput variant only when the String data is == "123"; bind `input`
    ProgramError::InvalidInput(input) if input == "123" => (),
    // ... InvalidInput variant containing any other String data not capture above; bind `input`
    ProgramError::InvalidInput(input) => (),
    // ... Code variant having an ErrorCode of 1
    ProgramError::Code(ErrorCode(1)) => (),
    // ... Code variant having any other ErrorCode not captured above; bind `other`
    ProgramError::Code(other) => (),
}

// enumeration variant names can be brought into scope with `use` ...
use ProgramError::*;
match some_error {
    // ... only need to specify the variant names now
    EmptyInput => (),
    InvalidInput(input) if input == "123" => (),
    InvalidInput(input) => (),
    Code(ErrorCode(1)) => (),
    Code(other) => (),
}

Tuples

Tuples offer a way to group unrelated data into an anonymous data type. Since tuples are anonymous, try to keep the number of elements limited to avoid ambiguities.

// create a new tuple named `tup` containing 4 pieces of data
let tup = ('a', 'b', 1, 2);
// tuple members are accessed by index
assert_eq!(tup.0, 'a');
assert_eq!(tup.1, 'b');
assert_eq!(tup.2, 1);
assert_eq!(tup.3, 2);

// tuples can be destructured into individual variables
let (a, b, one, two) = (tup.0, tup.1, tup.2, tup.3);
let (a, b, one, two) = ('a', 'b', 1, 2);
// a, b, one, two now can be used as individual variables

// tuple data types are just existing types surrounded by parentheses
fn double(point: (i32, i32)) -> (i32, i32) {
    (point.0 * 2, point.1 * 2)
}

Arrays

Arrays in Rust are fixed size. Most of the time you'll want to work with a slice or Vector, but arrays can be useful with fixed buffer sizes.

Click for more details

let array = [0; 3]; // array size 3, all elements initialized to 0
let array: [i32; 5] = [1, 2, 3, 4, 5];
let slice: &[i32] = &array[..];

Slices

Slices are views into a chunk of contiguous memory. They provide convenient high-performance operations for existing data.

Click for more details

let mut nums = vec![1, 2, 3, 4, 5];
let num_slice = &mut nums[..];  // make a slice out of the Vector
num_slice.first();              // Some(&1)
num_slice.last();               // Some(&5)
num_slice.reverse();            // &[5, 4, 3, 2, 1]
num_slice.sort();               // &[1, 2, 3, 4, 5]

// get a view of "chunks" having 2 elements each
let mut chunks = num_slice.chunks(2);
chunks.next(); // Some(&[1, 2])
chunks.next(); // Some(&[3, 4])
chunks.next(); // Some(&[5])

Slice Patterns

Slice patterns allow matching on slices given specific conditions while also ensuring no indexing errors occur.

let chars = vec!['A', 'B', 'C', 'D'];

// two ways to create a slice from a Vector
let char_slice = &chars[..];
let char_slice = chars.as_slice();

match char_slice {
    // match ...
    // ... the first and last element. minimum element count == 2
    [first, .., last] => println!("{first}, {last}"),
    // ... one and only one element
    [single] => println!("{single}"),
    // ... an empty slice
    [] => (),
}

match char_slice {
    // match ...
    // ... the first two elements. minimum elements == 2
    [one, two, ..] => println!("{one}, {two}"),
    // ... the last element. minimum elements == 1
    [.., last] => println!("{last}"),
    // ... an empty slice
    [] => (),
}

let nums = vec![7, 8, 9];
match nums.as_slice() {
    // match ...
    // First element only if element is == 1 or == 2 or == 3,
    // with remaining slice bound to `rest`. minimum elements == 1
    [first @ 1..=3, rest @ ..] => println!("{rest:?}"),
    // ... one element, only if == 5 or == 6
    [single] if single == &5 || single == &6 => (),
    // ... two and only two elements
    [a, b] => (),
    // Two-element slices are captured in the previous match 
    // arm, so this arm will match either:
    //   * One element
    //   * More than two elements
    [s @ ..] => println!("one element, or 2+ elements {s:?}"),
    // ... empty slice
    [] => (),
}

Option

Rust doesn't have the concept of null, but the Option type is a more powerful alternative. Existence of a value is Some and abscense of a value is None. Semantically, Option is used when there is the possibility of some data not existing, such as "no search results found".

Click for more details

// Option in the standard library is defined as a generic enumeration:
enum Option<T> {
    Some(T),    // data exists
    None,       // no data exists
}
// an Option's variants are available for use without specifying Option::Some / Option::None

// create an Option containing usize data
let maybe_number: Option<usize> = Some(1);
// add 1 to the data, but only if the option is `Some` (this is a no-op if it is `None`)
let plus_one: Option<usize> = maybe_number.map(|num| num + 1);

// `if let` can be used to access the inner value of an Option
if let Some(num) = maybe_number {
    // use `num`
} else {
    // we have `None`
}

// Options can be used with `match`
match maybe_number {
    // match when ...
    // ... there is some data and it is == 1
    Some(1) => (),
    // ... there is some data not covered above; bind the value to `n`
    Some(n) => (),
    // ... there is no data
    None => (),
}

// since `if let` is an expression, we can use it to conditionally destructure an Option
let msg = if let Some(num) = maybe_number {
    format!("We have a {num}")
} else {
    format!("We have None")
};
assert_eq!(msg, "We have a 1");

// combinators can be used to easily manipulate Options
let maybe_number = Some(3);
let odd_only = maybe_number      // take `maybe_number`
    .and_then(|n| Some(n * 3))   // then access the inner value, multiply by 3, and make a new Option
    .map(|n| n - 1)              // then take the inner value and subtract 1
    .filter(|n| n % 2 == 1)      // then if the inner value is odd, keep it
    .unwrap_or(1);               // then unwrap the inner value if it exists; otherwise use 1
assert_eq!(odd_only, 1);

// same as above but with named functions instead of inline closures
let maybe_number = Some(4);
let odd_only = maybe_number      // take `maybe_number`
    .and_then(triple)            // then run the `triple` function with the inner value
    .map(minus_one)              // then transform the inner value with the `minus_one` function
    .filter(is_odd)              // then filter the value using the `is_odd` function
    .unwrap_or(1);               // then unwrap the inner value if it exists; otherwise use 1
assert_eq!(odd_only, 11);

fn triple(n: i32) -> Option<i32> {
    Some(n * 3)
}

fn minus_one(n: i32) -> i32 {
    n - 1
}

fn is_odd(n: &i32) -> bool {
    n % 2 == 1
}

Result / Error Handling

Rust doesn't have exceptions. All errors are handled using a return value and the Result type. Helper crates are available to automatically generate errors and make propagation easier:

    anyhow / eyre / miette: use in binary projects to easily propagate any type of error
    thiserror: use in library projects to easily create specific error types

Click for more details

// Result in the standard library is defined as a generic enumeration:
enum Result<T, E> {
    Ok(T),      // operation succeeded
    Err(E),     // operation failed
}
// a Results's variants are available for use without specifying Result::Ok / Result::Err

// create a Result having a success type of i32 and an error type of String
let maybe_number: Result<i32, String> = Ok(11);

// Combinators can be used to easily manipulate Results. The following sequence
// transformed the inner value by multiplying it by 3 if it is an Ok. If
// `maybe_number` is an Err then the error returned will be the supplied String.
let maybe_number = maybe_number
    .map(|n| n * 3)
    .map_err(|e| String::from("don't have a number"));

// We can use `if let` to conditionally destructure a Result.
// Here we are specifically looking for an error to report.
if let Err(e) = maybe_number.as_ref() {
    eprintln!("error: {e}");
}

// Results and Options can be changed back and forth using `.ok`
let odd_only = maybe_number      // take `maybe_number`
    .ok()                        // transform it into an Option
    .filter(|n| n % 2 == 1)      // apply a filter
    .ok_or_else(||               // transform the Option back into a Result
        String::from("not odd!") // if the Option is None, use this String for the Err
    );

// `match` is commonly used when working with Results
match odd_only {
    Ok(odd) => println!("odd number: {odd}"),
    Err(e) => eprintln!("error: {e}"),
}

Question Mark Operator

Results can be verbose and cumbersome to use when there are multiple failure points. The question mark operator (?) makes Result easier to work with by doing one of two things:

    if Ok: unwrap the value
    if Err: map the error to the specified Err return type and then return from the function

use std::error::Error;
use std::fs::File;
use std::io::{self, Read};
use std::path::Path;

// This function has 3 failure points and uses the question mark operator
// to automatically propagate appropriate errors.
fn read_num_using_questionmark(path: &Path) -> Result<u8, Box<dyn Error>> {
    // make a buffer
    let mut buffer = String::new();

    // Using the `?` will automatically give us an open file on
    // success, and automatically return a `Box<dyn Error>` on failure.
    let mut file = File::open(path)?;

    // We aren't concerned about the return value for this function, 
    // however we still need to handle the error with question mark.
    file.read_to_string(&mut buffer)?;

    // remove any whitespace
    let buffer = buffer.trim();

    // We wrap this function call in an `Ok` because `?` will
    // automatically unwrap an `Ok` variant, but our function
    // signature requires a `Result`.
    Ok(u8::from_str_radix(buffer, 10)?)
}

// Same function as above, but without using question mark.
// This function also demonstrates different error handling strategies.
fn read_num_no_questionmark(path: &Path) -> Result<u8, Box<dyn Error>> {
    // make a buffer
    let mut buffer = String::new();

    // possible error when opening file (type annotation shown for clarity)
    let file: Result<File, io::Error> = File::open(path);

    // match on `file` to see what happened
    match file {
        // when open was successful ...
        Ok(mut file) => {
            // ... read data into a buffer ...
            if let Err(e) = file.read_to_string(&mut buffer) {
                // ... if that fails, return a boxed Err
                return Err(Box::new(e));
            }
        }
        // failed to open file, return `dyn Error` using `.into()`
        Err(e) => return Err(e.into()),
    }

    // remove any whitespace (yay no failure point!)
    let buffer = buffer.trim();

    // convert to u8 while manually mapping a possible conversion error
    u8::from_str_radix(buffer, 10).map_err(|e| e.into())
}

// calling the function is the same regardless of technique chosen
let num: Result<u8, _> = read_num_using_questionmark(Path::new("num.txt"));
if num.is_ok() {        // `.is_ok` will tell us if we have an Ok variant
    println!("number was successfully read");
}

// use some combinators on the result
let num = num             // take `num`
    .map(|n| n + 1)       // map an `Ok` variant by adding 1 to the value
    .ok()                 // transform to an `Option`
    .and_then(|n|         // and then ...
        n.checked_mul(2)  // double the inner value (this returns an Option)
    )
    .ok_or_else(||        // transform back into `Result` ...
        // ... using this error message if the multiplication failed
        format!("doubling exceeds size of u8")
    );

// use `match` to print out the result on an appropriate output stream
match num {
    Ok(n) => println!("{n}"),
    Err(e) => eprintln!("{e}"),
}


The From trait can also be utilized with errors and the question mark operator:

// a target error type
enum JobError {
    Expired,
    Missing,
    Other(u8),
}

// similar implementation from previous example
impl From<u8> for JobError {
    fn from(code: u8) -> Self {
        match code {
            1 => Self::Expired,
            2 => Self::Missing,
            c => Self::Other(c),
        }
    }
}

// arbitrary structure
struct Job;

impl Job {
    // function that returns an error code as u8
    fn whoops(&self) -> Result<(), u8> {
        Err(2)
    }
}
// function potentially returns a JobError
fn execute_job(job: Job) -> Result<(), JobError> {
    // use question mark to convert potential errors into a JobError
    Ok(job.whoops()?)
}

let status = execute_job(Job); // JobError::Missing

Iterator

The Iterator trait provides a large amount of functionality for iterating over collections using combinators.

Click for more details

// create a new vector ...
let nums = vec![1, 2, 3, 4, 5];
// ... then turn it into an iterator and multiply each element by 3 ...
let tripled = nums.iter().map(|n| n * 3);
// ... then filter out all the even numbers ...
let odds_only = tripled.filter(|n| n % 2 == 1);
// ... and finally collect the odd numbers into a new Vector
let new_vec: Vec<i32> = odds_only.collect();    // type annotation required

// same steps as above, but chaining it all together:
// create a new Vector
let nums = vec![1, 2, 3, 4, 5];
let tripled_odds_only = nums    // take the `nums` vector
    .iter()                     // then turn it into an iterator
    .filter_map(|n| {           // then perform a filter and map operation on each element
        let n = n * 3;          // multiply the element by 3
        if n % 2 == 1 {
            Some(n)             // keep if odd
        } else {
            None                // discard if even
        }
    })
    .collect::<Vec<i32>>();     // collect the remaining numbers into a Vector

// This example takes a vector of (x,y) points where all even indexes
// are the x-coordinates, and all odd indexes are y-coordinates and
// creates an iterator over tuples of the points.

// Points Vector: x, y, x, y, x, y, x, y, x, y 
let points = vec![0, 0, 2, 1, 4, 3, 6, 5, 8, 7];

// `step_by` will skip every other index; iteration starts at index 0
let x = points.iter().step_by(2);

// use `skip` to skip 1 element so we start at index 1
// then skip every other index starting from index 1
let y = points.iter().skip(1).step_by(2);

// `zip` takes two iterators and generates a new one by taking
// alternating elements from each iterator. `enumerate` provides
// the iteration count as an index
let points = x.zip(y).enumerate();
for (i, point) in points {
    println!("{i}: {point:?}");
    // 0: (0, 0)
    // 1: (2, 1)
    // 2: (4, 3)
    // 3: (6, 5)
    // 4: (8, 7)
}

// create a new Vector
let nums = vec![1, 2, 3];
let sum = nums      // take `nums`
    .iter()         // create an iterator
    .sum::<i32>();  // add all elements together and return an i32
assert_eq!(sum, 6);

Ownership & Borrowing

All data in Rust is owned by some data structure or some function and the data can be borrowed by other functions or other data structures. This system enables compile-time tracking of how long data lives which in turn enables compile-time memory management without runtime overhead.

Click for more details

// borrow a str
fn print(msg: &str) {
    println!("{msg}");
}

// borrow a str, return a slice of the borrowed str
fn trim(msg: &str) -> &str {
    msg.trim()
}

// borrow a str, return an owned String
fn all_caps(msg: &str) -> String {
    msg.to_ascii_uppercase()
}

// function takes ownership of `msg` and is responsible
// for destroying it
fn move_me(msg: String) {
    println!("{msg}");
    // `msg` destroyed
}

// borrow "foo"
print("foo");

// borrow " bar "; return a new slice
let trimmed: &str = trim(" bar ");      // "bar"

// borrow "baz"; return a new String
let cruise_control: String = all_caps("baz");   // "BAZ"

// create owned String
let foo: String = String::from("foo");
// Move the String (foo) into move_me function.
// The `move_me` function will destroy `foo` since
// ownership was transferred.
let moved = move_me(foo);

// `foo` no longer exists
// println!("{foo}");
// ERROR: `foo` was moved into `move_me`

Lifetimes

Lifetimes allow specifying to the compiler that some data already exists. This allows creation of structures containing borrowed data or to return borrowed data from a function.

Click for more details

// Use lifetimes to indicate borrowed data stored in structures.
// Both structures and enumerations can have multiple lifetimes.
struct Email<'a, 'b> {
    subject: &'a str,
    body: &'b str,
}

let sample_subject = String::from("cheat sheet");
let sample_body = String::from("lots of code");
// `sample_subject` and `sample_body` are required to stay in memory
// as long as `email` exists.
let email = Email {
    subject: &sample_subject,
    body: &sample_body,
};

// dbg!(sample_subject);
// dbg!(email);
// ERROR: cannot move `sample_subject` into dbg macro because
//        `email` still needs it

// Lifetime 'a indicates borrowed data stored in the enum.
// The compiler uses 'a to enforce the following:
//  1. &str data must exist prior to creating a `StrCompare`
//  2. &str data must still exist after destruction of `StrCompare`
#[derive(Debug)]
enum StrCompare<'a> {
    Equal,
    Longest(&'a str),
}

// determine which &str is longer
// Lifetime annotations indicate that both `a` and `b` are
// borrowed and they will both exist for the same amount of time.
fn longest<'s>(a: &'s str, b: &'s str) -> StrCompare<'s> {
    if a.len() > b.len() {
        StrCompare::Longest(a)
    } else if a.len() < b.len() {
        StrCompare::Longest(b)
    } else {
        StrCompare::Equal
    }
}

// ERROR: the following block will not compile (see comments)

// new scope: lifetime (1)
{
    let a = String::from("abc");       // lifetime (1)
    let longstring: StrCompare;        // lifetime (1)

    // new scope: lifetime (2)
    {
        let b = String::from("1234"); // lifetime (2)
        longstring = longest(&a, &b);
        // end scope; lifetime (2) data dropped (destroyed):
        // `b` no longer exists
    }

    // `b` was previously dropped, but might still be needed here
    // as part of the `StrCompare` enumeration
    println!("{longstring:?}");     // ERROR: `b` doesn't live long enough

    // lifetime (1) data dropped in reverse creation order:
    // `longstring` no longer exists
    // `a` no longer exists
}

// FIXED: `a` and `b` now have same lifetime

// new scope: lifetime (1)
{
    let a = String::from("abc");       // lifetime (1)
    let b = String::from("1234");      // lifetime (1)
    let longstring = longest(&a, &b);  // lifetime (1)
    println!("{longstring:?}");

    // lifetime (1) data dropped in reverse creation order:
    // `longstring` dropped
    // `b` dropped
    // `a` dropped
}

Traits

Traits declare behavior that may be implemented by any structures or enumerations. Traits are similar to interfaces in other programming languages.

Click for more details

// create a new trait
trait Notify {
    // implementers must define this function
    fn notify(&self) -> &str;
}

struct Phone {
    txt: String,
}

struct Email {
    subject: String,
    body: String,
}

// implement the `Notify` trait for the `Phone` struct
impl Notify for Phone {
    fn notify(&self) -> &str {
        &self.txt
    }
}

// implement the `Notify` trait for the `Email` struct
impl Notify for Email {
    fn notify(&self) -> &str {
        &self.subject
    }
}

// create a new Phone
let phone = Phone {
    txt: String::from("foo"),
};

// create a new Email
let email = Email {
    subject: String::from("my email"),
    body: String::from("bar"),
};

phone.notify();     // "foo"
email.notify();     // "bar"

Associated Types

Associated types allow trait implementers to easily set a specific type for use in a trait.

Click for more details

trait Compute {
    // associated type to be defined by an implementer
    type Target;
    // use Self::Target to refer to the associated type
    fn compute(&self, rhs: Self::Target) -> Self::Target;
}

struct Add(i32);
struct Sub(f32);

impl Compute for Add {
    // set the associated type to i32
    type Target = i32;
    fn compute(&self, rhs: Self::Target) -> Self::Target {
        self.0 + rhs
    }
}

impl Compute for Sub {
    // set the associated type to f32
    type Target = f32;
    fn compute(&self, rhs: Self::Target) -> Self::Target {
        self.0 - rhs
    }
}

let add = Add(1);
let two = add.compute(1);
let sub = Sub(1.0);
let zero = sub.compute(1.0);

Trait Objects

Trait objects can be used to insert multiple objects of different types into a single collection. They are also useful when boxing closures or working with unsized types.

Click for more details

// create a trait to refill some resource
trait Refill {
    fn refill(&mut self);
}

// some structures to work with
struct Player { health_points: i32 }
struct MagicWand { magic_points: i32 }
struct Vehicle { fuel_remaining: i32 }

// set the maximum values for the structures
impl Player { const MAX_HEALTH: i32 = 100; }
impl MagicWand { const MAX_MAGIC: i32 = 100; }
impl Vehicle { const MAX_FUEL: i32 = 300; }

// trait implementations for all 3 structures
impl Refill for Player {
    fn refill(&mut self) {
        self.health_points = Self::MAX_HEALTH;
    }
}
impl Refill for MagicWand {
    fn refill(&mut self) {
        self.magic_points = Self::MAX_MAGIC;
    }
}
impl Refill for Vehicle {
    fn refill(&mut self) {
        self.fuel_remaining = Self::MAX_FUEL;
    }
}

// instantiate some structures
let player = Player { health_points: 50 };
let wand = MagicWand { magic_points: 30 };
let vehicle = Vehicle { fuel_remaining: 0 };

// let objects = vec![player, wand, vehicle];
// ERROR: cannot have a Vector containing different types

// Type annotation is required here. `dyn` keyword indicates
// "dynamic dispatch" and is also required for trait objects.
let mut objects: Vec<Box<dyn Refill>> =
    vec![
        Box::new(player),                 // must be boxed
        Box::new(wand),
        Box::new(vehicle)
    ];

// iterate over the collection and refill all of the resources
for obj in objects.iter_mut() {
    obj.refill();
}

Default

The Default trait allows a default version of a structure to be easily created.

Click for more details

struct Foo {
    a: usize,
    b: usize,
}

// Default is available without `use`
impl Default for Foo {
    fn default() -> Self {
        Self { a: 0, b: 0 }
    }
}

// make a new Foo
let foo = Foo::default();

// make a new Foo with specific values set
// and use default values for the rest
let foo = Foo {
    a: 10,
    ..Default::default() // b: 0
};

// we might have a Foo ...
let maybe_foo: Option<Foo> = None;
// ... if not, use the default one
let definitely_foo = maybe_foo.unwrap_or_default();

From / Into

From and Into traits allow non-fallible conversion between different types. If the conversion can fail, the TryFrom and TryInto traits will perform fallible conversions. Always prefer implementing From because it will automatically give you an implementation of Into.

Click for more details on From

Click for more details on TryFrom

// this will be our target type
enum Status {
    Broken(u8),
    Working,
}

// we want to convert from a `u8` into a `Status`
impl From<u8> for Status {
    // function parameter must be the starting type
    fn from(code: u8) -> Self {
        match code {
            // pick a variant based on the code
            0 => Status::Working,
            c => Status::Broken(code),
        }
    }
}

// use `.into()` to convert the `u8` into a Status
let status: Status = 0.into();  // Status::Working
// use `Status::from()` to convert from a `u8` into a Status
let status = Status::from(1);   // Status::Broken(1)

Generics

Rust data structures and functions only operate on a single data type. Generics provide a way to automatically generate duplicated functions and data structures appropriate for the data types in use.

Click for more details

// Here we define a structure generic over type T.
// T has no trait bounds, so any type can be used here.
struct MyVec<T> {
    inner: Vec<T>,     // Vector of type T
}

// define a structure generic over type T where
// type T implements the Debug trait
struct MyVec<T: std::fmt::Debug> {
    inner: Vec<T>,
}

// define a structure generic over type T where
// type T implements both the Debug and Display traits
struct MyVec<T>
where
    T: std::fmt::Debug + std::fmt::Display,
{
    inner: Vec<T>,
}

// create a new MyVec having type `usize`
let nums: MyVec<usize> = MyVec { inner: vec![1, 2, 3] };

// create a new MyVec with type inference
let nums = MyVec { inner: vec![1, 2, 3] };

// let nums = MyVec { inner: vec![] };
// ERROR: type annotations required because no inner data type provided

let nums: MyVec<String> = MyVec { inner: vec![] };
// OK using type annotations

// use the `Add` trait
use std::ops::Add;
// pub trait Add<Rhs = Self> {
//     type Output;
//     fn add(self, rhs: Rhs) -> Self::Output;
// }

// Here we define a function that is generic over type T.
// Type T has the following properties:
//   - Must implement the `Add` trait
//   - The associated type `Output` must
//     be the same type T
fn sum<T: Add<Output = T>>(lhs: T, rhs: T) -> T {
    lhs + rhs
}
let two = sum(1, 1);              // call the function
let two = sum::<f64>(1.0, 1.0);   // fully-qualified syntax

// let four_ish = sum(2, 2.0);
// ERROR: 2 is an integer and 2.0 is a floating point number,
//        but the generic function requires both types be the same

Operator Overloading

Rust enables developers to overload existing operators. The operators are defined as traits in the link below.

Click for more details, and a list of all operators

// the `Add` trait is used for the `+` operator
use std::ops::Add;

struct Centimeters(f64);

// implement Add for Centimeters + Centimeters
impl Add<Self> for Centimeters {
    // Self (capital S) refers to the type specified
    // in the `impl` block (Centimeters)
    type Output = Self;

    // self (lowercase S) refers to an instance of Centimeters.
    // Using `Self` makes it easier to change the types
    // later if needed.
    fn add(self, rhs: Self) -> Self::Output {
        Self(self.0 + rhs.0)
    }

    // equivalent to the above
    fn add(self, rhs: Centimeters) -> Centimeters {
        Centimeters(self.0 + rhs.0)
    }

}

fn add_distance(a: Centimeters, b: Centimeters) -> Centimeters {
    // When `+` is used, it calls the `add` function
    // defined as part of the `Add` trait. Since we already
    // access the inner value using .0 in the trait, we can
    // just do a + b here.
    a + b
}

let length = Centimeters(20.0);
let distance = add_distance(length, Centimeters(10.0));

Index

The Index trait is used for indexing operations. Implementing this trait on a structure permits accessing it's fields using indexing.

Click for more details

// the `Index` trait is used for indexing operations `[]`
use std::ops::Index;

// this will be our index
enum Temp {
    Current,
    Max,
    Min,
}

// sample structure to be indexed into
struct Hvac {
    current_temp: f64,
    max_temp: f64,
    min_temp: f64,
}

// implement Index where the index is Temp and the structure is Hvac
impl Index<Temp> for Hvac {
    // output type matches the data we will return from the structure
    type Output = f64;

    // `index` function parameter must be the type to be
    // used as an index
    fn index(&self, temp: Temp) -> &Self::Output {
        use Temp::*;    // use the variants for shorter code
        match temp {
            // now just access the structure fields
            // based on provided variant
            Current => &self.current_temp,
            Max => &self.max_temp,
            Min => &self.min_temp,
        }
    }
}

// create a new Hvac
let env = Hvac {
    current_temp: 30.0,
    max_temp: 60.0,
    min_temp: 0.0,
};
// get the current temperature using an Index
let current = env[Temp::Current];
// get the max temperature using an Index
let max = env[Temp::Max];

Concurrent Programming

Rust provides multiple techniques to approach concurrent programming. Computation-heavy workloads can use OS threads while idle workloads can use asynchronous programming. Concurrent-aware types and data structures allow wrapping existing structures which enables them to be utilized in a concurrent context.
Threads

Rust provides the ability to create OS threads via the std::thread module. Any number of threads can be created, however performance will be optimal when using the same number of thread as there are processing cores in the system.

Click for more details

use std::thread::{self, JoinHandle};

// The thread::spawn function will create a new thread and return
// a `JoinHandle` type that can be used to wait for this thread
// to finish working.
let thread_1 = thread::spawn(|| {});

// JoinHandle is generic over the return type from the thread
let thread_2: JoinHandle<usize> = thread::spawn(|| 1);

// wait for both threads to finish work
thread_1.join();
thread_2.join();

Channels

Channels provide a way to communicate between two points and are used for transferring data between threads. They have two ends: a sender and a receiver. The sender is used to send/write data into the channel, and the receiver is used to receive/read data out of the channel.

Click for more details

// The crossbeam_channel crate provides better performance
// and ergonomics compared to the standard library.
use crossbeam_channel::unbounded;

// create a channel with unlimited capacity
let (sender, receiver) = unbounded();

// data can be "sent" on the `sender` end
// and "received" on the `receiver` end
sender.send("Hello, channel!").unwrap();

// use `.recv` to read a message
match receiver.recv() {
    Ok(msg) => println!("{msg}"),
    Err(e) => println!("{e}"),
}


Using channels with threads:

// The crossbeam_channel crate provides better performance
// and ergonomics compared to the standard library.
use crossbeam_channel::unbounded;
use std::thread;

// create a channel with unlimited capacity
let (sender, receiver) = unbounded();

// clone the receiving ends so they can be sent to different threads
let (r1, r2) = (receiver.clone(), receiver.clone());

// move `r1` into this thread with the `move` keyword
let thread_1 = thread::spawn(move || match r1.recv() {
    Ok(msg) => println!("thread 1 msg: {msg}"),
    Err(e) => eprintln!("thread 1 error: {e}"),
});

// move `r2` into this thread with the `move` keyword
let thread_2 = thread::spawn(move || match r2.recv() {
    Ok(msg) => println!("thread 2 msg: {msg}"),
    Err(e) => eprintln!("thread 2 error: {e}"),
});

// send 2 messages into the channel
sender.send("Hello 1").unwrap();
sender.send("Hello 2").unwrap();

// wait for the threads to finish
thread_1.join();
thread_2.join();

Mutex

Mutex (short for mutually exclusive) allows data to be shared across multiple threads by using a locking mechanism. When a thread locks the Mutex, it will have exclusive access to the underlying data. Once processing is completed, the Mutex is unlocked and other threads will be able to access it.

Click for more details

// The parking_lot crate provides better performance
// and ergonomics compared to the standard library.
use parking_lot::Mutex;
// `Arc` is short for Atomic reference-counted pointer
// (thread safe pointer)
use std::sync::Arc;
use std::thread;

// data we will share between threads
struct Counter(usize);

// make a new Counter starting from 0
let counter = Counter(0);
// wrap the counter in a Mutex and wrap the Mutex in an Arc
let shared_counter = Arc::new(Mutex::new(counter));

// make some copies of the pointer:
// recommended syntax - clear to see that we are cloning a pointer (Arc)
let thread_1_counter = Arc::clone(&shared_counter);
// ok too, but not as clear as above; shared_counter could be anything
let thread_2_counter = shared_counter.clone();

// spawn a thread
let thread_1 = thread::spawn(move || {
    // lock the counter so we can access it
    let mut counter = thread_1_counter.lock();
    counter.0 += 1;
    // lock is automatically unlocked when dropped
});

let thread_2 = thread::spawn(move || {
    // new scopes can be introduced to drop the lock ...
    {
        let mut counter = thread_2_counter.lock();
        counter.0 += 1;
        // ... lock automatically unlocked
    }
    let mut counter = thread_2_counter.lock();
    counter.0 += 1;
    // we can also call `drop()` directly to unlock
    drop(counter);
});

// wait for threads to finish
thread_1.join();
thread_2.join();
// counter is now at 3
assert_eq!(shared_counter.lock().0, 3);

Async

Rust's asynchronous programming consists of two parts:

    A future which represents an asynchronous operation that should be ran
    An executor (or runtime) which is responsible for managing and running futures (as tasks)

There are async versions of many existing structures:

    streams (iterators)
    adapters (combinators)
    channels
    mutex

Click for more details

// Use the `futures` crate and `FutureExt` when working with async.
// `FutureExt` provides combinators similar to `Option` and `Result`
use futures::future::{self, FutureExt};

// asynchronous functions start with the `async` keyword
async fn add_one(n: usize) -> usize {
    n + 1
}

// the `tokio` crate provides a commonly used executor
#[tokio::main]
async fn main() {
    // async functions are lazy--no computation happens yet

    let one = async { 1 };          // inline future
    let two = one.map(|n| n + 1);   // add 1 to the future

    let three = async { 3 };        // inline future
    let four = three.then(add_one); // run async function on future

    // `join` will wait on both futures to complete.
    // `.await` begins execution of the futures.
    let result = future::join(two, four).await;

    assert_eq!(result, (2, 4))
}


Streams provide Iterator-like functionality to asynchronous streams of values.

// Use the `futures` crate when working with async.
use futures::future;

// `StreamExt` provides combinators similar to `Iterator`
use futures::stream::{self, StreamExt};

// the `tokio` crate provides a commonly used executor
#[tokio::main]
async fn main() {
    let nums = vec![1, 2, 3, 4];
    // create a stream from the Vector
    let num_stream = stream::iter(nums);

    let new_nums = num_stream            // take num_stream
        .map(|n| n * 3)                  // multiply each value by 3
        .filter(|n|                      // filter ...
            future::ready(n % 2 == 0)    // ... only take even numbers
        )
        .then(|n| async move { n + 1 })  // run async function on each value
        .collect::<Vec<_>>().await;      // collect into a Vector

    assert_eq!(new_nums, vec![7, 13]);

    stream::iter(vec![1, 2, 3, 4])
        .for_each_concurrent(          // perform some action concurrently
            2,                         // maximum number of in-flight tasks
            |n| async move {           // action to take
                // some potentially
                // async code here
            }
        ).await;                       // run on the executor
}

Modules

Code in Rust is organized into modules. Modules can be created inline with code, or using the filesystem where each file is a module or each directory is a module (containing more files).

Modules are accessed as paths starting either from the root or from the current module. This applies to both inline modules and modules as separate files.

Click for more details
Inline Modules

// private module: only accessible within the same scope (file / module)
mod sample {
    // bring an inner module to this scope
    pub use public_fn as inner_public_fn;   // rename to inner_public_fn

    // default: private
    fn private_fn() {}

    // public to parent module
    pub fn public_fn() {}

    // public interface to private_fn
    pub fn public_interface() {
        private_fn();            // sample::private_fn
        inner::limited_super();
        inner::limited_module();
    }

    // public module: accessible via `sample`
    pub mod inner {
        fn private_fn() {}

        pub fn public_fn() {}

        pub fn public_interface() {
            private_fn();               // inner::private_fn

            super::hidden::public_fn(); // `inner` and `hidden` are in
                                        // the same scope, so this is Ok.
        }

        // public only to the immediate parent module
        pub(super) fn limited_super() {}

        // public only to the specified ancestor module
        pub(in crate::sample) fn limited_module() {}

        // public to the entire crate
        pub(crate) fn limited_crate() {}
    }

    // private module: can only be accessed by `sample`
    mod hidden {
        fn private_fn() {}

        pub fn public_fn() {}

        pub fn public_interface() {
            private_fn()    // hidden::private_fn
        }

        // It's not possible to access module `sample::hidden` from outside of
        // `sample`, so `fn limited_crate` is public only to the `sample`
        // module.
        pub(crate) fn limited_crate() {}
    }
}

fn main() {
    // functions can be accessed by their path
    sample::public_fn();
    sample::public_interface();
    sample::inner_public_fn();         // sample::inner::public_fn

    // ERROR: private_fn() is private
    // sample::private_fn();

    // nested modules can be accessed by their path
    sample::inner::public_fn();
    sample::inner::public_interface();
    sample::inner::limited_crate();

    // ERROR: private_fn() is private
    // sample::inner::private_fn();

    // ERROR: limited_super() is only public within `sample`
    // sample::inner::limited_super();

    // ERROR: limited_module() is only public within `sample`
    // sample::inner::limited_module();

    // ERROR: `hidden` module is private
    // sample::hidden::private_fn();

    // ERROR: `hidden` module is private
    // sample::hidden::public_fn();

    // ERROR: `hidden` module is private
    // sample::hidden::public_interface();

    // `use` brings specific items into scope
    {
        // a single function
        use sample::public_fn;
        public_fn();

        // begin path from crate root
        use crate::sample::public_interface;
        public_interface();

        // rename an item
        use sample::inner::public_fn as other_public_fn;
        other_public_fn();
    }
    {
        // multiple items from a single module
        use sample::{public_fn, public_interface};
        public_fn();
        public_interface();
    }
    {
        // `self` in this context refers to the `inner` module
        use sample::inner::{self, public_fn};
        public_fn();
        inner::public_interface();
    }
    {
        // bring everything from `sample` into this scope
        use sample::*;
        public_fn();
        public_interface();
        inner::public_fn();
        inner::public_interface();
    }
    {
        // paths can be combined
        use sample::{
            public_fn,
            inner::public_fn as other_public_fn
        };
        public_fn();        // sample::public_fn
        other_public_fn()   // inner::public_fn
    }
}

Modules as Files

Cargo.toml

[lib]
name = "sample"
path = "lib/sample.rs"

Module directory structure

.
|-- lib
    |-- sample.rs
    |-- file.rs
    |-- dir/
        |-- mod.rs
        |-- public.rs
        |-- hidden.rs


./lib/sample.rs: this is the path indicated by path in Cargo.toml

// a module in a single file named `file.rs`
pub mod file;

// a module in a directory named `dir`
pub mod dir;

// functions / enums / structs / etc can be defined here also
pub fn foo() {}


./lib/file.rs

pub fn foo() {}


A file named mod.rs is required when creating a module from a directory. This file specifies item visibility and specifies additional modules.

./lib/dir/mod.rs:

// a module in a single file named `hidden.rs`
mod hidden;

// a module in a single file named `public.rs`
pub mod public;

pub fn foo() {}


./lib/dir/hidden.rs

pub fn foo() {}


./lib/dir/public.rs

pub fn foo() {}


./src/main.rs

fn main() {
    sample::file::foo();
    sample::dir::public::foo();
    sample::dir::foo();
    // ERROR: `hidden` module not marked as `pub`
    // sample::dir::hidden::foo();
}

Testing

Rust supports testing both private and public functions and will also test examples present in documentation.

Click for more details
Test Module

Using a dedicated test module within each file for testing is common:

use std::borrow::Cow;

// a function to test
fn capitalize_first_letter<'a>(input: &'a str) -> Cow<'a, str> {
    use unicode_segmentation::UnicodeSegmentation;
    // do nothing if the string is empty
    if input.is_empty() {
        Cow::Borrowed(input)
    } else {
        let graphemes = input.graphemes(true).collect::<Vec<&str>>();
        if graphemes.len() >= 1 {
            let first = graphemes[0];
            let capitalized = first.to_uppercase();
            let remainder = graphemes[1..]
                .iter()
                .map(|s| s.to_owned())
                .collect::<String>();
            Cow::Owned(format!("{capitalized}{remainder}"))
        } else {
            Cow::Borrowed(input)
        }
    }
}

// another function to test
fn is_local_phone_number(num: &str) -> bool {
    use regex::Regex;
    let re = Regex::new(r"[0-9]{3}-[0-9]{4}").unwrap();
    re.is_match(num)
}

// Use the `test` configuration option to only compile the `test` module
// when running `cargo test`.
#[cfg(test)]
mod test {
    // scoping rules require us to use whichever functions we are testing
    use super::{is_local_phone_number, capitalize_first_letter};

    // use the #[test] annotation to mark the function as a test
    #[test]
    fn accepts_valid_numbers() {
        // assert! will check if the value is true, and panic otherwise.
        // Test failure is marked by a panic in the test function.
        assert!(is_local_phone_number("123-4567"));
    }

    #[test]
    fn rejects_invalid_numbers() {
        // we can use multiple assert! invocations
        assert!(!is_local_phone_number("123-567"));
        assert!(!is_local_phone_number("12-4567"));
        assert!(!is_local_phone_number("-567"));
        assert!(!is_local_phone_number("-"));
        assert!(!is_local_phone_number("1234567"));
        assert!(!is_local_phone_number("one-four"));
    }

    #[test]
    fn rejects_invalid_numbers_alternate() {
        // We can also put the test data into a Vector
        // and perform the assert! in a loop.
        let invalid_numbers = vec![
            "123-567",
            "12-4567",
            "-567",
            "-",
            "1234567",
            "one-four",
        ];
        for num in invalid_numbers.iter() {
            assert!(!is_local_phone_number(num));
        }
    }

    #[test]
    fn capitalizes_first_letter_with_multiple_letter_input() {
        let result = capitalize_first_letter("test");
        // assert_eq! will check if the left value is
        // equal to the right value
        assert_eq!(result, String::from("Test"));
    }

    #[test]
    fn capitalizes_first_letter_with_one_letter_input() {
        let result = capitalize_first_letter("t");
        assert_eq!(result, String::from("T"));
    }

    #[test]
    fn capitalize_only_letters() {
        let data = vec![
            ("3test", "3test"),
            (".test", ".test"),
            ("-test", "-test"),
            (" test", " test"),
        ];
        for (input, expected) in data.iter() {
            let result = capitalize_first_letter(input);
            assert_eq!(result, *expected);
        }
    }
}

Doctests

Rust tests example code present in documentation. This happens automatically when running cargo test, but will only operate on library projects.

Click for more details

use std::borrow::Cow;
/// Capitalizes the first letter of the input `&str`.
///
/// Only capitalizes the first letter when it appears as the first character
/// of the input. If the first letter of the input `&str` is not a letter
/// that can be capitalized (such as a number or symbol), then no change will occur.
/// 
/// # Examples
/// 
/// All code examples here will be tested. Lines within the code
/// fence that begin with a hash (#) will be hidden in the docs.
/// 
/// ```
/// # use crate_name::capitalize_first_letter;
/// let hello = capitalize_first_letter("hello");
/// assert_eq!(hello, "Hello");
/// ```
fn capitalize_first_letter<'a>(input: &'a str) -> Cow<'a, str> {
    use unicode_segmentation::UnicodeSegmentation;
    // do nothing if the string is empty
    if input.is_empty() {
        Cow::Borrowed(input)
    } else {
        let graphemes = input.graphemes(true).collect::<Vec<&str>>();
        if graphemes.len() >= 1 {
            let first = graphemes[0];
            let capitalized = first.to_uppercase();
            let remainder = graphemes[1..].iter().map(|s| s.to_owned()).collect::<String>();
            Cow::Owned(format!("{capitalized}{remainder}"))
        } else {
            Cow::Borrowed(input)
        }
    }
}

Standard Library Macros

The standard library provides convenient macros for performing various tasks. A subset is listed below.

Click for more details
Macro 	Description
assert 	Checks if a boolean is true at runtime and panics if false.
assert_eq 	Checks if two expressions are equal at runtime and panics if not.
dbg 	Prints debugging information for the given expression.
env 	Inserts data from an environment variable at compile time.
println 	Format and print information (with a newline) to the terminal on stdout.
eprintln 	Format and print information (with a newline) to the terminal on stderr.
print 	Format and print information (with no newline) to the terminal on stdout.
eprint 	Format and print information (with no newline) to the terminal on stderr.
format 	Format information and return a new String.
include_str 	Include data from a file as a 'static str at compile time.
include_bytes 	Include data from a file as a byte array at compile time.
panic 	Triggers a panic on the current thread.
todo 	Indicates unfinished code; will panic if executed. Will type-check properly during compilation.
unimplemented 	Indicates code that is not implemented and with no immediate plans to implement; will panic if executed. Will type-check properly during compilation.
unreachable 	Indicates code that should never be executed. Use when compiler is unable to make this determination. Will type-check properly during compilation.
vec 	Create a new Vector.
Standard Library Derive Macros

Derive macros allow functionality to be implemented on structures or enumerations with a single line of code.
Macro 	Description
Clone 	Explicit copy using .clone()
Copy 	Type will be implicitly copied by compiler when needed. Requires Clone to be implemented.
Debug 	Enable formatting using {:?}
Default 	Implements Default trait
Hash 	Enables usage with a Hasher (ie: keys in a HashMap). Requires PartialEq and Eq to be implemented.
Eq 	Symmetric equality (a == b and b == a) and transitive equality (if a == b and b == c then a == c). Requires PartialEq to be implemented.
PartialEq 	Allows comparison with ==
Ord 	Transitive ordering (if a < b and b < c then a < c). Requires Eq to be implemented.
PartialOrd 	Allow comparison with <, <=, >, >=. Requires PartialEq to be implemented.

// enable `Foo` to be Debug-printed and
// implicitly copied if needed
#[derive(Debug, Clone, Copy)]
struct Foo(usize);

fn hi(f: Foo) {}

let foo = Foo(1);
hi(foo);   // moved
hi(foo);   // implicit copy
hi(foo);   // implicit copy
hi(foo);   // implicit copy

// enable `Name` to be used as a key in a HashMap
#[derive(Eq, PartialEq, Hash)]
struct Name(String);

let name = Name("cheat sheet".into());
let mut names = std::collections::HashMap::new();
names.insert(name, ());

// enable `Letters` to be used with comparison operators
#[derive(PartialEq, PartialOrd)]
enum Letters {
    A,
    B,
    C,
}

if Letters::A < Letters::B { /* ... */ }

Declarative Macros

Declarative macros operate on code instead of data and are commonly used to write implementation blocks and tests.

Click for more details

// use `macro_rules!` to create a macro
macro_rules! name_of_macro_here {
    // Macros consist of one or more "matchers", each having a "transcriber".
    // This is similar to having multiple arms in a `match` expression.
    // Matchers are evaluated from top to bottom.
    () => {};

    (
        // Matchers have metavariables and fragment specifiers
        // which are detailed in the following sections.
    ) => {
        // Transcribers represent the code that will be
        // generated by the macro. Metavariables can be
        // used here for generating code.
    };

    (2) => {};
    (3) => {};
}

name_of_macro_here!();      // first matcher will match
name_of_macro_here!(1);     // second matcher will match
name_of_macro_here!(2);     // third matcher will match
name_of_macro_here!(3);     // fourth matcher will match

Valid Positions

Declarative macros can be used in some (but not all!) positions in Rust code.

Expression

Right-hand side of expressions or statements.

let nums = vec![1, 2, 3];
match vec![1, 2, 3].as_slice() {
    _ => format!("hello"),
}


Statement

Usually ends with a semicolon.

println!("Hello!");
dbg!(9_i64.pow(2));


Pattern

Match arms or if let patterns.

if let pat!(x) = Some(1) { }
match Some(1) {
    pat!(x) => (),
    _ => ()
}


Type

Anywhere you can use a type annotation.

macro_rules! Tuple {
    { $A:ty, $B:ty } => { ($A, $B) };
}
type N2 = Tuple!(i32, i32);
let nums: Tuple(i32, char) = (1, 'a');


Item

Anywhere you can declare a constant, impl block, enum, module, etc.

macro_rules! constant {
    ($name:ident) => { const $name: &'static str = "Cheat sheet"; }
}
macro_rules! newtype {
    ($name:ident, $typ:ty) => { struct $name($typ); }
}
constant!(NAME);
assert_eq!(NAME, "Cheat sheet");

newtype!(DemoStruct, usize);
let demo = DemoStruct(5);


Associated Item

Like an Item, but specifically within an impl block or trait.

macro_rules! msg {
    ($msg:literal) => {
        pub fn msg() {
            println!("{}", $msg);
        }
    };
}
struct Demo;
// Associated item
impl Demo {
    msg!("demos struct");
}


macro_rules Transcribers

Declarative macros can be present within other declarative macros.

macro_rules! demo {
    () => {
        println!("{}",
            format!("demo{}", '!')
        );
    };
}
demo!()

Fragment Specifiers

Declarative macros operate on metavariables. Just like a function parameter, metavariables require a name and a type. Here is a list metavariable types that can be used for declarative macros, and code examples of that type.

$item

macro_rules! demo {
    ($i:item) => { $i };
}
demo!(const a: char = 'g';);
demo! {fn hello(){}}
demo! {mod demo{}}
struct MyNum(i32);
demo! {
    impl MyNum {
        pub fn demo(&self) {
            println!("my num is {}", self.0);
        }
    }
}


$block

macro_rules! demo {
    ($b:block) => { $b };
}

let num = demo!(
    {
        if 1 == 1 { 1 } else { 2 }
    }
);


$stmt

macro_rules! demo {
    ($s:stmt) => { $s };
}

demo!( let a = 5 );
let mut myvec = vec![];
demo!( mybec.push(a) );


$pat / $pat_param

macro_rules! demo {
    ($p:pat) => {{
        let num = 3;
        match num {
            $p => (),
            1 => (),
            _ => (),
        }
    }};
}
demo! ( 2 );


$expr

macro_rules! demo {
    ($e:expr) => { $e };
}

demo!( loop {} );
demo!( 2 + 2 );
demo!( {
    panic!();
} );


$ty

macro_rules! demo {
    ($t:ty) => {{
        let d: $t = 4;
        fn add(lhs: $t, rhs: $t) -> $t {
            lhs + rhs
        }
    }};
}
demo!(i32);
demo!(usize);


$ident

macro_rules! demo {
    ($i:ident, $i2:ident) => {
        fn $i() {
            println!("hello");
        }
        let $i2 = 5;
    };
}
demo!(say_hi, five);
say_hi();
assert_eq!(5, five);


$path

macro_rules! demo {
    ($p:path) => {
        use $p;
    };
}
demo!(std::collections::HashMap);


$tt

macro_rules! demo {
    ($t:tt) => {
        $t {}
    };
}
demo!(loop);
demo!({
    println!("hello");
});


$meta

macro_rules! demo {
    ($m:meta) => {
        $[derive($m)]
        struct MyNum(i32);
    };
}
demo!(Debug);


$lifetime

macro_rules! demo {
    ($l:lifetime) => {
        let a: &$l str = "sample";
    };
}
demo!('static);


$vis

macro_rules! demo {
    ($v:vis) => {
        $v fn sample() {}
    };
}
demo!(pub);


$literal

macro_rules! demo {
    $(l:literal) => { $l };
}
let five = demo!(5);
let hi = demo!("hello");

Repetitions

One of the primary use cases for macros is automatically writing code for multiple inputs. Repetitions are used to accomplish this.

macro_rules! demo {
    // zero or more
    (
        // comma (,) is a separator between each `frag`
        $( $metavar:frag ),*
    ) => {
        // using a repetition requires the same repetition symbol
        // as specified in the matcher above
        $( $metavar )*
    }

    // one or more
    (
        // comma (,) is a separator between each `frag`
        $( $metavar:frag ),+
    ) => {
        // using a repetition requires the same repetition symbol
        // as specified in the matcher above
        $( $metavar )+
    }

    // zero or one
    (
        // no separator possible because only 0 or 1 `frag` may be present
        $( $metavar:frag )?
    ) => {
        // using a repetition requires the same repetition symbol
        // as specified in the matcher above
        $( $metavar )?
    }
}

macro_rules! demo {
    (
        // zero or one literals
        $( $a:literal )?
    ) => {
        $($a)?
    }
}
demo!();
demo!(1);

macro_rules! demo {
    (
        // one or more literals separated by a comma
        $( $a:literal ),+
    ) => {
        $(
            println!("{}", $a);
        )+
    }
}
demo!(1);
demo!(1, 2, 3, 4);

macro_rules! demo {
    (
        // any number of literals separated by a comma
        $( $a:literal ),*
    ) => {
        $(
            println!("{}", $a);
        )*
    }
}
demo!();
demo!(1);
demo!(1, 2, 3, 4);

macro_rules! demo {
    (
        // any number of literals separated by a comma
        // and may have a trailing comma at the end
        $( $a:literal ),*
        $(,)?
    ) => {
        $(
            println!("{}", $a);
        )*
    }
}
demo!();
demo!(1);
demo!(1, 2, 3, 4,);

Example Macros

Here is an example of a macro to write multiple tests:

macro_rules! test_many {
    (
        // name of a function followed by a colon
        $fn:ident:
        // "a literal followed by -> followed by a literal"
        // repeat the above any number of times separated by a comma
        $( $in:literal -> $expect:literal ),*
    ) => {
        // repeat this code for each match
        $(
            // $fn = name of the function
            // $in = input number to the function
            // $expect = expected output from the function
            assert_eq!($fn($in), $expect);
        )*
    }
}

// function under test
fn double(v: usize) -> usize {
    v * 2
}

// invoking the macro
test_many!(double: 0->0, 1->2, 2->4, 3->6, 4->8);


Here is an example of a macro to write multiple implementation blocks:

// trait we want to implement
trait BasePay {
    fn base_pay() -> u32;
}

// structures we want the trait implemented on
struct Employee;
struct Supervisor;
struct Manager;

// macro to implement the trait
macro_rules! impl_base_pay {
    (
        // begin repetition
        $(
            // name of stucture for implementation, followed
            // by a colon (:) followed by a number
            $struct:ident: $pay:literal
        ),+ // repeat 1 or more times

        $(,)? // optional trailing comma between entries
    ) => {
        // begin repetition
        $(
            // our impl block using a metavariable
            impl BasePay for $struct {
                fn base_pay() -> u32 {
                    // just return the literal
                    $pay
                }
            }
        )+  // repeat 1 or more times
    }
}

// invoking the macro ...
impl_base_pay!(
    Employee: 10,
    Supervisor: 20,
    Manager: 30,
);

// ... generates
impl BasePay for Employee {
    fn base_pay() -> u32 {
        10
    }
}
impl BasePay for Supervisor {
    fn base_pay() -> u32 {
        20
    }
}
impl BasePay for Manager {
    fn base_pay() -> u32 {
        30
    }
}

Macro Notes

Macros can be invoked from anywhere in a crate, so it is important to use absolute paths to functions, modules, types, etc. when the macro is to be used outside of where it is defined.

For std, prefix the std crate with two colons like so:

use ::std::collections::HashMap;

For items that exist in the current crate, use the special $crate metavariable:

use $crate::modulename::my_item;

Quick Links
Home
Pricing
Testimonials
Blog
Community
The Academy
Courses
Career Paths
Workshops & More
Career Path Quiz
Free Resources
Company
About ZTM
Ambassadors
Contact Us
Privacy
Terms
Cookies

Copyright © 2022, Zero To Mastery Inc.

DocDroid
rust_cheat_sheet.pdf

    Report
    Share
    Download

"UTF-8 encoded growable string"
will replace any invalid
UTF-8 sequences with �
option<char>
non-ASCII letters are
unchanged
this function only recognizes the
characters 0-9, a-z and A-Z
num bytes in utf8
between 1 and 4
Returns an iterator that yields the lowercase
equivalent of a char as one or more chars.
char is always four bytes in size. This is a
different representation than a given
character would have as part of a String.
panics if out of index / not
on char boundary
char (or panics)
inplace = 0..t,
returned is t..n
removes contents,
keeps capacity
fn checked_add_signed(self, rhs:
OldDuration) ->
Option<Date<Tz>>
fn checked_sub_signed(self, rhs:
OldDuration) ->
Option<Date<Tz>>
number of elements
the vector can hold
Reserves capacity for at least
additional more elements
keeps the first len elements
and drops the rest
returns item at index,
swaps last item to index
Retains only the elements
specified by the predicate
Removes all but the first of consecutive elements in
the vector that resolve to the same key
Removes all but the first of consecutive elements in
the vector satisfying a given equality relation.
Creates a draining iterator that removes the
specified range in the vector and yields the
removed items.
Splits the collection into
two at the given index
vec contains 0..usize,
returns usize..n
does not change capacity
Returns an iterator over subslices
separated by elements that match pred,
limited to returning at most n items
->option
(slice, slice)
0..index, index..n
last slice might
be shorter
Returns the number of elements the
map can hold without reallocating
->option<oldValue> None if key was
not yet present
->Option<valueAtKey>
Retains only the elements
specified by the predicate.
https://stackoverflow.com/questions/29672373/what-
is-difference-between-mut-a-t-and-a-mut-t
Applies a function to the contained
value (if any), or returns the provided
default (if not).
Applies a function to the contained
value (if any), or computes a default (if
not).
Maps a Result<T, E> to Result<U, E> by applying a function
to a contained Ok value, leaving an Err value untouched.
returns opt2 if opt1 and opt2
are Some,else none
res2 if both Ok, else (first
encountered) error
None if opt is None, else calls
FnOnce with val in some
res2 if res1 is err,
else Ok val res1
Err value if err,
else calls F
Returns the option if it contains
a value, otherwise calls f and
returns the result.
Calls fnOnce if the result is Err,
otherwise returns the Ok value of res
y scoped from outer
scope, n taken from some
removes option<t> layer 
(when compared with filter
then map)
Because the closure passed to skip_while() takes a
reference, and many iterators iterate over references,
this leads to a possibly confusing situation, where the
type of the closure is a double reference:
takes two arguments: an initial value which seeds
the internal state, and a closure with two arguments,
the first being a mutable reference to the internal
state and the second an iterator element. The
closure can assign to the internal state to share
state between iterations
consumes iterator upto n
all preceding elements, as well as the returned
element, will be consumed from the iterator.
Returns an iterator of (variable,
value) pairs of strings, for all the
environment variables of the
current process.
will overwrite
contents!!
 copies
permissions
returns num
bytes copied
Recursively create a directory and all of its
parent components if they are missing
Returns an iterator over the
entries within a directory
Removes a directory at this path,
PLUS removing all its contents.
overwrites!!
No file is allowed to exist at
the target location
This option, when true, means that writes will
append to a file instead of overwriting previous
contents.
This option indicates whether a new file will be
created if the file does not yet already exist.
Opens a file at path with the
options specified
If a file is successfully opened with this option set it
will truncate the file to 0 length if it already exists
represents an entry inside of
a directory on the filesystem
filename
without ext
string only (no slice)
A string literal is a string slice
that is statically allocated,
meaning that it's saved inside
our compiled program, and
exists for the entire duration it
runs.
leaves vec2 as is
moves vals from vec2
-> number of days since January 1, 1 (Day 1)
in the proleptic Gregorian calendar
returns opt1 if some,
else opt2
replaces value with
none, returns new
option with value
Traits can be implemented for
any data type.
reverse from cmp
rev from iter
full filesystem path of the
current running executable
let path = Path::new("/tmp/foo.txt");
assert_eq!(path.with_file_name("bar.txt"), PathBuf::from("/tmp/bar.txt"));
let path = Path::new("/tmp");
assert_eq!(path.with_file_name("var"), PathBuf::from("/var"));
the number of non-leap seconds since January 1, 1970 0:00:00 UTC
(aka "UNIX timestamp").
The 'static lifetime is the entire
duration of the program
s1 no longer has value,
is moved to s2
calling s1 will lead to
error
vars without copy trait are
moved to argument if
passed to function call!!
Constructors are static (no self) inherent methods
for the type that they construct
usefull as function parameter: easier to
write a function to take multiple types
Associated types connect a type placeholder with a
trait such that the trait method definitions can use
these placeholder types in their signatures
three variants, corresponding to the three
kinds of things the struct instance could be:
&self if it’s a
reference
&mut self if it’s a
mutable reference
self if it’s a value
on the stack,
You can overrule impl<T> with
implementation for a specific type
error if out of
bounds
for private fields, use
mods + pub
this technique is usually used when the
method transforms self into something else
and you want to prevent the caller from using
the original instance after the transformation
By specifying id_variable @ before the range 3...7,
we’re capturing whatever value matched the range
while also testing that the value matched the range
pattern
The pattern code isn’t able to use the value from the
id field, because we haven’t saved the id value in a
variable.
In the last arm, where we’ve specified a variable
without a range, we do have the value available to
use in the arm’s code in a variable named id. The
reason is that we’ve used the struct field shorthand
syntax. .


Show Menu

Cheatography

    Your Favourite Cheat Sheets

    Your Messages
    Your Badges
    Your Friends
    Your Comments

    View Profile
    Edit Profile
    Change Password

    Log out

    New Cheat Sheet
    New Link
    New Upload

    Live Cheat Sheets
    Draft Cheat Sheets
    Collaborations
    Links

Login  or  Register

    Home
    Login
    Register
    Cheat Sheets
        Programming Cheat Sheets
        Software Cheat Sheets
        Business and Marketing Cheat Sheets
        Education Cheat Sheets
        Home and Health Cheat Sheets
        Games and Hobbies Cheat Sheets
        New Cheat Sheets
        Popular Cheat Sheets
        Cheat Sheets by Tag
        Cheat Sheets by Language
        Cheat Sheet Links
    Create
        Getting Started
        Create a New Cheat Sheet
        Upload a Cheat Sheet
        Link to a Cheat Sheet
        A Cheat Sheet for Making Cheat Sheets!
    Community
        Community
        Badges
        Friends
        Join Us!
        Login
        Twitter
        Facebook
        Pinterest
        Instagram
    Help

Cheatography https://cheatography.com

    Download This Cheat Sheet (PDF)

    Comments
    Rating:

    Home >
    Cheat Sheets >
    Programming Cheat Sheets

Rust Essentials Cheat Sheet (DRAFT) by Reiner Martin

Rust Programming
This is a draft cheat sheet. It is a work in progress and is not finished yet.
HashMaps
use std::c­oll­ect­ion­s::­Has­hMap;
let mut h: HashMa­p<(­i64­,i6­4),­i64> = HashMa­p::­new();
h.cont­ain­s_k­ey(­&(­n,k))
	
check whether key is present
h.inse­rt(­(n,k), res);
	
insert new value
*h.get­(&­(n,­k)).un­wrap()
	
retrieve value
Variables and constants
const N: i32 = 5
	
(Global) constant
let v = vec![3, 1, 4]
	
Define and initialize vector
let zero_vec = vec![0; len]
let mut p : [usize; 9] = [0; 9];
Primitive types
bool
	
Boolean
char
	
character
f32, f64
	
32-bits, 64-bits floats
i64, i32, i16, i8
	
signed 16- ... integers
u64, u32, u16, u8
	
unsigned 16-bits, ... integers
isize
	
pointe­r-sized signed integers
usize
	
pointe­r-sized unsigned integers
Processor directives
#![fea­tur­e(i­ter­ato­r_s­tep­_by)]
for n in (0..10­0).s­te­p_by(2) { ... } iterates over even numbers
#![fea­­tu­r­e­(i­­ncl­­us­i­v­e_­­ran­­ge­_­s­yn­­tax)]
1..=n is a range which includes both 1 and n
	  	
Boolean operators
Operator
	
Syntax
And
	
a & b or a && b
Or
	
a . b or a .. b
And
	
a ^ b
Not
	
!a
Conver­sions
To convert say an n: i32 to a u64 use n as u64
To convert a number x to a string use x.to_s­tring()
To convert s: String* to x.pars­e().un­wrap()
x.unwr­ap_­or(­def­aul­t_v­alue)
Formatting
printl­n!(­"­{}", x);
printl­n!(­"­{:0­10b­}", x);
	
binary, 10 digits, print leading zeros
format­!("H­ell­o");
	
"­Hel­lo"
format­!("H­ello, {}!", "­wor­ld");
	
"­Hello, world!­"
format­!("The number is {}", 1);
	
"The number is 1"
format­!("{­:?}­", (3, 4));
	
"­4"
format­!("{­val­ue}­", value=4);
	
"1 2"
format­!("{­:04­}", 42);
	
"­004­2" with leading zeros
Vectors and iterators
(0..16­usi­ze).ma­p(|x| x.coun­t_o­nes() as usize).co­llect()
Assertions

let x = 42;
assert!(x == 42);
assert_eq!(x, 42);

Use the macro assert! to check for a boolean true, and assert_eq! for the equality of two expres­sions.
programming     rust
Download the Rust Essentials Cheat Sheet
1 Page

PDF (recommended)

    PDF (1 page)

Alternative Downloads

    PDF (black and white)
    LaTeX

Latest Cheat Sheet
6 Pages
  (0)
Docker & Swarm 2022 Cheat Sheet
Common commands used with Docker Desktop
Boulard
22 Sep 22
composer, docker, container, swarm
Random Cheat Sheet
1 Page
  (1)
Textadept 7 Keyboard Shortcuts
Keyboard shortcuts for TextAdept, a muiltiplatform text editor: http://www.foicica.com/textadept
kbarni
4 Oct 13, updated 12 May 16
shortcuts, editor, text, textadept, bookmarks, explications
About Cheatography
Cheatography is a collection of 5313 cheat sheets and quick references in 25 languages for everything from programming to business!
Behind the Scenes
If you have any problems, or just want to say hi, you can find us right here:
DaveChild
DaveChild
SpaceDuck
SpaceDuck
Cheatography
Cheatography
Recent Activity
Boulard
Boulard updated Docker, Compose, Swarm 2022.
8 hours 45 mins ago
RainyMoons
RainyMoons published Greek Alphabet.
17 hours 45 mins ago
xzeqtr
xzeqtr published tmux.
18 hours 12 mins ago
ElectroM
ElectroM updated Personology Chapter 1.
21 hours 59 mins ago
hitension
hitension updated atom.io.
22 hours 7 mins ago
© 2011 - 2022 Cheatography.com   |   CC License   |   Terms   |   Privacy
Latest Cheat Sheets RSS Feed
 

a+VgeDitto lockscreen kbdin pis343Apolsiren


SA+VgeDItto lockscreen kbdin pis342Apolsiren

https://external-content.duckduckgo.com/iu/?u=http%3A%2F%2Fvisibone.com%2Fproducts%2Fbbk14-15_850.jpg&f=1&nofb=1


Sa+VgeDItto lockscreen kbdin pis343Apolsiren



Fork me on GitHub

Ferris holding a cheat sheet.
Rust Language Cheat Sheet
15. September 2022

    Contains clickable links to The Book BK, Rust by Example EX, Std Docs STD, Nomicon NOM, Reference REF.
    ➕

Font Ligatures (..=, =>) Night Mode 💡

Language Constructs

    Data Structures
    References & Pointers
    Functions & Behavior
    Control Flow
    Organizing Code
    Type Aliases and Casts
    Macros & Attributes
    Pattern Matching
    Generics & Constraints
    Higher-Ranked Items
    Strings & Chars
    Documentation
    Miscellaneous

Behind the Scenes

    The Abstract Machine
    Language Sugar
    Memory & Lifetimes

Memory Layout

    Basic Types
    Custom Types
    References & Pointers
    Closures
    Standard Library Types

Misc

    Links & Services
    Printing & PDF

Standard Library

    One-Liners
    Thread Safety
    Iterators
    Number Conversions
    String Conversions
    String Output

Tooling

    Project Anatomy
    Cargo
    Cross Compilation
    Tooling Directives

Working with Types

    Types, Traits, Generics
    Foreign Types and Traits
    Type Conversions

Coding Guides

    Idiomatic Rust
    Async-Await 101
    Closures in APIs
    Unsafe, Unsound, Undefined
    Adversarial Code🝖
    API Stability

Hello, Rust!

If you are new to Rust, or if you want to try the things below:
Hello World

fn main() {
    println!("Hello, world!");
}

▶️ Edit & Run
Strengths

Things Rust does measurably really well

    Compiled code about same performance as C / C++, and excellent memory and energy efficiency.
    Can avoid 70% of all safety issues present in C / C++, and most memory issues.
    Strong type system prevents data races, brings 'fearless concurrency' (amongst others).
    Seamless C interop, and dozens of supported platforms (based on LLVM).
    "Most loved language" for 4 5 6 7 years in a row. 🤷‍♀️
    Modern tooling: cargo (builds just work), clippy (550+ code quality lints), rustup (easy toolchain mgmt).

Weaknesses

Points you might run into

    Steep learning curve;1 compiler enforcing (esp. memory) rules that would be "best practices" elsewhere.
    Missing Rust-native libs in some domains, target platforms (esp. embedded), IDE features.1
    Longer compile times than "similar" code in other languages.1
    No formal language specification, can prevent legal use in some domains (aviation, medical, …).
    Careless (use of unsafe in) libraries can secretly break safety guarantees.

1 Compare Rust Survey.
Installation

Download

    Get installer from rustup.rs (highly recommended)🔥

IDEs

    IntelliJ (free) or CLion (paid) with IntelliJ Rust
    Visual Studio Code with rust-analyzer

First Steps

Modular Beginner Resources

    Tour of Rust - Live code and explanations, side by side.
    Rust in Easy English - 60+ concepts, simple English, example-driven.

In addition, have a look at the usual suspects. BK EX STD

    Opinion 💬 — If you have never seen or used any Rust it might be good to visit one of the links above before continuing; the next chapter might feel a bit terse otherwise.

Data Structures

Data types and memory locations defined via keywords.
Example	Explanation
struct S {}	Define a struct BK EX STD REF with named fields.
     struct S { x: T }	Define struct with named field x of type T.
     struct S ​(T);	Define "tupled" struct with numbered field .0 of type T.
     struct S;	Define zero sized NOM unit struct. Occupies no space, optimized away.
enum E {}	Define an enum, BK EX REF c. algebraic data types, tagged unions.
     enum E { A, B​(), C {} }	Define variants of enum; can be unit- A, tuple- B ​() and struct-like C{}.
     enum E { A = 1 }	If variants are only unit-like, allow discriminant values, e.g., for FFI.
union U {}	Unsafe C-like union REF for FFI compatibility. 🝖
static X: T = T();	Global variable BK EX REF with 'static lifetime, single memory location.
const X: T = T();	Defines constant, BK EX REF copied into a temporary when used.
let x: T;	Allocate T bytes on stack1 bound as x. Assignable once, not mutable.
let mut x: T;	Like let, but allow for mutability BK EX and mutable borrow.2
     x = y;	Moves y to x, invalidating y if T is not Copy, STD and copying y otherwise.

1 Bound variables BK EX REF live on stack for synchronous code. In async {} they become part of async's state machine, may reside on heap.
2 Technically mutable and immutable are misnomer. Immutable binding or shared reference may still contain Cell STD, giving interior mutability.
 

Creating and accessing data structures; and some more sigilic types.
Example	Explanation
S { x: y }	Create struct S {} or use'ed enum E::S {} with field x set to y.
S { x }	Same, but use local variable x for field x.
S { ..s }	Fill remaining fields from s, esp. useful with Default.
S { 0: x }	Like S ​(x) below, but set field .0 with struct syntax.
S​ (x)	Create struct S ​(T) or use'ed enum E::S​ () with field .0 set to x.
S	If S is unit struct S; or use'ed enum E::S create value of S.
E::C { x: y }	Create enum variant C. Other methods above also work.
()	Empty tuple, both literal and type, aka unit. STD
(x)	Parenthesized expression.
(x,)	Single-element tuple expression. EX STD REF
(S,)	Single-element tuple type.
[S]	Array type of unspecified length, i.e., slice. EX STD REF Can't live on stack. *
[S; n]	Array type EX STD REF of fixed length n holding elements of type S.
[x; n]	Array instance REF (expression) with n copies of x.
[x, y]	Array instance with given elements x and y.
x[0]	Collection indexing, here w. usize. Implementable with Index, IndexMut.
     x[..]	Same, via range (here full range), also x[a..b], x[a..=b], ... c. below.
a..b	Right-exclusive range STD REF creation, e.g., 1..3 means 1, 2.
..b	Right-exclusive range to STD without starting point.
..=b	Inclusive range to STD without starting point.
a..=b	Inclusive range, STD 1..=3 means 1, 2, 3.
a..	Range from STD without ending point.
..	Full range, STD usually means the whole collection.
s.x	Named field access, REF might try to Deref if x not part of type S.
s.0	Numbered field access, used for tuple types S ​(T).

* For now,RFC pending completion of tracking issue.
References & Pointers

Granting access to un-owned memory. Also see section on Generics & Constraints.
Example	Explanation
&S	Shared reference BK STD NOM REF (type; space for holding any &s).
     &[S]	Special slice reference that contains (address, length).
     &str	Special string slice reference that contains (address, length).
     &mut S	Exclusive reference to allow mutability (also &mut [S], &mut dyn S, …).
     &dyn T	Special trait object BK reference that contains (address, vtable).
&s	Shared borrow BK EX STD (e.g., address, len, vtable, … of this s, like 0x1234).
     &mut s	Exclusive borrow that allows mutability. EX
*const S	Immutable raw pointer type BK STD REF w/o memory safety.
     *mut S	Mutable raw pointer type w/o memory safety.
     &raw const s	Create raw pointer w/o going through reference; c. ptr:addr_of!() STD 🚧 🝖
     &raw mut s	Same, but mutable. 🚧 Raw ptrs. are needed for unaligned, packed fields. 🝖
ref s	Bind by reference, EX makes binding reference type. 🗑️
     let ref r = s;	Equivalent to let r = &s.
     let S { ref mut x } = s;	Mutable ref binding (let x = &mut s.x), shorthand destructuring ↓ version.
*r	Dereference BK STD NOM a reference r to access what it points to.
     *r = s;	If r is a mutable reference, move or copy s to target memory.
     s = *r;	Make s a copy of whatever r references, if that is Copy.
     s = *r;	Won't work 🛑 if *r is not Copy, as that would move and leave empty place.
     s = *my_box;	Special case🔗 for Box that can also move out Box'ed content if it isn't Copy.
'a	A lifetime parameter, BK EX NOM REF duration of a flow in static analysis.
     &'a S	Only accepts an address holding some s; addr. existing 'a or longer.
     &'a mut S	Same, but allow content of address to be changed.
     struct S<'a> {}	Signals this S will contain address with lifetime 'a. Creator of S decides 'a.
     trait T<'a> {}	Signals any S, which impl T for S, might contain address.
     fn f<'a>(t: &'a T)	Signals this function handles some address. Caller decides 'a.
'static	Special lifetime lasting the entire program execution.
Functions & Behavior

Define units of code and their abstractions.
Example	Explanation
trait T {}	Define a trait; BK EX REF common behavior types can adhere to.
trait T : R {}	T is subtrait of supertrait BK EX REF R. Any S must impl R before it can impl T.
impl S {}	Implementation REF of functionality for a type S, e.g., methods.
impl T for S {}	Implement trait T for type S; specifies how exactly S acts like T.
impl !T for S {}	Disable an automatically derived auto trait. NOM REF 🚧 🝖
fn f() {}	Definition of a function; BK EX REF or associated function if inside impl.
     fn f() -> S {}	Same, returning a value of type S.
     fn f(&self) {}	Define a method, BK EX REF e.g., within an impl S {}.
struct S ​(T);	More arcanely, also↑ defines fn S(x: T) -> S constructor function. RFC 🝖
const fn f() {}	Constant fn usable at compile time, e.g., const X: u32 = f(Y). '18
async fn f() {}	Async REF '18 function transformation, ↓ makes f return an impl Future. STD
     async fn f() -> S {}	Same, but make f return an impl Future<Output=S>.
     async { x }	Used within a function, make { x } an impl Future<Output=X>.
fn() -> S	Function pointers, BK STD REF memory holding address of a callable.
Fn() -> S	Callable Trait BK STD (also FnMut, FnOnce), implemented by closures, fn's …
|| {} 	A closure BK EX REF that borrows its captures, ↓ REF (e.g., a local variable).
     |x| {}	Closure accepting one argument named x, body is block expression.
     |x| x + x	Same, without block expression; may only consist of single expression.
     move |x| x + y 	Closure taking ownership of its captures; i.e., y transferred to closure.
     return || true 	Closures sometimes look like logical ORs (here: return a closure).
unsafe	If you enjoy debugging segfaults Friday night; unsafe code. ↓ BK EX NOM REF
     unsafe fn f() {}	Means "calling can cause UB, ↓ YOU must check requirements".
     unsafe trait T {}	Means "careless impl. of T can cause UB; implementor must check".
     unsafe { f(); }	Guarantees to compiler "I have checked requirements, trust me".
     unsafe impl T for S {}	Guarantees S is well-behaved w.r.t T; people may use T on S safely.
Control Flow

Control execution within a function.
Example	Explanation
while x {}	Loop, REF run while expression x is true.
loop {}	Loop indefinitely REF until break. Can yield value with break x.
for x in iter {}	Syntactic sugar to loop over iterators. BK STD REF
if x {} else {}	Conditional branch REF if expression is true.
'label: loop {}	Loop label, EX REF useful for flow control in nested loops.
break	Break expression REF to exit a loop.
     break x	Same, but make x value of the loop expression (only in actual loop).
     break 'label	Exit not only this loop, but the enclosing one marked with 'label.
     break 'label x	Same, but make x the value of the enclosing loop marked with 'label.
continue 	Continue expression REF to the next loop iteration of this loop.
continue 'label	Same but instead of this loop, enclosing loop marked with 'label.
x?	If x is Err or None, return and propagate. BK EX STD REF
x.await	Only works inside async. Yield flow until Future STD or Stream x ready. REF '18
return x	Early return REF from function. More idiomatic is to end with expression.
     { return }	Inside normal {}-blocks return exits surrounding function.
     || { return }	Within closures return exits that closure only, i.e., closure is s. function.
     async { return }	Inside async a return only REF 🛑 exits that {} block, i.e., async {} is s.f.!
f()	Invoke callable f (e.g., a function, closure, function pointer, Fn, …).
x.f()	Call member function, requires f takes self, &self, … as first argument.
     X::f(x)	Same as x.f(). Unless impl Copy for X {}, f can only be called once.
     X::f(&x)	Same as x.f().
     X::f(&mut x)	Same as x.f().
     S::f(&x)	Same as x.f() if X derefs to S, i.e., x.f() finds methods of S.
     T::f(&x)	Same as x.f() if X impl T, i.e., x.f() finds methods of T if in scope.
X::f()	Call associated function, e.g., X::new().
     <X as T>::f()	Call trait method T::f() implemented for X.
Organizing Code

Segment projects into smaller units and minimize dependencies.
Example	Explanation
mod m {}	Define a module, BK EX REF get definition from inside {}. ↓
mod m;	Define a module, get definition from m.rs or m/mod.rs. ↓
a::b	Namespace path EX REF to element b within a (mod, enum, …).
     ::b	Search b in crate root '15 REF or external prelude '18 REF; global path. REF 🗑️
     crate::b	Search b in crate root. '18
     self::b	Search b in current module.
     super::b	Search b in parent module.
use a::b;	Use EX REF b directly in this scope without requiring a anymore.
use a::{b, c};	Same, but bring b and c into scope.
use a::b as x;	Bring b into scope but name x, like use std::error::Error as E.
use a::b as _;	Bring b anonymously into scope, useful for traits with conflicting names.
use a::*;	Bring everything from a in, only recommended if a is some prelude. STD 🔗
pub use a::b;	Bring a::b into scope and reexport from here.
pub T	"Public if parent path is public" visibility BK REF for T.
     pub(crate) T	Visible at most1 in current crate.
     pub(super) T	Visible at most1 in parent.
     pub(self) T	Visible at most1 in current module (default, same as no pub).
     pub(in a::b) T	Visible at most1 in ancestor a::b.
extern crate a;	Declare dependency on external crate; BK REF 🗑️ just use a::b in '18.
extern "C" {}	Declare external dependencies and ABI (e.g., "C") from FFI. BK EX NOM REF
extern "C" fn f() {}	Define function to be exported with ABI (e.g., "C") to FFI.

1 Items in child modules always have access to any item, regardless if pub or not.
Type Aliases and Casts

Short-hand names of types, and methods to convert one type to another.
Example	Explanation
type T = S;	Create a type alias, BK REF i.e., another name for S.
Self	Type alias for implementing type, REF e.g. fn new() -> Self.
self	Method subject in fn f(self) {}, same as fn f(self: Self) {}.
     &self	Same, but refers to self as borrowed, same as f(self: &Self)
     &mut self	Same, but mutably borrowed, same as f(self: &mut Self)
     self: Box<Self>	Arbitrary self type, add methods to smart pointers (my_box.f_of_self()).
S as T	Disambiguate BK REF type S as trait T, e.g., <S as T>::f().
S as R	In use of symbol, import S as R, e.g., use a::S as R.
x as u32	Primitive cast, EX REF may truncate and be a bit surprising. 1 NOM

1 See Type Conversions below for all the ways to convert between types.
Macros & Attributes

Code generation constructs expanded before the actual compilation happens.
Example	Explanation
m!()	Macro BK STD REF invocation, also m!{}, m![] (depending on macro).
#[attr]	Outer attribute, EX REF annotating the following item.
#![attr]	Inner attribute, annotating the upper, surrounding item.
 
Inside Macros	Explanation
$x:ty	Macro capture, the :... fragment REF declares what is allowed for $x. 1
$x	Macro substitution, e.g., use the captured $x:ty from above.
$(x),*	Macro repetition REF zero or more times in macros by example.
     $(x),?	Same, but zero or one time.
     $(x),+	Same, but one or more times.
     $(x)<<+	In fact separators other than , are also accepted. Here: <<.

1 See Tooling Directives below for all captures.
Pattern Matching

Constructs found in match or let expressions, or function parameters.
Example	Explanation
match m {}	Initiate pattern matching, BK EX REF then use match arms, c. next table.
let S(x) = get();	Notably, let also destructures EX similar to the table below.
     let S { x } = s;	Only x will be bound to value s.x.
     let (_, b, _) = abc;	Only b will be bound to value abc.1.
     let (a, ..) = abc;	Ignoring 'the rest' also works.
     let (.., a, b) = (1, 2);	Specific bindings take precedence over 'the rest', here a is 1, b is 2.
     let s @ S { x } = get();	Bind s to S while x is bound to s.x, pattern binding, BK EX REF c. below 🝖
     let w @ t @ f = get();	Stores 3 copies of get() result in each w, t, f. 🝖
     let Some(x) = get();	Won't work 🛑 if pattern can be refuted, REF use if let instead.
if let Some(x) = get() {}	Branch if pattern can be assigned (e.g., enum variant), syntactic sugar. *
while let Some(x) = get() {}	Equiv.; here keep calling get(), run {} as long as pattern can be assigned.
fn f(S { x }: S)	Function parameters also work like let, here x bound to s.x of f(s). 🝖

* Desugars to match get() { Some(x) => {}, _ => () }.
 

Pattern matching arms in match expressions. Left side of these arms can also be found in let expressions.
Within Match Arm	Explanation
E::A => {}	Match enum variant A, c. pattern matching. BK EX REF
E::B ( .. ) => {}	Match enum tuple variant B, ignoring any index.
E::C { .. } => {}	Match enum struct variant C, ignoring any field.
S { x: 0, y: 1 } => {}	Match struct with specific values (only accepts s with s.x of 0 and s.y of 1).
S { x: a, y: b } => {}	Match struct with any(!) values and bind s.x to a and s.y to b.
     S { x, y } => {}	Same, but shorthand with s.x and s.y bound as x and y respectively.
S { .. } => {}	Match struct with any values.
D => {}	Match enum variant E::D if D in use.
D => {}	Match anything, bind D; possibly false friend 🛑 of E::D if D not in use.
_ => {}	Proper wildcard that matches anything / "all the rest".
0 | 1 => {}	Pattern alternatives, or-patterns. RFC
     E::A | E::Z => {}	Same, but on enum variants.
     E::C {x} | E::D {x} => {}	Same, but bind x if all variants have it.
     Some(A | B) => {}	Same, can also match alternatives deeply nested.
(a, 0) => {}	Match tuple with any value for a and 0 for second.
[a, 0] => {}	Slice pattern, REF 🔗 match array with any value for a and 0 for second.
     [1, ..] => {}	Match array starting with 1, any value for rest; subslice pattern. REF RFC
     [1, .., 5] => {}	Match array starting with 1, ending with 5.
     [1, x @ .., 5] => {}	Same, but also bind x to slice representing middle (c. pattern binding).
     [a, x @ .., b] => {}	Same, but match any first, last, bound as a, b respectively.
1 .. 3 => {}	Range pattern, BK REF here matches 1 and 2; partially unstable. 🚧
     1 ..= 3 => {}	Inclusive range pattern, matches 1, 2 and 3.
     1 .. => {}	Open range pattern, matches 1 and any larger number.
x @ 1..=5 => {}	Bind matched to x; pattern binding, BK EX REF here x would be 1, 2, … or 5.
     Err(x @ Error {..}) => {}	Also works nested, here x binds to Error, esp. useful with if below.
S { x } if x > 10 => {}	Pattern match guards, BK EX REF condition must be true as well to match.
Generics & Constraints

Generics combine with type constructors, traits and functions to give your users more flexibility.
Example	Explanation
S<T>	A generic BK EX type with a type parameter (T is placeholder name here).
S<T: R>	Type short hand trait bound BK EX specification (R must be actual trait).
     T: R, P: S	Independent trait bounds (here one for T and one for P).
     T: R, S	Compile error, 🛑 you probably want compound bound R + S below.
     T: R + S	Compound trait bound, BK EX T must fulfill R and S.
     T: R + 'a	Same, but w. lifetime. T must fulfill R, if T has lifetimes, must outlive 'a.
     T: ?Sized	Opt out of a pre-defined trait bound, here Sized. ?
     T: 'a	Type lifetime bound; EX if T has references, they must outlive 'a.
     T: 'static	Same; does esp. not mean value t will 🛑 live 'static, only that it could.
     'b: 'a	Lifetime 'b must live at least as long as (i.e., outlive) 'a bound.
S<const N: usize>	Generic const bound; REF user of type S can provide constant value N.
     S<10>	Where used, const bounds can be provided as primitive values.
     S<{5+5}>	Expressions must be put in curly brackets.
S<T> where T: R	Almost same as S<T: R> but more pleasant to read for longer bounds.
     S<T> where u8: R<T>	Also allows you to make conditional statements involving other types.
S<T = R>	Default parameters; BK bit easier to use, but still flexible.
     S<const N: u8 = 0>	Default parameter for constants; e.g., in f(x: S) {} param N is 0.
     S<T = u8>	Default parameter for types, e.g., in f(x: S) {} param T is u8.
S<'_>	Inferred anonymous lifetime; asks compiler to 'figure it out' if obvious.
S<_>	Inferred anonymous type, e.g., as let x: Vec<_> = iter.collect()
S::<T>	Turbofish STD call site type disambiguation, e.g. f::<u32>().
trait T<X> {}	A trait generic over X. Can have multiple impl T for S (one per X).
trait T { type X; }	Defines associated type BK REF RFC X. Only one impl T for S possible.
     type X = R;	Set associated type within impl T for S { type X = R; }.
impl<T> S<T> {}	Implement functionality for any T in S<T>, here T type parameter.
impl S<T> {}	Implement functionality for exactly S<T>, here T specific type (e.g., S<u32>).
fn f() -> impl T	Existential types, BK returns an unknown-to-caller S that impl T.
fn f(x: &impl T)	Trait bound,"impl traits", BK somewhat similar to fn f<S:T>(x: &S).
fn f(x: &dyn T)	Marker for dynamic dispatch, BK REF f will not be monomorphized.
fn f() where Self: R;	In trait T {}, make f accessible only on types known to also impl R.
     fn f() where Self: Sized;	Using Sized can opt f out of dyn T trait object vtable, enabling trait obj.
     fn f() where Self: R {}	Other R useful w. dflt. methods (non dflt. would need be impl'ed anyway).
Higher-Ranked Items 🝖

Actual types and traits, abstract over something, usually lifetimes.
Example	Explanation
for<'a>	Marker for higher-ranked bounds. NOM REF 🝖
     trait T: for<'a> R<'a> {}	Any S that impl T would also have to fulfill R for any lifetime.
fn(&'a u8)	Function pointer type holding fn callable with specific lifetime 'a.
for<'a> fn(&'a u8)	Higher-ranked type1 🔗 holding fn callable with any lt.; subtype↓ of above.
     fn(&'_ u8)	Same; automatically expanded to type for<'a> fn(&'a u8).
     fn(&u8)	Same; automatically expanded to type for<'a> fn(&'a u8).
dyn for<'a> Fn(&'a u8)	Higher-ranked (trait-object) type, works like fn above.
     dyn Fn(&'_ u8)	Same; automatically expanded to type dyn for<'a> Fn(&'a u8).
     dyn Fn(&u8)	Same; automatically expanded to type dyn for<'a> Fn(&'a u8).

1 Yes, the for<> is part of the type, which is why you write impl T for for<'a> fn(&'a u8) below.
 
Implementing Traits	Explanation
impl<'a> T for fn(&'a u8) {}	For fn. pointer, where call accepts specific lt. 'a, impl trait T.
impl T for for<'a> fn(&'a u8) {}	For fn. pointer, where call accepts any lt., impl trait T.
     impl T for fn(&u8) {}	Same, short version.
Strings & Chars

Rust has several ways to create textual values.
Example	Explanation
"..."	String literal, REF, 1 UTF-8, will interpret \n as line break 0xA, …
r"..."	Raw string literal. REF, 1 UTF-8, won't interpret \n, …
r#"..."#	Raw string literal, UTF-8, but can also contain ". Number of # can vary.
b"..."	Byte string literal; REF, 1 constructs ASCII [u8], not a string.
br"...", br#"..."#	Raw byte string literal, ASCII [u8], combination of the above.
'🦀'	Character literal, REF fixed 4 byte unicode 'char'. STD
b'x'	ASCII byte literal. REF

1 Supports multiple lines out of the box. Just keep in mind Debug↓ (e.g., dbg!(x) and println!("{x:?}")) might render them as \n, while Display↓ (e.g., println!("{x}")) renders them proper.
Documentation

Debuggers hate him. Avoid bugs with this one weird trick.
Example	Explanation
///	Outer line doc comment,1 BK EX REF use these on types, traits, functions, …
//!	Inner line doc comment, mostly used at start of file to document module.
//	Line comment, use these to document code flow or internals.
/*...*/	Block comment. 2 🗑️
/**...*/	Outer block doc comment. 2 🗑️
/*!...*/	Inner block doc comment. 2 🗑️

1 Tooling Directives outline what you can do inside doc comments.

2 Generally discouraged due to bad UX. If possible use equivalent line comment instead with IDE support.
Miscellaneous

These sigils did not fit any other category but are good to know nonetheless.
Example	Explanation
!	Always empty never type. 🚧 BK EX STD REF
_	Unnamed wildcard REF variable binding, e.g., |x, _| {}.
     let _ = x;	Unnamed assignment is no-op, does not 🛑 move out x or preserve scope!
_x	Variable binding explicitly marked as unused.
1_234_567	Numeric separator for visual clarity.
1_u8	Type specifier for numeric literals EX REF (also i8, u16, …).
0xBEEF, 0o777, 0b1001	Hexadecimal (0x), octal (0o) and binary (0b) integer literals.
r#foo	A raw identifier BK EX for edition compatibility. 🝖
x;	Statement REF terminator, c. expressions EX REF
Common Operators

Rust supports most operators you would expect (+, *, %, =, ==, …), including overloading. STD Since they behave no differently in Rust we do not list them here.
Behind the Scenes

Arcane knowledge that may do terrible things to your mind, highly recommended.
The Abstract Machine

Like C and C++, Rust is based on an abstract machine.
Overview
Rust
→
CPU

🛑 Misleading.
Rust
→
Abstract Machine
→
CPU

Correct.
 

With rare exceptions you are never 'allowed to reason' about the actual CPU. You write code for an abstracted CPU. Rust then (sort of) understands what you want, and translates that into actual RISC-V / x86 / ... machine code.
 

This abstract machine

    is not a runtime, and does not have any runtime overhead, but is a computing model abstraction,
    contains concepts such as memory regions (stack, ...), execution semantics, ...
    knows and sees things your CPU might not care about,
    forms a contract between programmer and machine,
    and exploits all of the above for optimizations.

Misconceptions

Things people may incorrectly assume they should get away with if Rust targeted CPU directly, and more correct counterparts:
 
Without AM	With AM
0xffff_ffff would make a valid char. 🛑	Memory more than just bits.
0xff and 0xff are same pointer. 🛑	Pointers can come from different domains.
Any r/w pointer on 0xff always fine. 🛑	Read and write reference may not exist same time.
Null reference is just 0x0 in some register. 🛑	Holding 0x0 in reference summons Cthulhu.
Language Sugar

If something works that "shouldn't work now that you think about it", it might be due to one of these.
Name	Description
Coercions NOM	Weakens types to match signature, e.g., &mut T to &T; c. type conversions. ↓
Deref NOM 🔗	Derefs x: T until *x, **x, … compatible with some target S.
Prelude STD	Automatic import of basic items, e.g., Option, drop, ...
Reborrow	Since x: &mut T can't be copied; moves new &mut *x instead.
Lifetime Elision BK NOM REF	Automatically annotates f(x: &T) to f<'a>(x: &'a T).
Method Resolution REF	Derefs or borrow x until x.f() works.
Match Ergonomics RFC	Repeatedly dereferences scrutinee and adds ref and ref mut to bindings.
Rvalue Static Promotion RFC	Makes references to constants 'static, e.g., &42, &None, &mut [].
Dual Definitions RFC	Defining one thing (e.g., struct S(u8)) implicitly def. another (e.g., fn S).
 

    Opinion 💬 — The features above will make your life easier, but might hinder your understanding. If any (type-related) operation ever feels inconsistent it might be worth revisiting this list.

Memory & Lifetimes

An illustrated guide to moves, references and lifetimes.
Types & Moves
 
Application Memory
S(1)
t
Variables
S(1)
a t
Moves
M { ... } ⛔
c
Type Safety
S(1)▼ S(2)▼ S(3)
t
Scope & Drop
Call Stack
S(1)
a x
Function Boundaries
S(1)
a x x
Nested Functions
S(1) M { }
a x m
Repurposing Memory
References & Pointers
 
▼
S(1) 0x3
a r
References as Pointers
 
▼
S(2) 0x3 S(1)
a r d
Access to Non-Owned Memory
 
▼
0x3 M { x } ⛔ ⛔
a r d
References Guard Referents
 
▼
0x3
p
Raw Pointers
Lifetime Basics
"Lifetime" of Things
 
▼
S(2) 0xa
c r
Meaning of r: &'c S
 
▼
S(0) S(3) S(2) 0x6 ⛔
a b c r
Typelikeness of Lifetimes
 
▼
  0x6 S(4) ⛔
b
Borrowed State
Lifetimes in Functions
S(1) S(2) ? 0x6 0xa
b c r x y
Function Parameters
S(1) S(2) ?
a b c r
Problem of 'Borrowed' Propagation
 
▼
S(1) S(2) y + _
a b c r
Lifetimes Propagate Borrowed State
S(2)
a c
Unlocking
Advanced 🝖
 
▼
 
▼
 
S(1) 0x2 0x6 0x2
a ra rb rval
References to References
S(1)▼
_
Drop and _

↕️ Examples expand by clicking.
 
Memory Layout

Byte representations of common types.
Basic Types

Essential types built into the core of the language.
Numeric Types REF
u8, i8
u16, i16
u32, i32
u64, i64
u128, i128
f32
f64
usize, isize
Same as ptr on platform.

 
Unsigned Types
Type	Max Value
u8	255
u16	65_535
u32	4_294_967_295
u64	18_446_744_073_709_551_615
u128	340_282_366_920_938_463_463_374_607_431_768_211_455
usize	Depending on platform pointer size, same as u16, u32, or u64.
Signed Types
Type	Max Value
i8	127
i16	32_767
i32	2_147_483_647
i64	9_223_372_036_854_775_807
i128	170_141_183_460_469_231_731_687_303_715_884_105_727
isize	Depending on platform pointer size, same as i16, i32, or i64.
 
Type	Min Value
i8	-128
i16	-32_768
i32	-2_147_483_648
i64	-9_223_372_036_854_775_808
i128	-170_141_183_460_469_231_731_687_303_715_884_105_728
isize	Depending on platform pointer size, same as i16, i32, or i64.
Float Types🝖

Sample bit representation* for a f32:
S E E E E E E E E F F F F F F F F F F F F F F F F F F F F F F F
 

Explanation:
f32	S (1)	E (8)	F (23)	Value
Normalized number	±	1 to 254	any	±(1.F)2 * 2E-127
Denormalized number	±	0	non-zero	±(0.F)2 * 2-126
Zero	±	0	0	±0
Infinity	±	255	0	±∞
NaN	±	255	non-zero	NaN
 

Similarly, for f64 types this would look like:
f64	S (1)	E (11)	F (52)	Value
Normalized number	±	1 to 2046	any	±(1.F)2 * 2E-1023
Denormalized number	±	0	non-zero	±(0.F)2 * 2-1022
Zero	±	0	0	±0
Infinity	±	2047	0	±∞
NaN	±	2047	non-zero	NaN
* Float types follow IEEE 754-2008 and depend on platform endianness.
Casting Pitfalls 🛑
Cast1	Gives	Note
3.9_f32 as u8	3	Truncates, consider x.round() first.
314_f32 as u8	255	Takes closest available number.
f32::INFINITY as u8	255	Same, treats INFINITY as really large number.
f32::NAN as u8	0	-
_314 as u8	58	Truncates excess bits.
_200 as i8	56	-
_257 as i8	-1	-
Arithmetical Pitfalls 🛑
Operation1	Gives	Note
200_u8 / 0_u8	Compile error.	-
200_u8 / _0 d, r	Panic.	Regular math may panic; here: division by zero.
200_u8 + 200_u8	Compile error.	-
200_u8 + _200 d	Panic.	Consider checked_, wrapping_, ... instead. STD
200_u8 + _200 r	144	In release mode this will overflow.
1_u8 / 2_u8	0	Other integer division truncates.
0.8_f32 + 0.1_f32	0.90000004	-
1.0_f32 / 0.0_f32	f32::INFINITY	-
0.0_f32 / 0.0_f32	f32::NAN	-
x < f32::NAN	false	NAN comparisons always return false.
x > f32::NAN	false	-
f32::NAN == f32::NAN	false	-

1 Expression _100 means anything that might contain the value 100, e.g., 100_i32, but is opaque to compiler.
d Debug build.
r Release build.
 
Textual Types REF
char
Any Unicode scalar.
str
... U T F - 8 ... unspecified times
Rarely seen alone, but as &str instead.
 
Basics
Type	Description
char	Always 4 bytes and only holds a single Unicode scalar value 🔗.
str	An u8-array of unknown length guaranteed to hold UTF-8 encoded code points.
Usage
Chars	Description
let c = 'a';	Often a char (unicode scalar) can coincide with your intuition of character.
let c = '❤';	It can also hold many Unicode symbols.
let c = '❤️';	But not always. Given emoji is two char (see Encoding) and can't 🛑 be held by c.1
c = 0xffff_ffff;	Also, chars are not allowed 🛑 to hold arbitrary bit patterns.
1 Fun fact, due to the Zero-width joiner (⨝) what the user perceives as a character can get even more unpredictable: 👨‍👩‍👧 is in fact 5 chars 👨⨝👩⨝👧, and rendering engines are free to either show them fused as one, or separately as three, depending on their abilities.
 
Strings	Description
let s = "a";	A str is usually never held directly, but as &str, like s here.
let s = "❤❤️";	It can hold arbitrary text, has variable length per c., and is hard to index.
Encoding🝖

let s = "I ❤ Rust";
let t = "I ❤️ Rust";
Variant	Memory Representation2
s.as_bytes()	49 20 e2 9d a4 20 52 75 73 74 3
s.chars()1	49 00 00 00 20 00 00 00 64 27 00 00 20 00 00 00 52 00 00 00 75 00 00 00 73 00 …
t.as_bytes()	49 20 e2 9d a4 ef b8 8f 20 52 75 73 74 4
t.chars()1	49 00 00 00 20 00 00 00 64 27 00 00 0f fe 01 00 20 00 00 00 52 00 00 00 75 00 …
 
1 Result then collected into array and transmuted to bytes.
2 Values given in hex, on x86.
3 Notice how ❤, having Unicode Code Point (U+2764), is represented as 64 27 00 00 inside the char, but got UTF-8 encoded to e2 9d a4 in the str.
4 Also observe how the emoji Red Heart ❤️, is a combination of ❤ and the U+FE0F Variation Selector, thus t has a higher char count than s.
 

    💬 For what seem to be browser bugs Safari and Edge render the hearts in Footnote 3 and 4 wrong, despite being able to differentiate them correctly in s and t above.

 
Custom Types

Basic types definable by users. Actual layout REF is subject to representation; REF padding can be present.
T
T
Sized ↓
T: ?Sized
T
Maybe DST ↓
[T; n]
T T T ... n times
Fixed array of n elements.
[T]
... T T T ... unspecified times
Slice type of unknown-many elements. Neither
Sized (nor carries len information), and most
often lives behind reference as &[T]. ↓
struct S;
Zero-Sized ↓
(A, B, C)
A B C
or maybe
B A C
Unless a representation is forced
(e.g., via #[repr(C)]), type layout
unspecified.
struct S { b: B, c: C }
B C
or maybe
C ↦ B
Compiler may also add padding.

    Also note, two types A(X, Y) and B(X, Y) with exactly the same fields can still have differing layout; never transmute() STD without representation guarantees.

 

These sum types hold a value of one of their sub types:
enum E { A, B, C }
Tag A
exclusive or
Tag B
exclusive or
Tag C
Safely holds A or B or C, also
called 'tagged union', though
compiler may omit tag.
union { ... }
A
unsafe or
B
unsafe or
C
Can unsafely reinterpret
memory. Result might
be undefined.
References & Pointers

References give safe access to 3rd party memory, raw pointers unsafe access. The corresponding mut types have an identical data layout to their immutable counterparts.
&'a T
ptr2/4/8 meta2/4/8
|
T
Must target some valid t of T,
and any such target must exist for
at least 'a.
*const T
ptr2/4/8 meta2/4/8
No guarantees.

Pointer Meta

Many reference and pointer types can carry an extra field, pointer metadata. STD It can be the element- or byte-length of the target, or a pointer to a vtable. Pointers with meta are called fat, otherwise thin.
&'a T
ptr2/4/8
|
T
No meta for
sized target.
(pointer is thin).
&'a T
ptr2/4/8 len2/4/8
|
T
If T is a DST struct such as
S { x: [u8] } meta field len is
length of dyn. sized content.
&'a [T]
ptr2/4/8 len2/4/8
|
... T T ...
Regular slice reference (i.e., the
reference type of a slice type [T]) ↑
often seen as &[T] if 'a elided.
&'a str
ptr2/4/8 len2/4/8
|
... U T F - 8 ...
String slice reference (i.e., the
reference type of string type str),
with meta len being byte length.

&'a dyn Trait
ptr2/4/8 ptr2/4/8
|
T
|
*Drop::drop(&mut T)
size
align
*Trait::f(&T, ...)
*Trait::g(&T, ...)
Meta points to vtable, where *Drop::drop(), *Trait::f(), ... are pointers to their respective impl for T.
Closures

Ad-hoc functions with an automatically managed data block capturing REF environment where closure was defined. For example:
move |x| x + y.f() + z
Y Z
Anonymous closure type C1
|x| x + y.f() + z
ptr2/4/8 ptr2/4/8
Anonymous closure type C2
|
Y
|
Z

    Also produces anonymous fn such as fc1(C1, X) or fc2(&C2, X). Details depend which FnOnce, FnMut, Fn ... is supported, based on properties of captured types.

Standard Library Types

Rust's standard library combines the above primitive types into useful types with special semantics, e.g.:
UnsafeCell<T>
T
Magic type allowing
aliased mutability.
Cell<T>
T
Allows T's
to move in
and out.
RefCell<T>
borrowed T
Also support dynamic
borrowing of T. Like Cell this
is Send, but not Sync.
AtomicUsize
usize2/4/8
Other atomic similarly.
Result<T, E>
Tag E
or
Tag T
Option<T>
Tag
or
Tag T
Tag may be omitted for
certain T, e.g., NonNull.
 
Order-Preserving Collections
Box<T>
ptr2/4/8 meta2/4/8
|
T
For some T stack proxy may carry
meta↑ (e.g., Box<[T]>).
Vec<T>
ptr2/4/8 capacity2/4/8 len2/4/8
|
T T ... len
← capacity →
Regular growable array vector of single type.
LinkedList<T> 🝖
head2/4/8 tail2/4/8 len2/4/8
|
|
next2/4/8 prev2/4/8 T
Elements head and tail both null or point to nodes on
the heap. Each node can point to its prev and next node.
Eats your cache (just look at the thing!); don't use unless
you evidently must. 🛑
VecDeque<T>
tail2/4/8 head2/4/8 ptr2/4/8 capacity2/4/8
|
T⁣T ... empty ... T⁣H
← capacity →
Index tail and head select in array-as-ringbuffer. This means content
may be non-contiguous and empty in the middle, as exemplified above.
 
Other Collections
HashMap<K, V>
bmask2/4/8 ctrl2/4/8 left2/4/8 len2/4/8
|
K:V K:V ... K:V ... K:V
Oversimplified!
Stores keys and values on heap according to hash value, SwissTable
implementation via hashbrown. HashSet identical to HashMap,
just type V disappears. Heap view grossly oversimplified. 🛑
BinaryHeap<T>
ptr2/4/8 capacity2/4/8 len2/4/8
|
T⁣0 T⁣1 T⁣1 T⁣2 T⁣2 ... len
← capacity →
Heap stored as array with 2N elements per layer. Each T
can have 2 children in layer below. Each T larger than its
children.
Owned Strings
String
ptr2/4/8 capacity2/4/8 len2/4/8
|
U T F - 8 ... len
← capacity →
Observe how String differs from &str and &[char].
CString
ptr2/4/8 len2/4/8
|
A B C ... len ... ␀
NUL-terminated but w/o NUL in middle.
OsString
Platform Defined
|
? ? / ? ?
Encapsulates how operating system
represents strings (e.g., WTF-8 on
Windows).
PathBuf
OsString
|
? ? / ? ?
Encapsulates how operating system
represents paths.
 
Shared Ownership

If the type does not contain a Cell for T, these are often combined with one of the Cell types above to allow shared de-facto mutability.
Rc<T>
ptr2/4/8 meta2/4/8
|
strng2/4/8 weak2/4/8 T
Share ownership of T in same thread. Needs nested Cell
or RefCellto allow mutation. Is neither Send nor Sync.
Arc<T>
ptr2/4/8 meta2/4/8
|
strng2/4/8 weak2/4/8 T
Same, but allow sharing between threads IF contained
T itself is Send and Sync.

Mutex<T> / RwLock<T>
inner poison2/4/8 T
Inner fields depend on platform. Needs to be
held in Arc to be shared between decoupled
threads, or via scope() for scoped threads.
Standard Library
One-Liners

Snippets that are common, but still easy to forget. See Rust Cookbook 🔗 for more.
Strings
Intent	Snippet
Concatenate strings (any Display↓ that is). 1 '21	format!("{x}{y}")
Append string (any Display to any Write). '21	write!(x, "{y}")
Split by separator pattern. STD 🔗	s.split(pattern)
     ... with &str	s.split("abc")
     ... with char	s.split('/')
     ... with closure	s.split(char::is_numeric)
Split by whitespace.	s.split_whitespace()
Split by newlines.	s.lines()
Split by regular expression.2	Regex::new(r"\s")?.split("one two three")

1 Allocates; if x or y are not going to be used afterwards consider using write! or std::ops::Add.
2 Requires regex crate.
I/O
Intent	Snippet
Create a new file	File::create(PATH)?
     Same, via OpenOptions	OpenOptions::new().create(true).write(true).truncate(true).open(PATH)?
Macros
Intent	Snippet
Macro w. variable arguments	macro_rules! var_args { ($($args:expr),*) => {{ }} }
     Using args, e.g., calling f multiple times.	     $( f($args); )*
Esoterics🝖
Intent	Snippet
Cleaner closure captures	wants_closure({ let c = outer.clone(); move || use_clone(c) })
Fix inference in 'try' closures	iter.try_for_each(|x| { Ok::<(), Error>(()) })?;
Iterate and edit &mut [T] if T Copy.	Cell::from_mut(mut_slice).as_slice_of_cells()
Get subslice with length.	&original_slice[offset..][..length]
Canary to ensure trait T is object safe.	const _: Option<&dyn T> = None;
Thread Safety
Examples	Send*	!Send
Sync*	Most types ... Arc<T>1,2, Mutex<T>2	MutexGuard<T>1, RwLockReadGuard<T>1
!Sync	Cell<T>2, RefCell<T>2	Rc<T>, &dyn Trait, *const T3, *mut T3

* An instance t where T: Send can be moved to another thread, a T: Sync means &t can be moved to another thread.
1 If T is Sync.
2 If T is Send.
3 If you need to send a raw pointer, create newtype struct Ptr(*const u8) and unsafe impl Send for Ptr {}. Just ensure you may send it.
Iterators
Obtaining Iterators

Basics

Assume you have a collection c of type C:

    c.into_iter() — Turns collection c into an Iterator STD i and consumes* c. Requires IntoIterator STD for C to be implemented. Type of item depends on what C was. 'Standardized' way to get Iterators.
    c.iter() — Courtesy method some collections provide, returns borrowing Iterator, doesn't consume c.
    c.iter_mut() — Same, but mutably borrowing Iterator that allow collection to be changed.

The Iterator

Once you have an i:

    i.next() — Returns Some(x) next element c provides, or None if we're done.

For Loops

    for x in c {} — Syntactic sugar, calls c.into_iter() and loops i until None.

* If it looks as if it doesn't consume c that's because type was Copy. For example, if you call (&c).into_iter() it will invoke .into_iter() on &c (which will consume the reference and turn it into an Iterator), but c remains untouched.
Implementing Iterators

Basics

Let's assume you have a struct Collection<T> {}.

    struct IntoIter<T> {} — Create a struct to hold your iteration status (e.g., an index) for value iteration.
    impl Iterator for IntoIter {} — Implement Iterator::next() so it can produce elements.

Collection<T>
IntoIter<T>
⌾ Iterator
Item = T;

Shared & Mutable Iterators

    struct Iter<T> {} — Create struct holding &Collection<T> for shared iteration.
    struct IterMut<T> {} — Similar, but holding &mut Collection<T> for mutable iteration.
    impl Iterator for Iter<T> {} — Implement shared iteration.
    impl Iterator for IterMut<T> {} — Implement mutable iteration.

In addition, you might want to add convenience methods:

    Collection::iter(&self) -> Iter,
    Collection::iter_mut(&mut self) -> IterMut.

Iter<T>
⌾ Iterator
Item = &T;
IterMut<T>
⌾ Iterator
Item = &mut T;

Making Loops Work

    impl IntoIterator for Collection {} — Now for x in c {} works.
    impl IntoIterator for &Collection {} — Now for x in &c {} works.
    impl IntoIterator for &mut Collection {} — Now for x in &mut c {} works.

Collection<T>
⌾ IntoIterator
Item = T;
To = IntoIter<T>
Iterate over T.
&Collection<T>
⌾ IntoIterator
Item = &T;
To = Iter<T>
Iterate over &T.
&mut Collectn<T>
⌾ IntoIterator
Item = &mut T;
To = IterMut<T>
Iterate over &mut T.
Number Conversions

As-correct-as-it-currently-gets number conversions.
↓ Have / Want →	u8 … i128	f32 / f64	String
u8 … i128	u8::try_from(x)? 1	x as f32 3	x.to_string()
f32 / f64	x as u8 2	x as f32	x.to_string()
String	x.parse::<u8>()?	x.parse::<f32>()?	x

1 If type true subset from() works directly, e.g., u32::from(my_u8).
2 Truncating (11.9_f32 as u8 gives 11) and saturating (1024_f32 as u8 gives 255); c. below.
3 Might misrepresent number (u64::MAX as f32) or produce Inf (u128::MAX as f32).
String Conversions

If you want a string of type …
String
If you have x of type …	Use this …
String	x
CString	x.into_string()?
OsString	x.to_str()?.to_string()
PathBuf	x.to_str()?.to_string()
Vec<u8> 1	String::from_utf8(x)?
&str	x.to_string() i
&CStr	x.to_str()?.to_string()
&OsStr	x.to_str()?.to_string()
&Path	x.to_str()?.to_string()
&[u8] 1	String::from_utf8_lossy(x).to_string()
CString
If you have x of type …	Use this …
String	CString::new(x)?
CString	x
OsString 2	CString::new(x.to_str()?)?
PathBuf	CString::new(x.to_str()?)?
Vec<u8> 1	CString::new(x)?
&str	CString::new(x)?
&CStr	x.to_owned() i
&OsStr 2	CString::new(x.to_os_string().into_string()?)?
&Path	CString::new(x.to_str()?)?
&[u8] 1	CString::new(Vec::from(x))?
*mut c_char 3	unsafe { CString::from_raw(x) }
OsString
If you have x of type …	Use this …
String	OsString::from(x) i
CString	OsString::from(x.to_str()?)
OsString	x
PathBuf	x.into_os_string()
Vec<u8> 1	?
&str	OsString::from(x) i
&CStr	OsString::from(x.to_str()?)
&OsStr	OsString::from(x) i
&Path	x.as_os_str().to_owned()
&[u8] 1	?
PathBuf
If you have x of type …	Use this …
String	PathBuf::from(x) i
CString	PathBuf::from(x.to_str()?)
OsString	PathBuf::from(x) i
PathBuf	x
Vec<u8> 1	?
&str	PathBuf::from(x) i
&CStr	PathBuf::from(x.to_str()?)
&OsStr	PathBuf::from(x) i
&Path	PathBuf::from(x) i
&[u8] 1	?
Vec<u8>
If you have x of type …	Use this …
String	x.into_bytes()
CString	x.into_bytes()
OsString	?
PathBuf	?
Vec<u8> 1	x
&str	Vec::from(x.as_bytes())
&CStr	Vec::from(x.to_bytes_with_nul())
&OsStr	?
&Path	?
&[u8] 1	x.to_vec()
&str
If you have x of type …	Use this …
String	x.as_str()
CString	x.to_str()?
OsString	x.to_str()?
PathBuf	x.to_str()?
Vec<u8> 1	std::str::from_utf8(&x)?
&str	x
&CStr	x.to_str()?
&OsStr	x.to_str()?
&Path	x.to_str()?
&[u8] 1	std::str::from_utf8(x)?
&CStr
If you have x of type …	Use this …
String	CString::new(x)?.as_c_str()
CString	x.as_c_str()
OsString 2	x.to_str()?
PathBuf	?,4
Vec<u8> 1,5	CStr::from_bytes_with_nul(&x)?
&str	?,4
&CStr	x
&OsStr 2	?
&Path	?
&[u8] 1,5	CStr::from_bytes_with_nul(x)?
*const c_char 1	unsafe { CStr::from_ptr(x) }
&OsStr
If you have x of type …	Use this …
String	OsStr::new(&x)
CString	?
OsString	x.as_os_str()
PathBuf	x.as_os_str()
Vec<u8> 1	?
&str	OsStr::new(x)
&CStr	?
&OsStr	x
&Path	x.as_os_str()
&[u8] 1	?
&Path
If you have x of type …	Use this …
String	Path::new(x) r
CString	Path::new(x.to_str()?)
OsString	Path::new(x.to_str()?) r
PathBuf	Path::new(x.to_str()?) r
Vec<u8> 1	?
&str	Path::new(x) r
&CStr	Path::new(x.to_str()?)
&OsStr	Path::new(x) r
&Path	x
&[u8] 1	?
&[u8]
If you have x of type …	Use this …
String	x.as_bytes()
CString	x.as_bytes()
OsString	?
PathBuf	?
Vec<u8> 1	&x
&str	x.as_bytes()
&CStr	x.to_bytes_with_nul()
&OsStr	x.as_bytes() 2
&Path	?
&[u8] 1	x
Other
You want	And have x	Use this …
*const c_char	CString	x.as_ptr()

i Short form x.into() possible if type can be inferred.
r Short form x.as_ref() possible if type can be inferred.

1 You should, or must if call is unsafe, ensure raw data comes with a valid representation for the string type (e.g., UTF-8 data for a String).

2 Only on some platforms std::os::<your_os>::ffi::OsStrExt exists with helper methods to get a raw &[u8] representation of the underlying OsStr. Use the rest of the table to go from there, e.g.:

use std::os::unix::ffi::OsStrExt;
let bytes: &[u8] = my_os_str.as_bytes();
CString::new(bytes)?

3 The c_char must have come from a previous CString. If it comes from FFI see &CStr instead.

4 No known shorthand as x will lack terminating 0x0. Best way to probably go via CString.

5 Must ensure vector actually ends with 0x0.
String Output

How to convert types into a String, or output them.
APIs

Rust has, among others, these APIs to convert types to stringified output, collectively called format macros:
Macro	Output	Notes
format!(fmt)	String	Bread-and-butter "to String" converter.
print!(fmt)	Console	Writes to standard output.
println!(fmt)	Console	Writes to standard output.
eprint!(fmt)	Console	Writes to standard error.
eprintln!(fmt)	Console	Writes to standard error.
write!(dst, fmt)	Buffer	Don't forget to also use std::io::Write;
writeln!(dst, fmt)	Buffer	Don't forget to also use std::io::Write;
 
Method	Notes
x.to_string() STD	Produces String, implemented for any Display type.
 

Here fmt is string literal such as "hello {}", that specifies output (compare "Formatting" tab) and additional parameters.
Printable Types

In format! and friends, types convert via trait Display "{}" STD or Debug "{:?}" STD , non exhaustive list:
Type	Implements	
String	Debug, Display	
CString	Debug	
OsString	Debug	
PathBuf	Debug	
Vec<u8>	Debug	
&str	Debug, Display	
&CStr	Debug	
&OsStr	Debug	
&Path	Debug	
&[u8]	Debug	
bool	Debug, Display	
char	Debug, Display	
u8 … i128	Debug, Display	
f32, f64	Debug, Display	
!	Debug, Display	
()	Debug	
 

In short, pretty much everything is Debug; more special types might need special handling or conversion ↑ to Display.
Formatting

Each argument designator in format macro is either empty {}, {argument}, or follows a basic syntax:

{ [argument] ':' [[fill] align] [sign] ['#'] [width [$]] ['.' precision [$]] [type] }

Element	Meaning
argument	Number (0, 1, ...), variable '21 or name,'18 e.g., print!("{x}").
fill	The character to fill empty spaces with (e.g., 0), if width is specified.
align	Left (<), center (^), or right (>), if width is specified.
sign	Can be + for sign to always be printed.
#	Alternate formatting, e.g. prettify DebugSTD formatter ? or prefix hex with 0x.
width	Minimum width (≥ 0), padding with fill (default to space). If starts with 0, zero-padded.
precision	Decimal digits (≥ 0) for numerics, or max width for non-numerics.
$	Interpret width or precision as argument identifier instead to allow for dynamic formatting.
type	DebugSTD (?) formatting, hex (x), binary (b), octal (o), pointer (p), exp (e) ... see more.
 
Format Example	Explanation
{}	Print the next argument using Display.STD
{x}	Same, but use variable x from scope. '21
{:?}	Print the next argument using Debug.STD
{2:#?}	Pretty-print the 3rd argument with DebugSTD formatting.
{val:^2$}	Center the val named argument, width specified by the 3rd argument.
{:<10.3}	Left align with width 10 and a precision of 3.
{val:#x}	Format val argument as hex, with a leading 0x (alternate format for x).
 
Full Example	Explanation
println!("{}", x)	Print x using DisplaySTD on std. out and append new line. '15 🗑️
println!("{x}")	Same, but use variable x from scope. '21
format!("{a:.3} {b:?}")	Convert PI with 3 digits, add space, b with Debug STD, return String. '21
 
Tooling
Project Anatomy

Basic project layout, and common files and folders, as used by cargo. ↓
Entry	Code
📁 .cargo/	Project-local cargo configuration, may contain config.toml. 🔗 🝖
📁 benches/	Benchmarks for your crate, run via cargo bench, requires nightly by default. * 🚧
📁 examples/	Examples how to use your crate, they see your crate like external user would.
     my_example.rs	Individual examples are run like cargo run --example my_example.
📁 src/	Actual source code for your project.
     main.rs	Default entry point for applications, this is what cargo run uses.
     lib.rs	Default entry point for libraries. This is where lookup for my_crate::f() starts.
📁 src/bin/	Place for additional binaries, even in library projects.
     extra.rs	Additional binary, run with cargo run --bin extra.
📁 tests/	Integration tests go here, invoked via cargo test. Unit tests often stay in src/ file.
.rustfmt.toml	In case you want to customize how cargo fmt works.
.clippy.toml	Special configuration for certain clippy lints, utilized via cargo clippy 🝖
build.rs	Pre-build script, 🔗 useful when compiling C / FFI, ...
Cargo.toml	Main project manifest, 🔗 Defines dependencies, artifacts ...
Cargo.lock	Dependency details for reproducible builds; add to git for apps, not for libs.
rust-toolchain.toml	Define toolchain override🔗 (channel, components, targets) for this project.

* On stable consider Criterion.
 

Minimal examples for various entry points might look like:
Applications

// src/main.rs (default application entry point)

fn main() {
    println!("Hello, world!");
}

Libraries

// src/lib.rs (default library entry point)

pub fn f() {}      // Is a public item in root, so it's accessible from the outside.

mod m {
    pub fn g() {}  // No public path (`m` not public) from root, so `g`
}                  // is not accessible from the outside of the crate.

Unit Tests

// src/my_module.rs (any file of your project)

fn f() -> u32 { 0 }

#[cfg(test)]
mod test {
    use super::f;           // Need to import items from parent module. Has
                            // access to non-public members.
    #[test]
    fn ff() {
        assert_eq!(f(), 0);
    }
}

Integration Tests

// tests/sample.rs (sample integration test)

#[test]
fn my_sample() {
    assert_eq!(my_crate::f(), 123); // Integration tests (and benchmarks) 'depend' to the crate like
}                                   // a 3rd party would. Hence, they only see public items.

Benchmarks🚧

// benches/sample.rs (sample benchmark)

#![feature(test)]   // #[bench] is still experimental

extern crate test;  // Even in '18 this is needed ... for reasons.
                    // Normally you don't need this in '18 code.

use test::{black_box, Bencher};

#[bench]
fn my_algo(b: &mut Bencher) {
    b.iter(|| black_box(my_crate::f())); // `black_box` prevents `f` from being optimized away.
}

Build Scripts

// build.rs (sample pre-build script)

fn main() {
    // You need to rely on env. vars for target; `#[cfg(...)]` are for host.
    let target_os = env::var("CARGO_CFG_TARGET_OS");
}

*See here for list of environment variables set.
Proc Macros🝖

// src/lib.rs (default entry point for proc macros)

extern crate proc_macro;  // Apparently needed to be imported like this.

use proc_macro::TokenStream;

#[proc_macro_attribute]   // Can now be used as `#[my_attribute]`
pub fn my_attribute(_attr: TokenStream, item: TokenStream) -> TokenStream {
    item
}

// Cargo.toml

[package]
name = "my_crate"
version = "0.1.0"

[lib]
proc-macro = true

 

Module trees and imports:
Module Trees

Modules BK EX REF and source files work as follows:

    Module tree needs to be explicitly defined, is not implicitly built from file system tree. 🔗
    Module tree root equals library, app, … entry point (e.g., lib.rs).

Actual module definitions work as follows:

    A mod m {} defines module in-file, while mod m; will read m.rs or m/mod.rs.
    Path of .rs based on nesting, e.g., mod a { mod b { mod c; }}} is either a/b/c.rs or a/b/c/mod.rs.
    Files not pathed from module tree root via some mod m; won't be touched by compiler! 🛑

Namespaces🝖

Rust has three kinds of namespaces:
Namespace Types 	Namespace Functions 	Namespace Macros
mod X {} 	fn X() {} 	macro_rules! X { ... }
X (crate) 	const X: u8 = 1; 	
trait X {} 	static X: u8 = 1; 	
enum X {} 		
union X {} 		
struct X {} 		
← struct X;1 → 	
← struct X();2 → 	

1 Counts in Types and in Functions, defines type X and constant X.
2 Counts in Types and in Functions, defines type X and function X.

    In any given scope, for example within a module, only one item item per namespace can exist, e.g.,
        enum X {} and fn X() {} can coexist
        struct X; and const X cannot coexist
    With a use my_mod::X; all items called X will be imported.

    Due to naming conventions (e.g., fn and mod are lowercase by convention) and common sense (most developers just don't name all things X) you won't have to worry about these kinds in most cases. They can, however, be a factor when designing macros.

 
Cargo

Commands and tools that are good to know.
Command	Description
cargo init	Create a new project for the latest edition.
cargo build	Build the project in debug mode (--release for all optimization).
cargo check	Check if project would compile (much faster).
cargo test	Run tests for the project.
cargo doc --open	Locally generate documentation for your code and dependencies.
cargo run	Run your project, if a binary is produced (main.rs).
     cargo run --bin b	Run binary b. Unifies features with other dependents (can be confusing).
     cargo run -p w	Run main of sub-workspace w. Treats features more as you would expect.
cargo ... --timings	Show what crates caused your build to take so long. 🔥
cargo tree	Show dependency graph.
cargo +{nightly, stable} ...	Use given toolchain for command, e.g., for 'nightly only' tools.
cargo +nightly ...	Some nightly-only commands (substitute ... with command below)
     rustc -- -Zunpretty=expanded	Show expanded macros. 🚧
rustup doc	Open offline Rust documentation (incl. the books), good on a plane!

Here cargo build means you can either type cargo build or just cargo b; and --release means it can be replaced with -r.
 

These are optional rustup components. Install them with rustup component add [tool].
Tool	Description
cargo clippy	Additional (lints) catching common API misuses and unidiomatic code. 🔗
cargo fmt	Automatic code formatter (rustup component add rustfmt). 🔗
 

A large number of additional cargo plugins can be found here.
 
Cross Compilation

🔘 Check target is supported.

🔘 Install target via rustup target install X.

🔘 Install native toolchain (required to link, depends on target).

Get from target vendor (Google, Apple, …), might not be available on all hosts (e.g., no iOS toolchain on Windows).

Some toolchains require additional build steps (e.g., Android's make-standalone-toolchain.sh).

🔘 Update ~/.cargo/config.toml like this:

[target.aarch64-linux-android]
linker = "[PATH_TO_TOOLCHAIN]/aarch64-linux-android/bin/aarch64-linux-android-clang"

or

[target.aarch64-linux-android]
linker = "C:/[PATH_TO_TOOLCHAIN]/prebuilt/windows-x86_64/bin/aarch64-linux-android21-clang.cmd"

🔘 Set environment variables (optional, wait until compiler complains before setting):

set CC=C:\[PATH_TO_TOOLCHAIN]\prebuilt\windows-x86_64\bin\aarch64-linux-android21-clang.cmd
set CXX=C:\[PATH_TO_TOOLCHAIN]\prebuilt\windows-x86_64\bin\aarch64-linux-android21-clang.cmd
set AR=C:\[PATH_TO_TOOLCHAIN]\prebuilt\windows-x86_64\bin\aarch64-linux-android-ar.exe
...

Whether you set them depends on how compiler complains, not necessarily all are needed.

    Some platforms / configurations can be extremely sensitive how paths are specified (e.g., \ vs /) and quoted.

✔️ Compile with cargo build --target=X
 
Tooling Directives

Special tokens embedded in source code used by tooling or preprocessing.
Macros

Inside a declarative BK macro by example BK EX REF macro_rules! implementation these work:
Within Macros	Explanation
$x:ty	Macro capture (here a type).
     $x:item	An item, like a function, struct, module, etc.
     $x:block	A block {} of statements or expressions, e.g., { let x = 5; }
     $x:stmt	A statement, e.g., let x = 1 + 1;, String::new(); or vec![];
     $x:expr	An expression, e.g., x, 1 + 1, String::new() or vec![]
     $x:pat	A pattern, e.g., Some(t), (17, 'a') or _.
     $x:ty	A type, e.g., String, usize or Vec<u8>.
     $x:ident	An identifier, for example in let x = 0; the identifier is x.
     $x:path	A path (e.g. foo, ::std::mem::replace, transmute::<_, int>).
     $x:literal	A literal (e.g. 3, "foo", b"bar", etc.).
     $x:lifetime	A lifetime (e.g. 'a, 'static, etc.).
     $x:meta	A meta item; the things that go inside #[...] and #![...] attributes.
     $x:vis	A visibility modifier; pub, pub(crate), etc.
     $x:tt	A single token tree, see here for more details.
$crate	Special hygiene variable, crate where macros is defined. ?
Documentation

Inside a doc comment BK EX REF these work:
Within Doc Comments	Explanation
```...```	Include a doc test (doc code running on cargo test).
```X,Y ...```	Same, and include optional configurations; with X, Y being ...
     rust	Make it explicit test is written in Rust; implied by Rust tooling.
     -	Compile test. Run test. Fail if panic. Default behavior.
     should_panic	Compile test. Run test. Execution should panic. If not, fail test.
     no_run	Compile test. Fail test if code can't be compiled, Don't run test.
     compile_fail	Compile test but fail test if code can be compiled.
     ignore	Do not compile. Do not run. Prefer option above instead.
     edition2018	Execute code as Rust '18; default is '15.
#	Hide line from documentation (``` # use x::hidden; ```).
[`S`]	Create a link to struct, enum, trait, function, … S.
[`S`](crate::S)	Paths can also be used, in the form of markdown links.
#![globals]

Attributes affecting the whole crate or app:
Opt-Out's	On	Explanation
#![no_std]	C	Don't (automatically) import stdSTD ; use coreSTD instead. REF
#![no_implicit_prelude]	CM	Don't add preludeSTD, need to manually import None, Vec, ... REF
#![no_main]	C	Don't emit main() in apps if you do that yourself. REF
 
Opt-In's	On	Explanation
#![feature(a, b, c)]	C	Rely on features that may never get stabilized, c. Unstable Book. 🚧
 
Builds	On	Explanation
#![windows_subsystem = "x"]	C	On Windows, make a console or windows app. REF 🝖
#![crate_name = "x"]	C	Specifiy current crate name, e.g., when not using cargo. ? REF 🝖
#![crate_type = "bin"]	C	Specifiy current crate type (bin, lib, dylib, cdylib, ...). REF 🝖
#![recursion_limit = "123"]	C	Set compile-time recursion limit for deref, macros, ... REF 🝖
#![type_length_limit = "456"]	C	Limits maximum number of type substitutions. REF 🝖
 
Handlers	On	Explanation
#[panic_handler]	F	Make some fn f(&PanicInfo) -> ! app's panic handler. REF
#[global_allocator]	S	Make static item impl. GlobalAlloc STD global allocator. REF
#[code]

Attributes primarily governing emitted code:
Developer UX	On	Explanation
#[non_exhaustive]	T	Future-proof struct or enum; hint it may grow in future. REF
#[path = "x.rs"]	M	Get module from non-standard file. REF
 
Codegen	On	Explanation
#[inline]	F	Nicely suggest compiler should inline function at call sites. REF
#[inline(always)]	F	Emphatically threaten compiler to inline call, or else. REF
#[inline(never)]	F	Instruct compiler to feel disappointed if it still inlines the function. REF
#[cold]	F	Hint that function probably isn't going to be called. REF
#[target_feature(enable="x")]	F	Enable CPU feature (e.g., avx2) for code of unsafe fn. REF
#[track_caller]	F	Allows fn to find callerSTD for better panic messages. REF
#[repr(X)]1	T	Use another representation instead of the default rust REF one:
     #[repr(C)]	T	Use a C-compatible (f. FFI), predictable (f. transmute) layout. REF
     #[repr(C, u8)]	enum	Give enum discriminant the specified type. REF
     #[repr(transparent)]	T	Give single-element type same layout as contained field. REF
     #[repr(packed(1))]	T	Lower alignment of struct and contained fields, mildly UB prone. REF
     #[repr(align(8))]	T	Raise alignment of struct to given value, e.g., for SIMD types. REF

1 Some representation modifiers can be combined, e.g., #[repr(C, packed(1))].
 
Linking	On	Explanation
#[no_mangle]	*	Use item name directly as symbol name, instead of mangling. REF
#[no_link]	X	Don't link extern crate when only wanting macros. REF
#[link(name="x", kind="y")]	X	Native lib to link against when looking up symbol. REF
#[link_name = "foo"]	F	Name of symbol to search for resolving extern fn. REF
#[link_section = ".sample"]	FS	Section name of object file where item should be placed. REF
#[export_name = "foo"]	FS	Export a fn or static under a different name. REF
#[used]	S	Don't optimize away static variable despite it looking unused. REF
#[quality]

Attributes used by Rust tools to improve code quality:
Code Patterns	On	Explanation
#[allow(X)]	*	Instruct rustc / clippy to ... ignore class X of possible issues. REF
#[warn(X)] 1	*	... emit a warning, mixes well with clippy lints. 🔥 REF
#[deny(X)] 1	*	... fail compilation. REF
#[forbid(X)] 1	*	... fail compilation and prevent subsequent allow overrides. REF
#[deprecated = "msg"]	*	Let your users know you made a design mistake. REF
#[must_use = "msg"]	FTX	Makes compiler check return value is processed by caller. 🔥 REF

1 There is some debate which one is the best to ensure high quality crates. Actively maintained multi-dev crates probably benefit from more aggressive deny or forbid lints; less-regularly updated ones probably more from conservative use of warn (as future compiler or clippy updates may suddenly break otherwise working code with minor issues).
 
Tests	On	Explanation
#[test]	F	Marks the function as a test, run with cargo test. 🔥 REF
#[ignore = "msg"]	F	Compiles but does not execute some #[test] for now. REF
#[should_panic]	F	Test must panic!() to actually succeed. REF
#[bench]	F	Mark function in bench/ as benchmark for cargo bench. 🚧 REF
 
Formatting	On	Explanation
#[rustfmt::skip]	*	Prevent cargo fmt from cleaning up item. 🔗
#![rustfmt::skip::macros(x)]	CM	... from cleaning up macro x. 🔗
#![rustfmt::skip::attributes(x)]	CM	... from cleaning up attribute x. 🔗
 
Documentation	On	Explanation
#[doc = "Explanation"]	*	Same as adding a /// doc comment. 🔗
#[doc(alias = "other")]	*	Provide another name users can search for in the docs. 🔗
#[doc(hidden)]	*	Prevent item from showing up in docs. 🔗
#![doc(html_favicon_url = "")]	C	Sets the favicon for the docs. 🔗
#![doc(html_logo_url = "")]	C	The logo used in the docs. 🔗
#![doc(html_playground_url = "")]	C	Generates Run buttons and uses given service. 🔗
#![doc(html_root_url = "")]	C	Base URL for links to external crates. 🔗
#![doc(html_no_source)]	C	Prevents source from being included in docs. 🔗
#[macros]

Attributes related to the creation and use of macros:
Macros By Example	On	Explanation
#[macro_export]	!	Export macro_rules! as pub on crate level REF
#[macro_use]	MX	Let macros persist past modules; or import from extern crate. REF
 
Proc Macros	On	Explanation
#[proc_macro]	F	Mark fn as function-like procedural macro callable as m!(). REF
#[proc_macro_derive(Foo)]	F	Mark fn as derive macro which can #[derive(Foo)]. REF
#[proc_macro_attribute]	F	Mark fn as attribute macro which can understand new #[x]. REF
 
Derives	On	Explanation
#[derive(X)]	T	Let some proc macro provide a goodish impl of trait X. 🔥 REF
#[cfg]

Attributes governing conditional compilation:
Config Attributes	On	Explanation
#[cfg(X)]	*	Include item if configuration X holds. REF
#[cfg(all(X, Y, Z))]	*	Include item if all options hold. REF
#[cfg(any(X, Y, Z))]	*	Include item if at least one option holds. REF
#[cfg(not(X))]	*	Include item if X does not hold. REF
#[cfg_attr(X, foo = "msg")]	*	Apply #[foo = "msg"] if configuration X holds. REF
 

    ⚠️ Note, options can generally be set multiple times, i.e., the same key can show up with multiple values. One can expect #[cfg(target_feature = "avx")] and #[cfg(target_feature = "avx2")] to be true at the same time.

 
Known Options	On	Explanation
#[cfg(target_arch = "x86_64")]	*	The CPU architecture crate is compiled for. REF
#[cfg(target_feature = "avx")]	*	Whether a particular class of instructions is available. REF
#[cfg(target_os = "macos")]	*	Operating system your code will run on. REF
#[cfg(target_family = "unix")]	*	Family operating system belongs to. REF
#[cfg(target_env = "msvc")]	*	How DLLs and functions are interfaced with on OS. REF
#[cfg(target_endian = "little")]	*	Main reason your cool new zero-cost protocol fails. REF
#[cfg(target_pointer_width = "64")]	*	How many bits pointers, usize and CPU words have. REF
#[cfg(target_vendor = "apple")]	*	Manufacturer of target. REF
#[cfg(debug_assertions)]	*	Whether debug_assert!() and friends would panic. REF
#[cfg(panic = "unwind")]	*	Whether unwind or abort will happen on panic. ?
#[cfg(proc_macro)]	*	Wheter crate compiled as proc macro. REF
#[cfg(test)]	*	Whether compiled with cargo test. 🔥 REF
#[cfg(feature = "serde")]	*	When your crate was compiled with feature serde. 🔥 REF
build.rs

Environment variables and outputs related to the pre-build script.
Input Environment	Explanation 🔗
CARGO_FEATURE_X	Environment variable set for each feature x activated.
     CARGO_FEATURE_SERDE	If feature serde were enabled.
     CARGO_FEATURE_SOME_FEATURE	If feature some-feature were enabled; dash - converted to _.
CARGO_CFG_X	Exposes cfg's; joins mult. opts. by , and converts - to _.
     CARGO_CFG_TARGET_OS=macos	If target_os were set to macos.
     CARGO_CFG_TARGET_FEATURE=avx,avx2	If target_feature were set to avx and avx2.
OUT_DIR	Where output should be placed.
TARGET	Target triple being compiled for.
HOST	Host triple (running this build script).
PROFILE	Can be debug or release.

Available in build.rs via env::var()?. List not exhaustive.
 
Output String	Explanation 🔗
cargo:rerun-if-changed=PATH	(Only) run this build.rs again if PATH changed.
cargo:rerun-if-env-changed=VAR	(Only) run this build.rs again if environment VAR changed.
cargo:rustc-link-lib=[KIND=]NAME	Link native library as if via -l option.
cargo:rustc-link-search=[KIND=]PATH	Search path for native library as if via -L option.
cargo:rustc-flags=FLAGS	Add special flags to compiler. ?
cargo:rustc-cfg=KEY[="VALUE"]	Emit given cfg option to be used for later compilation.
cargo:rustc-env=VAR=VALUE 	Emit var accessible via env!() in crate during compilation.
cargo:rustc-cdylib-link-arg=FLAG 	When building a cdylib, pass linker flag.
cargo:warning=MESSAGE	Emit compiler warning.

Emitted from build.rs via println!(). List not exhaustive.

For the On column in attributes:
C means on crate level (usually given as #![my_attr] in the top level file).
M means on modules.
F means on functions.
S means on static.
T means on types.
X means something special.
! means on macros.
* means on almost any item.
Working with Types
Types, Traits, Generics

Allowing users to bring their own types and avoid code duplication.
Types & Traits
Types
Type Equivalence and Conversions
Implementations — impl S { }
Traits — trait T { }
Implementing Traits for Types — impl T for S { }
Traits vs. Interfaces
Generics
Type Constructors — Vec<>
Generic Parameters — <T>
Const Generics — [T; N] and S<const N: usize>
Bounds (Simple) — where T: X
Bounds (Compound) — where T: X + Y
Implementing Families — impl<>
Blanket Implementations — impl<T> X for T { ... }
Advanced Concepts🝖
Trait Parameters — Trait<In> { type Out; }
Trait Authoring Considerations (Abstract)
Trait Authoring Considerations (Example)
Dynamic / Zero Sized Types
?Sized
Generics and Lifetimes — <'a>

Examples expand by clicking.
Foreign Types and Traits

A visual overview of types and traits in your crate and upstream.
u8
u16
f32
bool
char
Primitive Types
File
String
Builder
Composite Types
Vec<T>
Vec<T>
Vec<T>
&'a T
&'a T
&'a T
&mut 'a T
&mut 'a T
&mut 'a T
[T; n]
[T; n]
[T; n]
Type Constructors
Vec<T>
Vec<T>
f<T>() {}
drop() {}
Functions
PI
dbg!
Other
⌾ Copy
⌾ Deref
type Tgt;
⌾ From<T>
⌾ From<T>
⌾ From<T>
Traits
Items defined in upstream crates.
⌾ Serialize
⌾ Transport
⌾ ShowHex
Device
⌾ From<u8>
Foreign trait impl. for local type.
String
⌾ Serialize
Local trait impl. for foreign type.
String
⌾ From<u8>
🛑 Illegal, foreign trait for f. type.
String
⌾ From<Port>
Exception: Legal if used type local.
Port
⌾ From<u8>
⌾ From<u16>
Mult. impl. of trait with differing IN params.
Container
⌾ Deref
Tgt = u8;
⌾ Deref
Tgt = f32;
🛑 Illegal impl. of trait with differing OUT params.
T
T
T
⌾ ShowHex
Blanket impl. of trait for any type.
Your crate.

Examples of traits and types, and which traits you can implement for which type.
Type Conversions

How to get B when you have A?
Intro

fn f(x: A) -> B {
    // How can you obtain B from A?
}

Method	Explanation
Identity	Trivial case, B is exactly A.
Computation	Create and manipulate instance of B by writing code transforming data.
Casts	On-demand conversion between types where caution is advised.
Coercions	Automatic conversion within 'weakening ruleset'.1
Subtyping	Automatic conversion within 'same-layout-different-lifetimes ruleset'.1
 

1 While both convert A to B, coercions generally link to an unrelated B (a type "one could reasonably expect to have different methods"), while subtyping links to a B differing only in lifetimes.
Computation (Traits)

fn f(x: A) -> B {
    x.into()
}

Bread and butter way to get B from A. Some traits provide canonical, user-computable type relations:
Trait	Example	Trait implies ...
impl From<A> for B {}	a.into()	Obvious, always-valid relation.
impl TryFrom<A> for B {}	a.try_into()?	Obvious, sometimes-valid relation.
impl Deref for A {}	*a	A is smart pointer carrying B; also enables coercions.
impl AsRef<B> for A {}	a.as_ref()	A can be viewed as B.
impl AsMut<B> for A {}	a.as_mut()	A can be mutably viewed as B.
impl Borrow<B> for A {}	a.borrow()	A has borrowed analog B (behaving same under Eq, ...).
impl ToOwned for A { ... }	a.to_owned()	A has owned analog B.
Casts

fn f(x: A) -> B {
    x as B
}

Convert types with keyword as if conversion relatively obvious but might cause issues. NOM
A	B	Example	Explanation
Ptr	Ptr	device_ptr as *const u8	If *A, *B are Sized.
Ptr	Integer	device_ptr as usize	
Integer	Ptr	my_usize as *const Device	
Number	Number	my_u8 as u16	Often surprising behavior. ↑
enum w/o fields	Integer	E::A as u8	
bool	Integer	true as u8	
char	Integer	'A' as u8	
&[T; N]	*const T	my_ref as *const u8	
fn(...)	Ptr	f as *const u8	If Ptr is Sized.
fn(...)	Integer	f as usize	
 

Where Ptr, Integer, Number are just used for brevity and actually mean:

    Ptr any *const T or *mut T;
    Integer any countable u8 ... i128;
    Number any Integer, f32, f64.

    Opinion 💬 — Casts, esp. Number - Number, can easily go wrong. If you are concerned with correctness, consider more explicit methods instead.

Coercions

fn f(x: A) -> B {
    x
}

Automatically weaken type A to B; types can be substantially1 different. NOM
A	B	Explanation
&mut T	&T	Pointer weakening.
&mut T	*mut T	-
&T	*const T	-
*mut T	*const T	-
&T	&U	Deref, if impl Deref<Target=U> for T.
T	U	Unsizing, if impl CoerceUnsized<U> for T.2 🚧
T	V	Transitivity, if T coerces to U and U to V.
|x| x + x	fn(u8) -> u8	Non-capturing closure, to equivalent fn pointer.
 

1 Substantially meaning one can regularly expect a coercion result B to be an entirely different type (i.e., have entirely different methods) than the original type A.

2 Does not quite work in example above as unsized can't be on stack; imagine f(x: &A) -> &B instead. Unsizing works by default for:

    [T; n] to [T]
    T to dyn Trait if impl Trait for T {}.
    Foo<..., T, ...> to Foo<..., U, ...> under arcane 🔗 circumstances.

Subtyping🝖

fn f(x: A) -> B {
    x
}

Automatically converts A to B for types only differing in lifetimes NOM - subtyping examples:
A(subtype)	B(supertype)	Explanation
&'static u8	&'a u8	Valid, forever-pointer is also transient-pointer.
&'a u8	&'static u8	🛑 Invalid, transient should not be forever.
&'a &'b u8	&'a &'b u8	Valid, same thing. But now things get interesting. Read on.
&'a &'static u8	&'a &'b u8	Valid, &'static u8 is also &'b u8; covariant inside &.
&'a mut &'static u8	&'a mut &'b u8	🛑 Invalid and surprising; invariant inside &mut.
Box<&'static u8>	Box<&'a u8>	Valid, Box with forever is also box with transient; covariant.
Box<&'a u8>	Box<&'static u8>	🛑 Invalid, Box with transient may not be with forever.
Box<&'a mut u8>	Box<&'a u8>	🛑 ⚡ Invalid, see table below, &mut u8 never was a &u8.
Cell<&'static u8>	Cell<&'a u8>	🛑 Invalid, Cell are never something else; invariant.
fn(&'static u8)	fn(&'a u8)	🛑 If fn needs forever it may choke on transients; contravar.
fn(&'a u8)	fn(&'static u8)	But sth. that eats transients can be(!) sth. that eats forevers.
for<'r> fn(&'r u8)	fn(&'a u8)	Higher-ranked type for<'r> fn(&'r u8) is also fn(&'a u8).
 

In contrast, these are not🛑 examples of subtyping:
A	B	Explanation
u16	u8	🛑 Obviously invalid; u16 should never automatically be u8.
u8	u16	🛑 Invalid by design; types w. different data still never subtype even if they could.
&'a mut u8	&'a u8	🛑 Trojan horse, not subtyping; but coercion (still works, just not subtyping).
 
Variance🝖

fn f(x: A) -> B {
    x
}

Automatically converts A to B for types only differing in lifetimes NOM - subtyping variance rules:

    A longer lifetime 'a that outlives a shorter 'b is a subtype of 'b.
    Implies 'static is subtype of all other lifetimes 'a.
    Whether types with parameters (e.g., &'a T) are subtypes of each other the following variance table is used:



Construct1	'a	T	U
&'a T	covariant	covariant	
&'a mut T	covariant	invariant	
Box<T>		covariant	
Cell<T>		invariant	
fn(T) -> U		contravariant	covariant
*const T		covariant	
*mut T		invariant	

Covariant means if A is subtype of B, then T[A] is subtype of T[B].
Contravariant means if A is subtype of B, then T[B] is subtype of T[A].
Invariant means even if A is subtype of B, neither T[A] nor T[B] will be subtype of the other.

1 Compounds like struct S<T> {} obtain variance through their used fields, usually becoming invariant if multiple variances are mixed.

    💡 In other words, 'regular' types are never subtypes of each other (e.g., u8 is not subtype of u16), and a Box<u32> would never be sub- or supertype of anything. However, generally a Box<A>, can be subtype of Box<B> (via covariance) if A is a subtype of B, which can only happen if A and B are 'sort of the same type that only differed in lifetimes', e.g., A being &'static u32 and B being &'a u32.

gg1


Coding Guides
Idiomatic Rust

If you are used to Java or C, consider these.
Idiom	Code
Think in Expressions	y = if x { a } else { b };
	y = loop { break 5 };
	fn f() -> u32 { 0 }
Think in Iterators	(1..10).map(f).collect()
	names.iter().filter(|x| x.starts_with("A"))
Handle Absence with ?	y = try_something()?;
	get_option()?.run()?
Use Strong Types	enum E { Invalid, Valid { ... } } over ERROR_INVALID = -1
	enum E { Visible, Hidden } over visible: bool
	struct Charge(f32) over f32
Provide Builders	Car::new("Model T").hp(20).build();
Don't Panic	Panics are not exceptions, they may abort() entire process!
	Only raise panic! if impossible to handle error, better return Option or Result.
Split Implementations	Generic types S<T> can have a separate impl per T.
	Rust doesn't have OO, but with separate impl you can get specialization.
Unsafe	Avoid unsafe {}, often safer, faster solution without it. Exception: FFI.
Implement Traits	#[derive(Debug, Copy, ...)] and custom impl where needed.
Tooling	With clippy you can improve your code quality.
	Formatting with rustfmt helps others to read your code.
	Add unit tests BK (#[test]) to ensure your code works.
	Add doc tests BK (``` my_api::f() ```) to ensure docs match code.
Documentation	Annotate your APIs with doc comments that can show up on docs.rs.
	Don't forget to include a summary sentence and the Examples heading.
	If applicable: Panics, Errors, Safety, Abort and Undefined Behavior.
 

    🔥 We highly recommend you also follow the API Guidelines (Checklist) for any shared project! 🔥

 
Async-Await 101

If you are familiar with async / await in C# or TypeScript, here are some things to keep in mind:
Basics
Construct	Explanation
async	Anything declared async always returns an impl Future<Output=_>. STD
     async fn f() {}	Function f returns an impl Future<Output=()>.
     async fn f() -> S {}	Function f returns an impl Future<Output=S>.
     async { x }	Transforms { x } into an impl Future<Output=X>.
let sm = f(); 	Calling f() that is async will not execute f, but produce state machine sm. 1 2
     sm = async { g() };	Likewise, does not execute the { g() } block; produces state machine.
runtime.block_on(sm);	Outside an async {}, schedules sm to actually run. Would execute g(). 3 4
sm.await	Inside an async {}, run sm until complete. Yield to runtime if sm not ready.

1 Technically async transforms following code into anonymous, compiler-generated state machine type; f() instantiates that machine.
2 The state machine always impl Future, possibly Send & co, depending on types used inside async.
3 State machine driven by worker thread invoking Future::poll() via runtime directly, or parent .await indirectly.
4 Rust doesn't come with runtime, need external crate instead, e.g., tokio. Also, more helpers in futures crate.
Execution Flow

At each x.await, state machine passes control to subordinate state machine x. At some point a low-level state machine invoked via .await might not be ready. In that the case worker thread returns all the way up to runtime so it can drive another Future. Some time later the runtime:

    might resume execution. It usually does, unless sm / Future dropped.
    might resume with the previous worker or another worker thread (depends on runtime).

Simplified diagram for code written inside an async block :

       consecutive_code();           consecutive_code();           consecutive_code();
START --------------------> x.await --------------------> y.await --------------------> READY
// ^                          ^     ^                               Future<Output=X> ready -^
// Invoked via runtime        |     |
// or an external .await      |     This might resume on another thread (next best available),
//                            |     or NOT AT ALL if Future was dropped.
//                            |
//                            Execute `x`. If ready: just continue execution; if not, return
//                            this thread to runtime.

Caveats 🛑

With the execution flow in mind, some considerations when writing code inside an async construct:
Constructs 1	Explanation
sleep_or_block();	Definitely bad 🛑, never halt current thread, clogs executor.
set_TL(a); x.await; TL();	Definitely bad 🛑, await may return from other thread, thread local invalid.
s.no(); x.await; s.go();	Maybe bad 🛑, await will not return if Future dropped while waiting. 2
Rc::new(); x.await; rc();	Non-Send types prevent impl Future from being Send; less compatible.

1 Here we assume s is any non-local that could temporarily be put into an invalid state; TL is any thread local storage, and that the async {} containing the code is written without assuming executor specifics.
2 Since Drop is run in any case when Future is dropped, consider using drop guard that cleans up / fixes application state if it has to be left in bad condition across .await points.
 
Closures in APIs

There is a subtrait relationship Fn : FnMut : FnOnce. That means a closure that implements Fn STD also implements FnMut and FnOnce. Likewise a closure that implements FnMut STD also implements FnOnce. STD

From a call site perspective that means:
Signature	Function g can call …	Function g accepts …
g<F: FnOnce()>(f: F)	… f() once.	Fn, FnMut, FnOnce
g<F: FnMut()>(mut f: F)	… f() multiple times.	Fn, FnMut
g<F: Fn()>(f: F)	… f() multiple times.	Fn

Notice how asking for a Fn closure as a function is most restrictive for the caller; but having a Fn closure as a caller is most compatible with any function.
 

From the perspective of someone defining a closure:
Closure	Implements*	Comment
|| { moved_s; } 	FnOnce	Caller must give up ownership of moved_s.
|| { &mut s; } 	FnOnce, FnMut	Allows g() to change caller's local state s.
|| { &s; } 	FnOnce, FnMut, Fn	May not mutate state; but can share and reuse s.

* Rust prefers capturing by reference (resulting in the most "compatible" Fn closures from a caller perspective), but can be forced to capture its environment by copy or move via the move || {} syntax.
 

That gives the following advantages and disadvantages:
Requiring	Advantage	Disadvantage
F: FnOnce	Easy to satisfy as caller.	Single use only, g() may call f() just once.
F: FnMut	Allows g() to change caller state.	Caller may not reuse captures during g().
F: Fn	Many can exist at same time.	Hardest to produce for caller.
 
Unsafe, Unsound, Undefined

Unsafe leads to unsound. Unsound leads to undefined. Undefined leads to the dark side of the force.
Safe Code

Safe Code

    Safe has narrow meaning in Rust, vaguely 'the intrinsic prevention of undefined behavior (UB)'.
    Intrinsic means the language won't allow you to use itself to cause UB.
    Making an airplane crash or deleting your database is not UB, therefore 'safe' from Rust's perspective.
    Writing to /proc/[pid]/mem to self-modify your code is also 'safe', resulting UB not caused intrinsincally.

let y = x + x;  // Safe Rust only guarantees the execution of this code is consistent with
print(y);       // 'specification' (long story ...). It does not guarantee that y is 2x
                // (X::add might be implemented badly) nor that y is printed (Y::fmt may panic).

Unsafe Code

Unsafe Code

    Code marked unsafe has special permissions, e.g., to deref raw pointers, or invoke other unsafe functions.
    Along come special promises the author must uphold to the compiler, and the compiler will trust you.
    By itself unsafe code is not bad, but dangerous, and needed for FFI or exotic data structures.

// `x` must always point to race-free, valid, aligned, initialized u8 memory.
unsafe fn unsafe_f(x: *mut u8) {
    my_native_lib(x);
}

Undefined Behavior

Undefined Behavior (UB)

    As mentioned, unsafe code implies special promises to the compiler (it wouldn't need be unsafe otherwise).
    Failure to uphold any promise makes compiler produce fallacious code, execution of which leads to UB.
    After triggering undefined behavior anything can happen. Insidiously, the effects may be 1) subtle, 2) manifest far away from the site of violation or 3) be visible only under certain conditions.
    A seemingly working program (incl. any number of unit tests) is no proof UB code might not fail on a whim.
    Code with UB is objectively dangerous, invalid and should never exist.

if maybe_true() {
    let r: &u8 = unsafe { &*ptr::null() };   // Once this runs, ENTIRE app is undefined. Even if
} else {                                     // line seemingly didn't do anything, app might now run
    println!("the spanish inquisition");     // both paths, corrupt database, or anything else.
}

Unsound Code

Unsound Code

    Any safe Rust that could (even only theoretically) produce UB for any user input is always unsound.
    As is unsafe code that may invoke UB on its own accord by violating above-mentioned promises.
    Unsound code is a stability and security risk, and violates basic assumption many Rust users have.

fn unsound_ref<T>(x: &T) -> &u128 {      // Signature looks safe to users. Happens to be
    unsafe { mem::transmute(x) }         // ok if invoked with an &u128, UB for practically
}                                        // everything else.

 

    Responsible use of Unsafe 💬

        Do not use unsafe unless you absolutely have to.
        Follow the Nomicon, Unsafe Guidelines, always uphold all safety invariants, and never invoke UB.
        Minimize the use of unsafe and encapsulate it in small, sound modules that are easy to review.
        Never create unsound abstractions; if you can't encapsulate unsafe properly, don't do it.
        Each unsafe unit should be accompanied by plain-text reasoning outlining its safety.

 
Adversarial Code 🝖

Adversarial code is safe 3rd party code that compiles but does not follow API expectations, and might interfere with your own (safety) guarantees.
You author	User code may possibly ...
fn g<F: Fn()>(f: F) { ... }	Unexpectedly panic.
struct S<X: T> { ... }	Implement T badly, e.g., misuse Deref, ...
macro_rules! m { ... }	Do all of the above; call site can have weird scope.
 
Risk Pattern	Description
#[repr(packed)]	Packed alignment can make reference &s.x invalid.
impl std::... for S {}	Any trait impl, esp. std::ops may be broken. In particular ...
     impl Deref for S {}	May randomly Deref, e.g., s.x != s.x, or panic.
     impl PartialEq for S {}	May violate equality rules; panic.
     impl Eq for S {}	May cause s != s; panic; must not use s in HashMap & co.
     impl Hash for S {}	May violate hashing rules; panic; must not use s in HashMap & co.
     impl Ord for S {}	May violate ordering rules; panic; must not use s in BTreeMap & co.
     impl Index for S {}	May randomly index, e.g. s[x] != s[x]; panic.
     impl Drop for S {}	May run code or panic end of scope {}, during assignment s = new_s.
panic!()	User code can panic any time, resulting in abort or unwind.
catch_unwind(|| s.f(panicky))	Also, caller might force observation of broken state in s.
let ... = f();	Variable name can affect order of Drop execution. 1 🛑

1 Notably, when you rename a variable from _x to _ you will also change Drop behavior since you change semantics. A variable named _x will have Drop::drop() executed at the end of its scope, a variable named _ can have it executed immediately on 'apparent' assignment ('apparent' because a binding named _ means wildcard REF discard this, which will happen as soon as feasible, often right away)!
 

    Implications

        Generic code cannot be safe if safety depends on type cooperation w.r.t. most (std::) traits.
        If type cooperation is needed you must use unsafe traits (prob. implement your own).
        You must consider random code execution at unexpected places (e.g., re-assignments, scope end).
        You may still be observable after a worst-case panic.

    As a corollary, safe-but-deadly code (e.g., airplane_speed<T>()) should probably also follow these guides.

 
API Stability

When updating an API, these changes can break client code.RFC Major changes (🔴) are definitely breaking, while minor changes (🟡) might be breaking:
 
Crates
🔴 Making a crate that previously compiled for stable require nightly.
🟡 Altering use of Cargo features (e.g., adding or removing features).
 
Modules
🔴 Renaming / moving / removing any public items.
🟡 Adding new public items, as this might break code that does use your_crate::*.
 
Structs
🔴 Adding private field when all current fields public.
🔴 Adding public field when no private field exists.
🟡 Adding or removing private fields when at least one already exists (before and after the change).
🟡 Going from a tuple struct with all private fields (with at least one field) to a normal struct, or vice versa.
 
Enums
🔴 Adding new variants; can be mitigated with early #[non_exhaustive] REF
🔴 Adding new fields to a variant.
 
Traits
🔴 Adding a non-defaulted item, breaks all existing impl T for S {}.
🔴 Any non-trivial change to item signatures, will affect either consumers or implementors.
🟡 Adding a defaulted item; might cause dispatch ambiguity with other existing trait.
🟡 Adding a defaulted type parameter.
 
Traits
🔴 Implementing any "fundamental" trait, as not implementing a fundamental trait already was a promise.
🟡 Implementing any non-fundamental trait; might also cause dispatch ambiguity.
 
Inherent Implementations
🟡 Adding any inherent items; might cause clients to prefer that over trait fn and produce compile error.
 
Signatures in Type Definitions
🔴 Tightening bounds (e.g., <T> to <T: Clone>).
🟡 Loosening bounds.
🟡 Adding defaulted type parameters.
🟡 Generalizing to generics.
Signatures in Functions
🔴 Adding / removing arguments.
🟡 Introducing a new type parameter.
🟡 Generalizing to generics.
 
Behavioral Changes
🔴 / 🟡 Changing semantics might not cause compiler errors, but might make clients do wrong thing.
 
Misc
Links & Services

These are other great guides and tables.
Cheat Sheets	Description
Rust Learning⭐	Probably the best collection of links about learning Rust.
Functional Jargon in Rust	A collection of functional programming jargon explained in Rust.
Periodic Table of Types	How various types and references correlate.
Futures	How to construct and work with futures.
Rust Iterator Cheat Sheet	Summary of iterator-related methods from std::iter and itertools.
Type-Based Rust Cheat Sheet	Lists common types and how they convert.
 

All major Rust books developed by the community.
Books ️📚	Description
The Rust Programming Language	Standard introduction to Rust, start here if you are new.
     API Guidelines	How to write idiomatic and re-usable Rust.
     Asynchronous Programming 🚧	Explains async code, Futures, ...
     Design Patterns	Idioms, Patterns, Anti-Patterns.
     Edition Guide	Working with Rust 2015, Rust 2018, and beyond.
     Guide to Rustc Development	Explains how the compiler works internally.
     Little Book of Rust Macros	Community's collective knowledge of Rust macros.
     Reference 🚧	Reference of the Rust language.
     RFC Book	Look up accepted RFCs and how they change the language.
     Performance Book	Techniques to improve the speed and memory usage.
     Rust Cookbook	Collection of simple examples that demonstrate good practices.
     Rust in Easy English	Explains concepts in simplified English, good alternative start.
     Rust for the Polyglot Programmer	A guide for the experienced programmer.
     Rustdoc Book	Tips how to customize cargo doc and rustdoc.
     Rustonomicon	Dark Arts of Advanced and Unsafe Rust Programming.
     Unsafe Code Guidelines 🚧	Concise information about writing unsafe code.
     Unstable Book	Information about unstable items, e.g, #![feature(...)].
The Cargo Book	How to use cargo and write Cargo.toml.
The CLI Book	Information about creating CLI tools.
The Embedded Book	Working with embedded and #![no_std] devices.
     The Embedonomicon	First #![no_std] from scratch on a Cortex-M.
The WebAssembly Book	Working with the web and producing .wasm files.
     The wasm-bindgen Guide	How to bind Rust and JavaScript APIs in particular.

For more inofficial books see Little Book of Rust Books.
 

Comprehensive lookup tables for common components.
Tables 📋	Description
Rust Changelog	See all the things that changed in a particular version.
Rust Forge	Lists release train and links for people working on the compiler.
     Rust Platform Support	All supported platforms and their Tier.
     Rust Component History	Check nightly status of various Rust tools for a platform.
ALL the Clippy Lints	All the clippy lints you might be interested in.
Configuring Rustfmt	All rustfmt options you can use in .rustfmt.toml.
Compiler Error Index	Ever wondered what E0404 means?
 

Online services which provide information or tooling.
Services ⚙️	Description
crates.io	All 3rd party libraries for Rust.
std.rs	Shortcut to std documentation.
docs.rs	Documentation for 3rd party libraries, automatically generated from source.
lib.rs	Unofficial overview of quality Rust libraries and applications.
caniuse.rs	Check which Rust version introduced or stabilized a feature.
Rust Playground	Try and share snippets of Rust code.
Rust Search Extension	Browser extension to search docs, crates, attributes, books, …
 
Printing & PDF

    Want this Rust cheat sheet as a PDF? Download the latest PDF here. Alternatively, generate it yourself via File > Print and then "Save as PDF" (works great in Chrome, has some issues in Firefox).

Ralf Biedert, 2022 – cheats.rs

Legal & Privacy


 QuickRef.ME
Rust cheatsheet

The Rust quick reference cheat sheet that aims at providing help on writing basic syntax and methods.
#Getting Started
Hello_World.rs

fn main() {
  println!("Hello, World!");
}

Compiling and Running

$ rustc Hello_World.rs
$ ./Hello_World
Hello, World!

Primitive types
bool 	Boolean (true / false)
char 	character
f32, f64 	32-bits, 64-bits floats
i64, i32, i16, i8 	signed 16- ... integers
u64, u32, u16, u8 	unsigned 16-bits, ... integers
isize 	pointer-sized signed integers
usize 	pointer-sized unsigned integers

See: Rust Types
Formatting

// Single Placeholder
println!("{}", 1);

// Multiple Placeholder
println!("{} {}", 1, 3);

// Positional Arguments
println!("{0} is {1} {2}, also {0} is a {3} programming language", "Rust", "cool", "language", "safe");

// Named Arguments
println!("{country} is a diverse nation with unity.", country = "India");

// Placeholder traits :b for binary, :0x is for hex and :o is octal
println!("Let us print 76 is binary which is {:b} , and hex equivalent is {:0x} and octal equivalent is {:o}", 76, 76, 76);

// Debug Trait
println!("Print whatever we want to here using debug trait {:?}", (76, 'A', 90));

// New Format Strings in 1.58
let x = "world";
println!("Hello {x}!");

Printing Styles

// Prints the output
print!("Hello World\n");

// Appends a new line after printing
println!("Appending a new line");

// Prints as an error
eprint!("This is an error\n");

// Prints as an error with new line
eprintln!("This is an error with new line");

Variables

// Initializing and declaring a variable
let some_variable = "This_is_a_variable";

// Making a variable mutable
let mut mutable_variable = "Mutable";

// Assigning multiple variables
let (name, age) = ("ElementalX", 20);

// (Global) constant
const SCREAMING_SNAKE_CASE:i64 = 9;

Comments

// Line Comments
/*.............Block Comments */
/// Outer doc comments
//! Inner doc comments

See: Comment
Functions

fn test(){
  println!("This is a function!");
}

fn main(){
  test();
}

See: Functions
#Rust Types
Integer

let mut a: u32 = 8;
let b: u64 = 877;
let c: i64 = 8999;
let d = -90;

Floating-Point

let mut sixty_bit_float: f64 = 89.90;
let thirty_two_bit_float: f32 = 7.90;
let just_a_float = 69.69;

Boolean

let true_val: bool = true;
let false_val: bool = false;
let just_a_bool = true;
let is_true = 8 < 5;  // => false

Character

let first_letter_of_alphabet = 'a';
let explicit_char: char = 'F';
let implicit_char = '8';
let emoji = "\u{1f600}";   // => 😀

String Literal

let community_name = "AXIAL";
let no_of_members: &str = "ten";

println!("The name of the community is {community_name} and it has {no_of_members} members");

See: Strings
Arrays

┌─────┬─────┬─────┬─────┬─────┬─────┐
| 92  | 97  | 98  | 99  | 98  | 94  |
└─────┴─────┴─────┴─────┴─────┴─────┘
   0     1     2     3     4     5

let array: [i64; 6] = [92,97,98,99,98,94];

Multi-Dimensional Array

     j0   j1   j2   j3   j4   j5
   ┌────┬────┬────┬────┬────┬────┐
i0 | 1  | 2  | 3  | 4  | 5  | 6  |
   ├────┼────┼────┼────┼────┼────┤
i1 | 6  | 5  | 4  | 3  | 2  | 1  |
   └────┴────┴────┴────┴────┴────┘

let array: [[i64; 6] ;2] = [
            [1,2,3,4,5,6],
            [6,5,4,3,2,1]];

Mutable Array

let mut array: [i32 ; 3] = [2,6,10];

array[1] = 4;
array[2] = 6;

Use the mut keyword to make it mutable.
Slices

let mut array: [ i64; 4] = [1,2,3,4];
let mut slices: &[i64] = &array[0..3] // Lower range is inclusive and upper range is exclusive

println!("The elements of the slices are : {slices:?}");

Vectors

let some_vector = vec![1,2,3,4,5]; 

A vector is declared using the vec! macro.
Tuples

let tuple = (1, 'A' , "Cool", 78, true);

#Rust Strings
String Literal

let cs:&str = "cheat sheet";

// => Share cheat sheet for developers
println!("Share {cs} for developers");

String Object

// Creating an empty string object
let my_string = String::new;

// Converting to a string object
let S_string = a_string.to_string()

// Creating an initialized string object
let lang = String::from("Rust");  
println!("First language is {lang}");

.capacity()

let rand = String::from("Random String");
rand.capacity()  // => 13

Calculates the capacity of the string in bytes.
.contains()

let name = String::from("ElementalX");
name.contains("Element") // => true

Checks if the substring is contained inside the original string or not.
Pushing a single character

let mut half_text = String::from("Hal");
half_text.push('f');    // => Half

Pushing an entire String

let mut hi = String::from("Hey there...");
hi.push_str("How are you doing??");

// => Hey there...How are you doing??
println!("{hi}");

#Rust Operators
Comparison Operators
e == f 	e is equal to f
e != f 	e is NOT equal to f
e < f 	e is less than f
e > f 	e is greater f
e <= f 	e is less than or equal to f
e >= f 	e is greater or equal to f

let (e, f) = (1, 100);

let greater = f > e;        // => true
let less = f < e;           // => false
let greater_equal = f >= e; // => true
let less_equal = e <= f;    // => true
let equal_to = e == f;      // => false
let not_equal_to = e != f;  // => true

Arithmetic Operators
a + b 	a is added to b
a - b 	b is subtracted from a
a / b 	a is divided by b
a % b 	Gets remainder of a by dividing with b
a * b 	a is multiplied with b

let (a, b) = (4, 5);

let sum: i32 = a + b;            // => 9
let subtractions: i32 = a - b;   // => -1
let multiplication: i32 = a * b; // => 20
let division: i32 = a / b;       // => 0
let modulus: i32 = a % b;        // => 4

Bitwise Operators
g & h 	Binary AND
g | h 	Binary OR
g ^ h 	Binary XOR
g ~ h 	Binary one's complement
g << h 	Binary shift left
g >> h 	Binary shift right

let (g, h) = (0x1, 0x2);

let bitwise_and = g & h;  // => 0
let bitwise_or = g | h;   // => 3
let bitwise_xor = g ^ h;  // => 3
let right_shift = g >> 2; // => 0
let left_shift = h << 4;  // => 32 

Logical Operators
c && d 	Both are true (AND)
c || d 	Either is true (OR)
!c 	c is false (NOT)

let (c, d) = (true, false);

let and = c && d;  // => false
let or  = c || d;  // => true
let not = !c;      // => false

Compound Assignment Operator

let mut k = 9;
let mut l = k;

k += l 	Add a value and assign, then k=9
k -= l 	Substrate a value and assign, then k=18
k /= l 	Divide a value and assign, then k=9
k *= l 	Multiply a value and assign, then k=81
k |= l 	Bitwise OR and assign, then k=89
#Rust Flow Control
If Expression

let case1: i32 = 81;
let case2: i32 = 82;

if case1 < case2 {
  println!("case1 is greater than case2");
}

If...Else Expression

let case3 = 8;
let case4 = 9;

if case3 >= case4 {
  println!("case3 is better than case4");
} else {
  println!("case4 is greater than case3");
}

If...Else...if...Else Expression

let foo = 12;
let bar = 13;

if foo == bar {
  println!("foo is equal to bar");
} else if foo < bar {
  println!("foo less than bar");
} else if foo != bar {
  println!("foo is not equal to bar");
} else {
  println!("Nothing");
}

If...Let Expression

let mut arr1:[i64 ; 3] = [1,2,3];
if let[1,2,_] = arr1{
    println!("Works with array");
}

let mut arr2:[&str; 2] = ["one", "two"];
if let["Apple", _] = arr2{
    println!("Works with str array too");
}

let tuple_1 = ("India", 7, 90, 90.432);
if let(_, 7, 9, 78.99) = tuple_1{
    println!("Works with tuples too");
}

let tuple_2 = ( 9, 7, 89, 12, "Okay");
if let(9, 7,89, 12, blank) = tuple_2 {
    println!("Everything {blank} mate?");
}

let tuple_3 = (89, 90, "Yes");
if let(9, 89, "Yes") = tuple_3{
    println!("Pattern did match");
}
else {
    println!("Pattern did not match");
}

Match Expression

let day_of_week = 2;
  match day_of_week {
    1 => {
      println!("Its Monday my dudes");
    },
    2 => {
      println!("It's Tuesday my dudes");
    },
    3 => {
      println!("It's Wednesday my dudes");
    },
    4 => {
      println!("It's Thursday my dudes");
    },
    5 => {
      println!("It's Friday my dudes");
    },
    6 => {
      println!("It's Saturday my dudes");
    },
    7 => {
      println!("It's Sunday my dudes");
    },
    _ => {
      println!("Default!")
    }
  };
}

Nested...If Expression

let nested_conditions = 89;
if nested_conditions == 89 {
    let just_a_value = 98;
    if just_a_value >= 97 {
        println!("Greater than 97");
    }
}

For Loop

for mut i in 0..15 {
  i-=1;
  println!("The value of i is : {i}");
}

While Loop

let mut check =  0;
while check < 11{
  println!("Check is : {check}");
  check+=1;
  println!("After incrementing: {check}");

  if check == 10{
    break; // stop while
  }
}

Loop keyword

loop {
  println!("hello world forever!");
}

The infinite loop indicated.
Break Statement

let mut i = 1;
loop {
  println!("i is {i}");
  if i > 100 {
    break;
  }
  i *= 2;
}

Continue Statement

for (v, c) in (0..10+1).enumerate(){
  println!("The {c} number loop");
  if v == 9{
    println!("Here we go continue?");
    continue;
  }
  println!{"The value of v is : {v}"};
}

#Rust Functions
Basic function


fn print_message(){
  println!("Hello, QuickRef.ME!");
}

fn main(){
  //Invoking a function in Rust.
  print_message();
}

Pass by Value

fn main()
{
  let x:u32 = 10;
  let y:u32 = 20;
  
  // => 200
  println!("Calc: {}", cal_rect(x, y));
}
fn cal_rect(x:u32, y:u32) -> u32
{
  x * y
}

Pass by Reference

fn main(){
  let mut by_ref = 3;      // => 3
  power_of_three(&mut by_ref);
  println!("{by_ref}");  // => 9
}

fn power_of_three(by_ref: &mut i32){
  // de-referencing is important
  *by_ref = *by_ref * *by_ref;
  println!("{by_ref}");  // => 9
}

Returns

fn main(){
  let (mut radius, mut pi) = (3.0, 3.14);
  let(area, _perimeter) = calculate (
      &mut radius,
      &mut pi
  );
  println!("The area and the perimeter of the circle are: {area} & {_perimeter}");
}

fn calculate(radius : &mut f64, pi: &mut f64) -> (f64, f64){
  let perimeter = 2.0 * *pi * *radius;
  let area = *pi * *radius * *radius;
  return (area, perimeter);
}

Arrays as Arguments

fn main(){
  let mut array: [i32 ; 5] = [1,2,3,4,6];
  print_arrays(array);
  println!("The elements: {array:?}");
}

fn print_arrays(mut array:[i32; 5]) {
  array[0] = 89;
  array[1] = 90;
  array[2] = 91;
  array[3] = 92;
  array[4] = 93;
  println!("The elements: {array:?}");
}

Returning Arrays


fn main(){
  let mut arr:[i32; 5] = [2,4,6,8,10];
  multiply(arr);
  println!("The array is : {:?}", multiply(arr));
}

fn multiply (mut arr: [i32 ; 5]) -> [i32 ; 5]{
  arr[2] = 90;
  for mut i in 0..5 {
      arr[i] = arr[i] * arr[2];
  }
  return arr;
}

#Misc
Type Casting

let a_int = 90; // int
// int to float
let mut type_cast = (a_int as f64);

let orginal: char = 'I';
// char to int => 73
let type_casted: i64 = orginal as i64;

To perform type-casting in Rust one must use the as keyword.
Borrowing

let mut foo = 4;
let mut borrowed_foo = &foo;
println!("{borrowed_foo}");

let mut bar = 3;
let mut mutable_borrowed_bar = &mut bar;
println!("{mutable_borrowed_bar}");

Here borrowed value borrows the value from value one using & operator.
De-referencing

let mut borrow = 10;
let deref = &mut borrow;

println!("{}", *deref);

De-referencing in rust can be done using the * operator
Variable Scope

{
  // The scope limited to this braces
  let a_number = 1;
}
println!("{a_number}");

This will produce error as the scope of the variable a_number ends at the braces
#Also see

    The Rust Document (doc.rust-lang.org)
    The Rust Reference (doc.rust-lang.org)
    Rust Cheatsheet (phaiax.github.io)

Top Cheatsheet

Python Cheatsheet

Quick Reference

Vim Cheatsheet

Quick Reference

JavaScript Cheatsheet

Quick Reference

Bash Cheatsheet

Quick Reference
Recent Cheatsheet

Aspect Ratio Cheatsheet

Quick Reference

HTML Characters Entities Cheatsheet

Quick Reference

ISO 639-1 Language Code Cheatsheet

Quick Reference

Rust Cheatsheet

Quick Reference
QuickRef.ME

Share quick reference and cheat sheet for developers.
#Notes

© 2022 QuickRef.ME, All rights reserved.




logo
Crate std

    Version 1.64.0 (a55dd71d5 2022-09-19)
    All Items

    Primitive Types
    Modules
    Macros
    Keywords

Crates

    alloc
    core
    proc_macro
    std
    test

Change settings
Crate std
1.0.0 · source · [−]
The Rust Standard Library

The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the broader Rust ecosystem. It offers core types, like Vec<T> and Option<T>, library-defined operations on language primitives, standard macros, I/O and multithreading, among many other things.

std is available to all Rust crates by default. Therefore, the standard library can be accessed in use statements through the path std, as in use std::env.
How to read this documentation

If you already know the name of what you are looking for, the fastest way to find it is to use the search bar at the top of the page.

Otherwise, you may want to jump to one of these useful sections:

    std::* modules
    Primitive types
    Standard macros
    The Rust Prelude

If this is your first time, the documentation for the standard library is written to be casually perused. Clicking on interesting things should generally lead you to interesting places. Still, there are important bits you don’t want to miss, so read on for a tour of the standard library and its documentation!

Once you are familiar with the contents of the standard library you may begin to find the verbosity of the prose distracting. At this stage in your development you may want to press the [-] button near the top of the page to collapse it into a more skimmable view.

While you are looking at that [-] button also notice the source link. Rust’s API documentation comes with the source code and you are encouraged to read it. The standard library source is generally high quality and a peek behind the curtains is often enlightening.
What is in the standard library documentation?

First of all, The Rust Standard Library is divided into a number of focused modules, all listed further down this page. These modules are the bedrock upon which all of Rust is forged, and they have mighty names like std::slice and std::cmp. Modules’ documentation typically includes an overview of the module along with examples, and are a smart place to start familiarizing yourself with the library.

Second, implicit methods on primitive types are documented here. This can be a source of confusion for two reasons:

    While primitives are implemented by the compiler, the standard library implements methods directly on the primitive types (and it is the only library that does so), which are documented in the section on primitives.
    The standard library exports many modules with the same name as primitive types. These define additional items related to the primitive type, but not the all-important methods.

So for example there is a page for the primitive type i32 that lists all the methods that can be called on 32-bit integers (very useful), and there is a page for the module std::i32 that documents the constant values MIN and MAX (rarely useful).

Note the documentation for the primitives str and [T] (also called ‘slice’). Many method calls on String and Vec<T> are actually calls to methods on str and [T] respectively, via deref coercions.

Third, the standard library defines The Rust Prelude, a small collection of items - mostly traits - that are imported into every module of every crate. The traits in the prelude are pervasive, making the prelude documentation a good entry point to learning about the library.

And finally, the standard library exports a number of standard macros, and lists them on this page (technically, not all of the standard macros are defined by the standard library - some are defined by the compiler - but they are documented here the same). Like the prelude, the standard macros are imported by default into all crates.
Contributing changes to the documentation

Check out the rust contribution guidelines here. The source for this documentation can be found on GitHub. To contribute changes, make sure you read the guidelines first, then submit pull-requests for your suggested changes.

Contributions are appreciated! If you see a part of the docs that can be improved, submit a PR, or chat with us first on Discord #docs.
A Tour of The Rust Standard Library

The rest of this crate documentation is dedicated to pointing out notable features of The Rust Standard Library.
Containers and collections

The option and result modules define optional and error-handling types, Option<T> and Result<T, E>. The iter module defines Rust’s iterator trait, Iterator, which works with the for loop to access collections.

The standard library exposes three common ways to deal with contiguous regions of memory:

    Vec<T> - A heap-allocated vector that is resizable at runtime.
    [T; N] - An inline array with a fixed size at compile time.
    [T] - A dynamically sized slice into any other kind of contiguous storage, whether heap-allocated or not.

Slices can only be handled through some kind of pointer, and as such come in many flavors such as:

    &[T] - shared slice
    &mut [T] - mutable slice
    Box<[T]> - owned slice

str, a UTF-8 string slice, is a primitive type, and the standard library defines many methods for it. Rust strs are typically accessed as immutable references: &str. Use the owned String for building and mutating strings.

For converting to strings use the format! macro, and for converting from strings use the FromStr trait.

Data may be shared by placing it in a reference-counted box or the Rc type, and if further contained in a Cell or RefCell, may be mutated as well as shared. Likewise, in a concurrent setting it is common to pair an atomically-reference-counted box, Arc, with a Mutex to get the same effect.

The collections module defines maps, sets, linked lists and other typical collection types, including the common HashMap<K, V>.
Platform abstractions and I/O

Besides basic data types, the standard library is largely concerned with abstracting over differences in common platforms, most notably Windows and Unix derivatives.

Common types of I/O, including files, TCP, UDP, are defined in the io, fs, and net modules.

The thread module contains Rust’s threading abstractions. sync contains further primitive shared memory types, including atomic and mpsc, which contains the channel types for message passing.
Primitive Types
neverExperimental

The ! type, also called “never”.
array

A fixed-size array, denoted [T; N], for the element type, T, and the non-negative compile-time constant size, N.
bool

The boolean type.
char

A character type.
f32

A 32-bit floating point type (specifically, the “binary32” type defined in IEEE 754-2008).
f64

A 64-bit floating point type (specifically, the “binary64” type defined in IEEE 754-2008).
fn

Function pointers, like fn(usize) -> bool.
i8

The 8-bit signed integer type.
i16

The 16-bit signed integer type.
i32

The 32-bit signed integer type.
i64

The 64-bit signed integer type.
i128

The 128-bit signed integer type.
isize

The pointer-sized signed integer type.
pointer

Raw, unsafe pointers, *const T, and *mut T.
reference

References, both shared and mutable.
slice

A dynamically-sized view into a contiguous sequence, [T]. Contiguous here means that elements are laid out so that every element is the same distance from its neighbors.
str

String slices.
tuple

A finite heterogeneous sequence, (T, U, ..).
u8

The 8-bit unsigned integer type.
u16

The 16-bit unsigned integer type.
u32

The 32-bit unsigned integer type.
u64

The 64-bit unsigned integer type.
u128

The 128-bit unsigned integer type.
unit

The () type, also called “unit”.
usize

The pointer-sized unsigned integer type.
Modules
assert_matchesExperimental

Unstable module containing the unstable assert_matches macro.
async_iterExperimental

Composable asynchronous iteration.
backtraceExperimental

Support for capturing a stack backtrace of an OS thread
intrinsicsExperimental

Compiler intrinsics.
lazyExperimental

Lazy values and one-time initialization of static data.
simdExperimental

Portable SIMD module.
alloc

Memory allocation APIs.
any

This module contains the Any trait, which enables dynamic typing of any 'static type through runtime reflection. It also contains the Provider trait and accompanying API, which enable trait objects to provide data based on typed requests, an alternate form of runtime reflection.
arch

SIMD and vendor intrinsics module.
array

Helper functions and types for fixed-length arrays.
ascii

Operations on ASCII strings and characters.
borrow

A module for working with borrowed data.
boxed

A pointer type for heap allocation.
cell

Shareable mutable containers.
char

A character type.
clone

The Clone trait for types that cannot be ‘implicitly copied’.
cmp

Functionality for ordering and comparison.
collections

Collection types.
convert

Traits for conversions between types.
default

The Default trait for types which may have meaningful default values.
env

Inspection and manipulation of the process’s environment.
error

Interfaces for working with Errors.
f32

Constants specific to the f32 single-precision floating point type.
f64

Constants specific to the f64 double-precision floating point type.
ffi

Utilities related to FFI bindings.
fmt

Utilities for formatting and printing Strings.
fs

Filesystem manipulation operations.
future

Asynchronous basic functionality.
hash

Generic hashing support.
hint

Hints to compiler that affects how code should be emitted or optimized. Hints may be compile time or runtime.
i8Deprecation planned

Constants for the 8-bit signed integer type.
i16Deprecation planned

Constants for the 16-bit signed integer type.
i32Deprecation planned

Constants for the 32-bit signed integer type.
i64Deprecation planned

Constants for the 64-bit signed integer type.
i128Deprecation planned

Constants for the 128-bit signed integer type.
io

Traits, helpers, and type definitions for core I/O functionality.
isizeDeprecation planned

Constants for the pointer-sized signed integer type.
iter

Composable external iteration.
marker

Primitive traits and types representing basic properties of types.
mem

Basic functions for dealing with memory.
net

Networking primitives for TCP/UDP communication.
num

Additional functionality for numerics.
ops

Overloadable operators.
option

Optional values.
os

OS-specific functionality.
panic

Panic support in the standard library.
path

Cross-platform path manipulation.
pin

Types that pin data to its location in memory.
prelude

The Rust Prelude
primitive

This module reexports the primitive types to allow usage that is not possibly shadowed by other declared types.
process

A module for working with processes.
ptr

Manually manage memory through raw pointers.
rc

Single-threaded reference-counting pointers. ‘Rc’ stands for ‘Reference Counted’.
result

Error handling with the Result type.
slice

A dynamically-sized view into a contiguous sequence, [T].
str

Unicode string slices.
string

A UTF-8–encoded, growable string.
sync

Useful synchronization primitives.
task

Types and Traits for working with asynchronous tasks.
thread

Native threads.
time

Temporal quantification.
u8Deprecation planned

Constants for the 8-bit unsigned integer type.
u16Deprecation planned

Constants for the 16-bit unsigned integer type.
u32Deprecation planned

Constants for the 32-bit unsigned integer type.
u64Deprecation planned

Constants for the 64-bit unsigned integer type.
u128Deprecation planned

Constants for the 128-bit unsigned integer type.
usizeDeprecation planned

Constants for the pointer-sized unsigned integer type.
vec

A contiguous growable array type with heap-allocated contents, written Vec<T>.
Macros
concat_bytesExperimental

Concatenates literals into a byte slice.
concat_identsExperimental

Concatenates identifiers into one identifier.
const_format_argsExperimental

Same as format_args, but can be used in some const contexts.
format_args_nlExperimental

Same as format_args, but adds a newline in the end.
log_syntaxExperimental

Prints passed tokens into the standard output.
trace_macrosExperimental

Enables or disables tracing functionality used for debugging other macros.
assert

Asserts that a boolean expression is true at runtime.
assert_eq

Asserts that two expressions are equal to each other (using PartialEq).
assert_ne

Asserts that two expressions are not equal to each other (using PartialEq).
cfg

Evaluates boolean combinations of configuration flags at compile-time.
column

Expands to the column number at which it was invoked.
compile_error

Causes compilation to fail with the given error message when encountered.
concat

Concatenates literals into a static string slice.
dbg

Prints and returns the value of a given expression for quick and dirty debugging.
debug_assert

Asserts that a boolean expression is true at runtime.
debug_assert_eq

Asserts that two expressions are equal to each other.
debug_assert_ne

Asserts that two expressions are not equal to each other.
env

Inspects an environment variable at compile time.
eprint

Prints to the standard error.
eprintln

Prints to the standard error, with a newline.
file

Expands to the file name in which it was invoked.
format

Creates a String using interpolation of runtime expressions.
format_args

Constructs parameters for the other string-formatting macros.
include

Parses a file as an expression or an item according to the context.
include_bytes

Includes a file as a reference to a byte array.
include_str

Includes a UTF-8 encoded file as a string.
is_x86_feature_detectedx86 or x86-64

A macro to test at runtime whether a CPU feature is available on x86/x86-64 platforms.
line

Expands to the line number on which it was invoked.
matches

Returns whether the given expression matches any of the given patterns.
module_path

Expands to a string that represents the current module path.
option_env

Optionally inspects an environment variable at compile time.
panic

Panics the current thread.
print

Prints to the standard output.
println

Prints to the standard output, with a newline.
stringify

Stringifies its arguments.
thread_local

Declare a new thread local storage key of type std::thread::LocalKey.
todo

Indicates unfinished code.
tryDeprecated

Unwraps a result or propagates its error.
unimplemented

Indicates unimplemented code by panicking with a message of “not implemented”.
unreachable

Indicates unreachable code.
vec

Creates a Vec containing the arguments.
write

Writes formatted data into a buffer.
writeln

Write formatted data into a buffer, with a newline appended.
Keywords
SelfTy

The implementing type within a trait or impl block, or the current type within a type definition.
as

Cast between types, or rename an import.
async

Return a Future instead of blocking the current thread.
await

Suspend execution until the result of a Future is ready.
break

Exit early from a loop.
const

Compile-time constants, compile-time evaluable functions, and raw pointers.
continue

Skip to the next iteration of a loop.
crate

A Rust binary or library.
dyn

dyn is a prefix of a trait object’s type.
else

What expression to evaluate when an if condition evaluates to false.
enum

A type that can be any one of several variants.
extern

Link to or import external code.
false

A value of type bool representing logical false.
fn

A function or function pointer.
for

Iteration with in, trait implementation with impl, or higher-ranked trait bounds (for<'a>).
if

Evaluate a block if a condition holds.
impl

Implement some functionality for a type.
in

Iterate over a series of values with for.
let

Bind a value to a variable.
loop

Loop indefinitely.
match

Control flow based on pattern matching.
mod

Organize code into modules.
move

Capture a closure’s environment by value.
mut

A mutable variable, reference, or pointer.
pub

Make an item visible to others.
ref

Bind by reference during pattern matching.
return

Return a value from a function.
self

The receiver of a method, or the current module.
static

A static item is a value which is valid for the entire duration of your program (a 'static lifetime).
struct

A type that is composed of other types.
super

The parent of the current module.
trait

A common interface for a group of types.
true

A value of type bool representing logical true.
type

Define an alias for an existing type.
union

The Rust equivalent of a C-style union.
unsafe

Code or interfaces whose memory safety cannot be verified by the type system.
use

Import or rename items from other crates or modules.
where

Add constraints that must be upheld to use an item.
while

Loop while a condition is upheld.



logo
Crate std

    Version 1.64.0 (a55dd71d5 2022-09-19)
    All Items

    Primitive Types
    Modules
    Macros
    Keywords

Crates

    alloc
    core
    proc_macro
    std
    test

Change settings
Crate std
1.0.0 · source · [−]
The Rust Standard Library

The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the broader Rust ecosystem. It offers core types, like Vec<T> and Option<T>, library-defined operations on language primitives, standard macros, I/O and multithreading, among many other things.

std is available to all Rust crates by default. Therefore, the standard library can be accessed in use statements through the path std, as in use std::env.
How to read this documentation

If you already know the name of what you are looking for, the fastest way to find it is to use the search bar at the top of the page.

Otherwise, you may want to jump to one of these useful sections:

    std::* modules
    Primitive types
    Standard macros
    The Rust Prelude

If this is your first time, the documentation for the standard library is written to be casually perused. Clicking on interesting things should generally lead you to interesting places. Still, there are important bits you don’t want to miss, so read on for a tour of the standard library and its documentation!

Once you are familiar with the contents of the standard library you may begin to find the verbosity of the prose distracting. At this stage in your development you may want to press the [-] button near the top of the page to collapse it into a more skimmable view.

While you are looking at that [-] button also notice the source link. Rust’s API documentation comes with the source code and you are encouraged to read it. The standard library source is generally high quality and a peek behind the curtains is often enlightening.
What is in the standard library documentation?

First of all, The Rust Standard Library is divided into a number of focused modules, all listed further down this page. These modules are the bedrock upon which all of Rust is forged, and they have mighty names like std::slice and std::cmp. Modules’ documentation typically includes an overview of the module along with examples, and are a smart place to start familiarizing yourself with the library.

Second, implicit methods on primitive types are documented here. This can be a source of confusion for two reasons:

    While primitives are implemented by the compiler, the standard library implements methods directly on the primitive types (and it is the only library that does so), which are documented in the section on primitives.
    The standard library exports many modules with the same name as primitive types. These define additional items related to the primitive type, but not the all-important methods.

So for example there is a page for the primitive type i32 that lists all the methods that can be called on 32-bit integers (very useful), and there is a page for the module std::i32 that documents the constant values MIN and MAX (rarely useful).

Note the documentation for the primitives str and [T] (also called ‘slice’). Many method calls on String and Vec<T> are actually calls to methods on str and [T] respectively, via deref coercions.

Third, the standard library defines The Rust Prelude, a small collection of items - mostly traits - that are imported into every module of every crate. The traits in the prelude are pervasive, making the prelude documentation a good entry point to learning about the library.

And finally, the standard library exports a number of standard macros, and lists them on this page (technically, not all of the standard macros are defined by the standard library - some are defined by the compiler - but they are documented here the same). Like the prelude, the standard macros are imported by default into all crates.
Contributing changes to the documentation

Check out the rust contribution guidelines here. The source for this documentation can be found on GitHub. To contribute changes, make sure you read the guidelines first, then submit pull-requests for your suggested changes.

Contributions are appreciated! If you see a part of the docs that can be improved, submit a PR, or chat with us first on Discord #docs.
A Tour of The Rust Standard Library

The rest of this crate documentation is dedicated to pointing out notable features of The Rust Standard Library.
Containers and collections

The option and result modules define optional and error-handling types, Option<T> and Result<T, E>. The iter module defines Rust’s iterator trait, Iterator, which works with the for loop to access collections.

The standard library exposes three common ways to deal with contiguous regions of memory:

    Vec<T> - A heap-allocated vector that is resizable at runtime.
    [T; N] - An inline array with a fixed size at compile time.
    [T] - A dynamically sized slice into any other kind of contiguous storage, whether heap-allocated or not.

Slices can only be handled through some kind of pointer, and as such come in many flavors such as:

    &[T] - shared slice
    &mut [T] - mutable slice
    Box<[T]> - owned slice

str, a UTF-8 string slice, is a primitive type, and the standard library defines many methods for it. Rust strs are typically accessed as immutable references: &str. Use the owned String for building and mutating strings.

For converting to strings use the format! macro, and for converting from strings use the FromStr trait.

Data may be shared by placing it in a reference-counted box or the Rc type, and if further contained in a Cell or RefCell, may be mutated as well as shared. Likewise, in a concurrent setting it is common to pair an atomically-reference-counted box, Arc, with a Mutex to get the same effect.

The collections module defines maps, sets, linked lists and other typical collection types, including the common HashMap<K, V>.
Platform abstractions and I/O

Besides basic data types, the standard library is largely concerned with abstracting over differences in common platforms, most notably Windows and Unix derivatives.

Common types of I/O, including files, TCP, UDP, are defined in the io, fs, and net modules.

The thread module contains Rust’s threading abstractions. sync contains further primitive shared memory types, including atomic and mpsc, which contains the channel types for message passing.
Primitive Types
neverExperimental

The ! type, also called “never”.
array

A fixed-size array, denoted [T; N], for the element type, T, and the non-negative compile-time constant size, N.
bool

The boolean type.
char

A character type.
f32

A 32-bit floating point type (specifically, the “binary32” type defined in IEEE 754-2008).
f64

A 64-bit floating point type (specifically, the “binary64” type defined in IEEE 754-2008).
fn

Function pointers, like fn(usize) -> bool.
i8

The 8-bit signed integer type.
i16

The 16-bit signed integer type.
i32

The 32-bit signed integer type.
i64

The 64-bit signed integer type.
i128

The 128-bit signed integer type.
isize

The pointer-sized signed integer type.
pointer

Raw, unsafe pointers, *const T, and *mut T.
reference

References, both shared and mutable.
slice

A dynamically-sized view into a contiguous sequence, [T]. Contiguous here means that elements are laid out so that every element is the same distance from its neighbors.
str

String slices.
tuple

A finite heterogeneous sequence, (T, U, ..).
u8

The 8-bit unsigned integer type.
u16

The 16-bit unsigned integer type.
u32

The 32-bit unsigned integer type.
u64

The 64-bit unsigned integer type.
u128

The 128-bit unsigned integer type.
unit

The () type, also called “unit”.
usize

The pointer-sized unsigned integer type.
Modules
assert_matchesExperimental

Unstable module containing the unstable assert_matches macro.
async_iterExperimental

Composable asynchronous iteration.
backtraceExperimental

Support for capturing a stack backtrace of an OS thread
intrinsicsExperimental

Compiler intrinsics.
lazyExperimental

Lazy values and one-time initialization of static data.
simdExperimental

Portable SIMD module.
alloc

Memory allocation APIs.
any

This module contains the Any trait, which enables dynamic typing of any 'static type through runtime reflection. It also contains the Provider trait and accompanying API, which enable trait objects to provide data based on typed requests, an alternate form of runtime reflection.
arch

SIMD and vendor intrinsics module.
array

Helper functions and types for fixed-length arrays.
ascii

Operations on ASCII strings and characters.
borrow

A module for working with borrowed data.
boxed

A pointer type for heap allocation.
cell

Shareable mutable containers.
char

A character type.
clone

The Clone trait for types that cannot be ‘implicitly copied’.
cmp

Functionality for ordering and comparison.
collections

Collection types.
convert

Traits for conversions between types.
default

The Default trait for types which may have meaningful default values.
env

Inspection and manipulation of the process’s environment.
error

Interfaces for working with Errors.
f32

Constants specific to the f32 single-precision floating point type.
f64

Constants specific to the f64 double-precision floating point type.
ffi

Utilities related to FFI bindings.
fmt

Utilities for formatting and printing Strings.
fs

Filesystem manipulation operations.
future

Asynchronous basic functionality.
hash

Generic hashing support.
hint

Hints to compiler that affects how code should be emitted or optimized. Hints may be compile time or runtime.
i8Deprecation planned

Constants for the 8-bit signed integer type.
i16Deprecation planned

Constants for the 16-bit signed integer type.
i32Deprecation planned

Constants for the 32-bit signed integer type.
i64Deprecation planned

Constants for the 64-bit signed integer type.
i128Deprecation planned

Constants for the 128-bit signed integer type.
io

Traits, helpers, and type definitions for core I/O functionality.
isizeDeprecation planned

Constants for the pointer-sized signed integer type.
iter

Composable external iteration.
marker

Primitive traits and types representing basic properties of types.
mem

Basic functions for dealing with memory.
net

Networking primitives for TCP/UDP communication.
num

Additional functionality for numerics.
ops

Overloadable operators.
option

Optional values.
os

OS-specific functionality.
panic

Panic support in the standard library.
path

Cross-platform path manipulation.
pin

Types that pin data to its location in memory.
prelude

The Rust Prelude
primitive

This module reexports the primitive types to allow usage that is not possibly shadowed by other declared types.
process

A module for working with processes.
ptr

Manually manage memory through raw pointers.
rc

Single-threaded reference-counting pointers. ‘Rc’ stands for ‘Reference Counted’.
result

Error handling with the Result type.
slice

A dynamically-sized view into a contiguous sequence, [T].
str

Unicode string slices.
string

A UTF-8–encoded, growable string.
sync

Useful synchronization primitives.
task

Types and Traits for working with asynchronous tasks.
thread

Native threads.
time

Temporal quantification.
u8Deprecation planned

Constants for the 8-bit unsigned integer type.
u16Deprecation planned

Constants for the 16-bit unsigned integer type.
u32Deprecation planned

Constants for the 32-bit unsigned integer type.
u64Deprecation planned

Constants for the 64-bit unsigned integer type.
u128Deprecation planned

Constants for the 128-bit unsigned integer type.
usizeDeprecation planned

Constants for the pointer-sized unsigned integer type.
vec

A contiguous growable array type with heap-allocated contents, written Vec<T>.
Macros
concat_bytesExperimental

Concatenates literals into a byte slice.
concat_identsExperimental

Concatenates identifiers into one identifier.
const_format_argsExperimental

Same as format_args, but can be used in some const contexts.
format_args_nlExperimental

Same as format_args, but adds a newline in the end.
log_syntaxExperimental

Prints passed tokens into the standard output.
trace_macrosExperimental

Enables or disables tracing functionality used for debugging other macros.
assert

Asserts that a boolean expression is true at runtime.
assert_eq

Asserts that two expressions are equal to each other (using PartialEq).
assert_ne

Asserts that two expressions are not equal to each other (using PartialEq).
cfg

Evaluates boolean combinations of configuration flags at compile-time.
column

Expands to the column number at which it was invoked.
compile_error

Causes compilation to fail with the given error message when encountered.
concat

Concatenates literals into a static string slice.
dbg

Prints and returns the value of a given expression for quick and dirty debugging.
debug_assert

Asserts that a boolean expression is true at runtime.
debug_assert_eq

Asserts that two expressions are equal to each other.
debug_assert_ne

Asserts that two expressions are not equal to each other.
env

Inspects an environment variable at compile time.
eprint

Prints to the standard error.
eprintln

Prints to the standard error, with a newline.
file

Expands to the file name in which it was invoked.
format

Creates a String using interpolation of runtime expressions.
format_args

Constructs parameters for the other string-formatting macros.
include

Parses a file as an expression or an item according to the context.
include_bytes

Includes a file as a reference to a byte array.
include_str

Includes a UTF-8 encoded file as a string.
is_x86_feature_detectedx86 or x86-64

A macro to test at runtime whether a CPU feature is available on x86/x86-64 platforms.
line

Expands to the line number on which it was invoked.
matches

Returns whether the given expression matches any of the given patterns.
module_path

Expands to a string that represents the current module path.
option_env

Optionally inspects an environment variable at compile time.
panic

Panics the current thread.
print

Prints to the standard output.
println

Prints to the standard output, with a newline.
stringify

Stringifies its arguments.
thread_local

Declare a new thread local storage key of type std::thread::LocalKey.
todo

Indicates unfinished code.
tryDeprecated

Unwraps a result or propagates its error.
unimplemented

Indicates unimplemented code by panicking with a message of “not implemented”.
unreachable

Indicates unreachable code.
vec

Creates a Vec containing the arguments.
write

Writes formatted data into a buffer.
writeln

Write formatted data into a buffer, with a newline appended.
Keywords
SelfTy

The implementing type within a trait or impl block, or the current type within a type definition.
as

Cast between types, or rename an import.
async

Return a Future instead of blocking the current thread.
await

Suspend execution until the result of a Future is ready.
break

Exit early from a loop.
const

Compile-time constants, compile-time evaluable functions, and raw pointers.
continue

Skip to the next iteration of a loop.
crate

A Rust binary or library.
dyn

dyn is a prefix of a trait object’s type.
else

What expression to evaluate when an if condition evaluates to false.
enum

A type that can be any one of several variants.
extern

Link to or import external code.
false

A value of type bool representing logical false.
fn

A function or function pointer.
for

Iteration with in, trait implementation with impl, or higher-ranked trait bounds (for<'a>).
if

Evaluate a block if a condition holds.
impl

Implement some functionality for a type.
in

Iterate over a series of values with for.
let

Bind a value to a variable.
loop

Loop indefinitely.
match

Control flow based on pattern matching.
mod

Organize code into modules.
move

Capture a closure’s environment by value.
mut

A mutable variable, reference, or pointer.
pub

Make an item visible to others.
ref

Bind by reference during pattern matching.
return

Return a value from a function.
self

The receiver of a method, or the current module.
static

A static item is a value which is valid for the entire duration of your program (a 'static lifetime).
struct

A type that is composed of other types.
super

The parent of the current module.
trait

A common interface for a group of types.
true

A value of type bool representing logical true.
type

Define an alias for an existing type.
union

The Rust equivalent of a C-style union.
unsafe

Code or interfaces whose memory safety cannot be verified by the type system.
use

Import or rename items from other crates or modules.
where

Add constraints that must be upheld to use an item.
while

Loop while a condition is upheld.



